<<<<<<< HEAD
=======
// accounts app
from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.utils import timezone
from datetime import timedelta
from django.core.exceptions import ValidationError
import uuid


class CustomUserManager(BaseUserManager):
    # ensure the email is normalized and user_type is provided
    def create_user(self, email, full_name, user_type, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        if not user_type:
            raise ValueError("User type must be set (landlord or tenant)")

        email = self.normalize_email(email)
        user = self.model(
            email=email,
            full_name=full_name,
            user_type=user_type,
            **extra_fields
        )
        user.set_password(password)
        user.save(using=self._db)

        # Auto-assign free trial for landlords
        if user_type == "landlord":
            Subscription.objects.create(
                user=user,
                plan="free",
                expiry_date=timezone.now() + timedelta(days=60)
            )
            # generate a public landlord_code
            if not getattr(user, 'landlord_code', None):
                user.landlord_code = f"L-{uuid.uuid4().hex[:10].upper()}"
                user.save(update_fields=['landlord_code'])

        return user

    def create_superuser(self, email, full_name, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        # set default user_type if not provided
        user_type = extra_fields.pop("user_type", "landlord")

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self.create_user(
            email=email,
            full_name=full_name,
            user_type=user_type,
            password=password,
            **extra_fields
        )


class CustomUser(AbstractBaseUser, PermissionsMixin):
    email = models.EmailField(unique=True)
    full_name = models.CharField(max_length=120, default='')
    government_id = models.CharField(max_length=20, blank=True, null=True)
    id_document = models.ImageField(upload_to='id_documents/', null=True, blank=True)
    landlord_code = models.CharField(max_length=50, unique=True, null=True, blank=True)
    date_joined = models.DateTimeField(auto_now_add=True)
    type = [('landlord', 'Landlord'), ('tenant', 'Tenant')]
    user_type = models.CharField(max_length=10, choices=type)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)
    mpesa_till_number = models.CharField(max_length=20, blank=True, null=True)
    phone_number = models.CharField(max_length=30, blank=True, null=True)
    emergency_contact = models.CharField(max_length=30, blank=True, null=True)
    
    # ADD THESE NEW FIELDS:
    address = models.TextField(blank=True, null=True, help_text="Business or physical address")
    website = models.URLField(blank=True, null=True, help_text="Business website URL")
    
    reminder_mode = models.CharField(
        max_length=20,
        choices=[('days_before', 'Days Before Due Date'), ('fixed_day', 'Fixed Day of Month')],
        default='days_before'
    )
    reminder_value = models.IntegerField(default=10)

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['full_name']
    objects = CustomUserManager()

    # Check if user has an active subscription
    def has_active_subscription(self):
        if hasattr(self, "subscription"):
            return self.subscription.is_active()
        return False

    def __str__(self):
        return f"{self.full_name} ({self.email})"


class Subscription(models.Model):
    PLAN_CHOICES = [
        ("free", "Free (60-day trial)"),
        ("starter", "Starter (up to 10 units)"),
        ("basic", "Basic (10-50 units)"),
        ("professional", "Professional (50-100 units)"),
        ("onetime", "One-time (Unlimited properties)"),
    ]

    user = models.OneToOneField(CustomUser, on_delete=models.CASCADE, related_name="subscription")
    plan = models.CharField(max_length=20, choices=PLAN_CHOICES, default="free")
    start_date = models.DateTimeField(auto_now_add=True)
    expiry_date = models.DateTimeField(null=True, blank=True)

    def save(self, *args, **kwargs):
        # Set expiry dates based on plan
        if not self.expiry_date:
            if self.plan == "free":
                self.expiry_date = timezone.now() + timedelta(days=60)
            elif self.plan == "starter":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            elif self.plan == "basic":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            elif self.plan == "professional":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            # "onetime" could remain None for lifetime access
        
        super().save(*args, **kwargs)

    # Check if subscription is still valid
    def is_active(self):
        return self.expiry_date is None or self.expiry_date > timezone.now()

    def __str__(self):
        return f"{self.user.email} - {self.plan}"


class Property(models.Model):
    landlord = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    name = models.CharField(max_length=255)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=100)
    unit_count = models.IntegerField()   # integer count of units for this property

    def __str__(self):
        return f"{self.name}, {self.city}"

    def __str__(self):
        return f"{self.name}, {self.city}"

# TODO: Ensure that the landlord can only have a certain amount of units linked to property unit count
class UnitType(models.Model):
    landlord = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='unit_types')
    name = models.CharField(max_length=50)
    deposit = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    number_of_units = models.IntegerField(default=0, help_text="Number of units of this type to create automatically")

    def __str__(self):
        return f"{self.landlord.email} - {self.name}"


class Unit(models.Model):
    property_obj = models.ForeignKey(
        Property,
        on_delete=models.CASCADE,
        related_name="unit_list",
        db_column="property_id"
    )
    # system-generated unit code (unique per unit)
    unit_code = models.CharField(max_length=30, unique=True, default='')
    unit_number = models.CharField(max_length=10)
    floor = models.IntegerField(null=True, blank=True)
    bedrooms = models.IntegerField(default=0)
    bathrooms = models.IntegerField(default=0)

    unit_type = models.ForeignKey(UnitType, on_delete=models.SET_NULL, null=True, blank=True)

    rent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    tenant = models.OneToOneField(CustomUser, on_delete=models.SET_NULL, null=True, blank=True)

    rent_paid = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent_remaining = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent_due_date = models.DateField(null=True, blank=True)

    deposit = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    is_available = models.BooleanField(default=True)

    assigned_date = models.DateTimeField(null=True, blank=True)
    left_date = models.DateTimeField(null=True, blank=True)

    @property
    def balance(self):
        return self.rent_remaining - self.rent_paid

    def clean(self):
        current_units = self.__class__.objects.filter(property_obj=self.property_obj).count()
        if self.property_obj.unit_count is not None and current_units >= self.property_obj.unit_count:
            raise ValidationError("The number of units for this property has reached the limit.")

    def save(self, *args, **kwargs):
        # Calculate rent_remaining as rent - rent_paid
        self.rent_remaining = self.rent - self.rent_paid

        if self.pk:  # existing unit
            old_unit = Unit.objects.get(pk=self.pk)
            if old_unit.tenant != self.tenant:
                if self.tenant and not self.assigned_date:
                    self.assigned_date = timezone.now()
                elif not self.tenant and old_unit.tenant:
                    self.left_date = timezone.now()
        else:  # new unit
            if self.tenant:
                self.assigned_date = timezone.now()
        super().save(*args, **kwargs)


    def __str__(self):
        return f"{self.property_obj.name} - Unit {self.unit_number}"



# REMINDER: payments is shown in the Unit model as rent_paid and rent_remaining
# TODO: Protect the subscription features using a decorator or middleware to ensure only subscribed users can access them
# TODO: Ensure payments for subscription and rent are two different things
from .models import CustomUser, Property, Unit, UnitType
from rest_framework import serializers

from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_encode
from django.utils.encoding import force_bytes
from django.core.mail import send_mail

# Overide the token to use email instead of username for JWT authentication
# accounts/serializers.py
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework import serializers
from django.contrib.auth import authenticate
from .models import CustomUser

class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    username_field = "email"

    user_type = serializers.CharField(write_only=True)

    def validate(self, attrs):
        email = attrs.get("email")
        password = attrs.get("password")
        user_type = attrs.get("user_type")

        if email and password and user_type:
            user = authenticate(self.context['request'], email=email, password=password)
            if not user:
                raise serializers.ValidationError("Invalid email or password")
            if user.user_type not in ['tenant', 'landlord']:
                raise serializers.ValidationError("Invalid user type")
            if user.user_type != user_type:
                raise serializers.ValidationError("User type does not match")
            if not user.is_active:
                raise serializers.ValidationError("User account is disabled")
        else:
            raise serializers.ValidationError("Must include 'email', 'password', and 'user_type'")

        data = super().validate(attrs)
        data['user_type'] = user_type
        return data



class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = [
            'id',
            'email',
            'full_name',
            'government_id',
            'id_document',
            'landlord_code',
            'date_joined',
            'user_type',
            'is_active',
            'is_staff',
            'is_superuser',
            'mpesa_till_number',
            'phone_number',
            'emergency_contact',
            'reminder_mode',
            'reminder_value',
            'password'
        ]
        read_only_fields = ['id', 'date_joined', 'is_active', 'is_staff', 'is_superuser', 'landlord_code']
        extra_kwargs = {
            'password': {'write_only': True}
        }

    def create(self, validated_data):
        # Always use the manager to ensure password is hashed
        # adapt to new signature: email, full_name, user_type, password
        email = validated_data.pop('email')
        full_name = validated_data.pop('full_name')
        user_type = validated_data.pop('user_type')
        password = validated_data.pop('password', None)
        user = CustomUser.objects.create_user(email=email, full_name=full_name, user_type=user_type, password=password, **validated_data)
        return user

    def update(self, instance, validated_data):
        for attr, value in validated_data.items():
            if attr == 'password':
                instance.set_password(value)
            else:
                setattr(instance, attr, value)
        instance.save()
        return instance

    def validate_phone_number(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid phone number in international format, e.g. +2547XXXXXXXX")
        return value

    def validate_emergency_contact(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid emergency contact phone number in international format")
        return value

        
class PropertySerializer(serializers.ModelSerializer):
    class Meta:
        model = Property
        fields = ['id', 'landlord', 'name', 'city', 'state', 'unit_count']
        read_only_fields = ['id', 'landlord']
    def create(self, validated_data):
        property = Property.objects.create(**validated_data)
        return property
    
class UnitTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = UnitType
        fields = ['id', 'landlord', 'name', 'deposit', 'rent']
        read_only_fields = ['id', 'landlord']


class UnitSerializer(serializers.ModelSerializer):
    property = serializers.IntegerField(write_only=True, required=False)  # Alias for property_obj

    class Meta:
        model = Unit
        fields = ['id', 'property_obj', 'unit_code', 'unit_number', 'floor', 'bedrooms', 'bathrooms', 'unit_type', 'rent', 'tenant', 'rent_paid', 'rent_remaining', 'deposit', 'is_available', 'property']
        read_only_fields = ['id', 'rent_remaining', 'unit_code']
        extra_kwargs = {
            'unit_number': {'required': False},
            'property_obj': {'required': False},
        }

    def validate(self, attrs):
        user = self.context['request'].user
        # Handle property alias
        if 'property' in attrs:
            try:
                prop = Property.objects.get(id=attrs.pop('property'))
                if prop.landlord != user:
                    raise serializers.ValidationError("Property not owned by you.")
                attrs['property_obj'] = prop
            except Property.DoesNotExist:
                raise serializers.ValidationError("Property not found.")
        # Validate property_obj ownership if set directly
        if 'property_obj' in attrs:
            if attrs['property_obj'].landlord != user:
                raise serializers.ValidationError("Property not owned by you.")
        # Validate unit_type ownership
        if 'unit_type' in attrs and attrs['unit_type']:
            if attrs['unit_type'].landlord != user:
                raise serializers.ValidationError("UnitType not owned by you.")
        return super().validate(attrs)

    def create(self, validated_data):
        # Auto-generate unit_number if not provided
        if not validated_data.get('unit_number'):
            prop = validated_data.get('property_obj')
            if prop:
                existing_units = Unit.objects.filter(property_obj=prop)
                last_unit = existing_units.order_by('-unit_number').first()
                if last_unit and last_unit.unit_number.isdigit():
                    next_num = int(last_unit.unit_number) + 1
                else:
                    next_num = 1
                validated_data['unit_number'] = str(next_num)
        # Auto-generate unit_code if not provided
        if not validated_data.get('unit_code'):
            prop = validated_data.get('property_obj')
            if prop and getattr(prop, 'id', None):
                existing_count = Unit.objects.filter(property_obj=prop).count()
                validated_data['unit_code'] = f"U-{prop.id}-{existing_count+1}"
            else:
                # fallback unique code
                import uuid
                validated_data['unit_code'] = f"U-{uuid.uuid4().hex[:10].upper()}"
        # Set rent and deposit from unit_type if not provided
        unit_type = validated_data.get('unit_type')
        if unit_type:
            if not validated_data.get('rent'):
                validated_data['rent'] = unit_type.rent
            if not validated_data.get('deposit'):
                validated_data['deposit'] = unit_type.deposit
        # Enforce landlord has at least one UnitType defined before creating units
        prop = validated_data.get('property_obj')
        if prop and prop.landlord:
            landlord = prop.landlord
            if not UnitType.objects.filter(landlord=landlord).exists():
                raise serializers.ValidationError("Landlord must create at least one UnitType before creating Units.")

        unit = Unit.objects.create(**validated_data)
        return unit


class UnitNumberSerializer(serializers.ModelSerializer):
    class Meta:
        model = Unit
        fields = ['unit_number']

# TODO: Ensure landlords create properties and units upon sign up this will be done in the frontend
# TODO: Ensure Tenants pay the deposit to book a unit and choose their property upon sign up
# TODO: Ensure Tenants and Landlords can reset their passwords and get email notifications for important actions 


# For reset password functionality
class PasswordResetSerializer(serializers.Serializer):
    email = serializers.EmailField()

    def validate_email(self, value):
        if not CustomUser.objects.filter(email=value).exists():
            raise serializers.ValidationError("User with this email does not exist.")
        return value

    def save(self):
        from django.conf import settings
        email = self.validated_data['email']
        user = CustomUser.objects.get(email=email)
        uid = urlsafe_base64_encode(force_bytes(user.pk))
        token = default_token_generator.make_token(user)
        # Use the configurable frontend URL from settings
        reset_link = f"{settings.FRONTEND_URL}/reset-password/{uid}/{token}/"

        send_mail(
            subject="Password Reset Request",
            message=f"Click the link to reset your password: {reset_link}",
            from_email=None,
            recipient_list=[email],
        )


class PasswordResetConfirmSerializer(serializers.Serializer):
    uid = serializers.CharField()
    token = serializers.CharField()
    new_password = serializers.CharField(write_only=True, min_length=8)

    def validate(self, attrs):
        from django.contrib.auth.tokens import default_token_generator
        from django.utils.http import urlsafe_base64_decode
        from django.contrib.auth.password_validation import validate_password
        try:
            uid = urlsafe_base64_decode(attrs['uid']).decode()
            user = CustomUser.objects.get(pk=uid)
        except (TypeError, ValueError, OverflowError, CustomUser.DoesNotExist):
            raise serializers.ValidationError("Invalid UID")

        if not default_token_generator.check_token(user, attrs['token']):
            raise serializers.ValidationError("Invalid or expired token")

        validate_password(attrs['new_password'], user)
        attrs['user'] = user
        return attrs

    def save(self):
        user = self.validated_data['user']
        new_password = self.validated_data['new_password']
        user.set_password(new_password)
        user.save()
        return user


class ReminderPreferencesSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ['reminder_mode', 'reminder_value']


class AvailableUnitsSerializer(serializers.ModelSerializer):
    landlord_id = serializers.CharField(source='property_obj.landlord.landlord_code', read_only=True)
    property_id = serializers.IntegerField(source='property_obj.id', read_only=True)
    property_name = serializers.CharField(source='property_obj.name', read_only=True)
    unit_number = serializers.CharField(read_only=True)

    class Meta:
        model = Unit
        fields = ['landlord_id', 'property_id', 'property_name', 'unit_number']
from django.urls import path
from .views import (
    # STK Push + Callbacks
    stk_push,
    stk_push_subscription,
    mpesa_rent_callback,
    mpesa_subscription_callback,
    mpesa_b2c_callback,
    mpesa_deposit_callback,

    # DRF views
    PaymentListCreateView,
    PaymentDetailView,
    SubscriptionPaymentListCreateView,
    SubscriptionPaymentDetailView,
    RentSummaryView,
    UnitTypeListView,
    InitiateDepositPaymentView,
    DepositPaymentStatusView,
    CleanupPendingPaymentsView,
    TestMpesaView,

    # CSV reports
    LandLordCSVView as landlord_csv,
    TenantCSVView as tenant_csv,
)
from django.views.decorators.csrf import csrf_exempt

urlpatterns = [
    # ------------------------------
    # M-PESA STK PUSH + CALLBACKS
    # ------------------------------
    path("stk-push/<int:unit_id>/", stk_push, name="stk-push"),
    path("stk-push-subscription/", stk_push_subscription, name="stk-push-subscription"),
    path("callback/rent/", mpesa_rent_callback, name="mpesa-rent-callback"),
    path("callback/subscription/", mpesa_subscription_callback, name="mpesa-subscription-callback"),
    path("callback/b2c/", mpesa_b2c_callback, name="mpesa-b2c-callback"),
    path("callback/deposit/", mpesa_deposit_callback, name="mpesa-deposit-callback"),

    # ------------------------------
    # RENT PAYMENTS (DRF)
    # ------------------------------
    path("rent-payments/", PaymentListCreateView.as_view(), name="rent-payment-list-create"),
    path("rent-payments/<int:pk>/", PaymentDetailView.as_view(), name="rent-payment-detail"),

    # ------------------------------
    # SUBSCRIPTION PAYMENTS (DRF)
    # ------------------------------
    path("subscription-payments/", SubscriptionPaymentListCreateView.as_view(), name="subscription-payment-list-create"),
    path("subscription-payments/<int:pk>/", SubscriptionPaymentDetailView.as_view(), name="subscription-payment-detail"),
    path("rent-payments/summary/", RentSummaryView.as_view(), name="rent-summary"),

    # ------------------------------
    # UNIT TYPES
    # ------------------------------
    path("unit-types/", UnitTypeListView.as_view(), name="unit-types"),

    # ------------------------------
    # INITIATE DEPOSIT PAYMENT
    # ------------------------------
    path("initiate-deposit/", InitiateDepositPaymentView.as_view(), name="initiate-deposit"),
    path('deposit-status/<int:payment_id>/', DepositPaymentStatusView.as_view(), name='deposit-status'),
    # ------------------------------
    # CSV REPORTS
    # ------------------------------
    path("landlord-csv/<int:property_id>/", landlord_csv.as_view(), name="landlord-csv"),
    path("tenant-csv/<int:unit_id>/", tenant_csv.as_view(), name="tenant-csv"),

    # ------------------------------
    # CLEANUP AND SIMULATION ENDPOINTS
    # ------------------------------
    path("cleanup-pending-payments/", CleanupPendingPaymentsView.as_view(), name="cleanup-pending-payments"),
    # ------------------------------
    # TEST ENDPOINTS
    # ------------------------------
    path("test-mpesa/", TestMpesaView.as_view(), name="test-mpesa"),
]
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status, generics
from rest_framework.decorators import api_view, permission_classes
from django.conf import settings
from django.shortcuts import get_object_or_404
from django.core.cache import cache
from django.utils import timezone
from django.db.models import Sum, Q
from django.http import HttpResponse
import json
import requests
from decimal import Decimal
from datetime import datetime, timedelta
import csv
import io
import uuid
import base64
import logging

from accounts.models import CustomUser, Unit, UnitType, Property, Subscription
from .models import Payment, SubscriptionPayment
from .generate_token import generate_access_token
from .serializers import PaymentSerializer, SubscriptionPaymentSerializer

logger = logging.getLogger(__name__)

def validate_mpesa_payment(phone_number, amount):
    """
    Validate payment parameters before initiating STK push
    """
    try:
        # Validate phone number format
        if not phone_number or not isinstance(phone_number, str):
            return False, "Phone number is required"
        
        # Clean phone number
        phone_number = phone_number.strip().replace(' ', '').replace('+', '')
        
        # Convert to 254 format if needed
        if phone_number.startswith('0') and len(phone_number) == 10:
            phone_number = '254' + phone_number[1:]
        elif phone_number.startswith('7') and len(phone_number) == 9:
            phone_number = '254' + phone_number
        elif phone_number.startswith('254') and len(phone_number) == 12:
            # Already in correct format
            pass
        else:
            return False, "Phone number must be in format 254XXXXXXXXX"
        
        # Validate phone number contains only digits
        if not phone_number.isdigit():
            return False, "Phone number must contain only digits"
        
        # Validate amount
        try:
            amount = float(amount)
            if amount <= 0:
                return False, "Amount must be greater than 0"
            
            if amount > 150000:  # M-Pesa transaction limit
                return False, "Amount exceeds M-Pesa transaction limit (KES 150,000)"
            if amount < 1:  # Minimum amount
                return False, "Amount must be at least KES 1"
        except (ValueError, TypeError):
            return False, "Amount must be a valid number"
        
        return True, phone_number  # Return cleaned phone number
    
    except Exception as e:
        logger.error(f"Payment validation error: {str(e)}")
        return False, "Payment validation failed"
# ------------------------------
# M-PESA STK PUSH FUNCTIONS
# ------------------------------
@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def stk_push(request, unit_id):
    """
    Initiate REAL STK push for rent payment
    """
    try:
        unit = get_object_or_404(Unit, id=unit_id)
        tenant = request.user

        # Validate tenant owns the unit AND user is a tenant
        if request.user.user_type != 'tenant':
            return Response({"error": "Only tenants can make rent payments"}, status=status.HTTP_403_FORBIDDEN)
        # Validate tenant owns the unit
        if unit.tenant != tenant:
            return Response({"error": "You don't have permission to pay for this unit"}, status=status.HTTP_403_FORBIDDEN)

        # Check if rent is already paid
        if unit.rent_remaining <= 0:
            return Response({"error": "Rent is already paid for this unit"}, status=status.HTTP_400_BAD_REQUEST)

        amount = unit.rent_remaining
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)
        
        # Use cleaned phone number
        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD GENERATION
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_RENT_CALLBACK_URL,
            "AccountReference": f"RENT-{unit.unit_code}",
            "TransactionDesc": f"Rent payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Use correct URL based on environment
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        logger.info(f"Sending STK push to: {url}")
        logger.info(f"Payload: {payload}")

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        logger.info(f"STK push response: {response_data}")

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="rent",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache_key = f"stk_{response_data['CheckoutRequestID']}"
            cache_data = {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount),
                "tenant_id": tenant.id
            }
            cache.set(cache_key, cache_data, timeout=300)  # 5 minutes

            logger.info(f"STK push initiated successfully. Payment ID: {payment.id}, Cache Key: {cache_key}")

            return Response({
                "success": True,
                "message": "STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            logger.error(f"STK push failed: {error_message}")
            return Response({
                "error": "Failed to initiate STK push",
                "details": error_message,
                "response_data": response_data
            }, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        logger.error(f"STK push error: {str(e)}", exc_info=True)
        return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def stk_push_subscription(request):
    """
    Initiate STK push for subscription payment
    """
    try:
        user = request.user
        plan = request.data.get('plan')
        phone_number = request.data.get('phone_number')

        if not plan or not phone_number:
            return Response({"error": "Plan and phone number are required"}, status=status.HTTP_400_BAD_REQUEST)

        # Validate plan
        plan_amounts = {
            'starter': 1000,
            'basic': 2000,
            'professional': 3000
        }

        if plan not in plan_amounts:
            return Response({"error": "Invalid plan"}, status=status.HTTP_400_BAD_REQUEST)

        amount = plan_amounts[plan]

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)
        
        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": amount,
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_SUBSCRIPTION_CALLBACK_URL,
            "AccountReference": f"SUB-{user.id}",
            "TransactionDesc": f"Subscription payment for {plan} plan"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Make STK push request
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending subscription payment record
            subscription_payment = SubscriptionPayment.objects.create(
                user=user,
                amount=Decimal(amount),
                subscription_type=plan,
                status="Pending",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache_key = f"stk_sub_{response_data['CheckoutRequestID']}"
            cache.set(cache_key, {
                "subscription_payment_id": subscription_payment.id,
                "user_id": user.id,
                "plan": plan,
                "amount": amount
            }, timeout=300)  # 5 minutes

            return Response({
                "success": True,
                "message": "Subscription STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "subscription_payment_id": subscription_payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            return Response({
                "error": "Failed to initiate subscription STK push",
                "details": error_message
            }, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        logger.error(f"Subscription STK push error: {str(e)}", exc_info=True)
        return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# ------------------------------
# M-PESA CALLBACK FUNCTIONS (FIXED VERSIONS)
# ------------------------------
@csrf_exempt
def mpesa_rent_callback(request):
    """
    Enhanced rent payment callback handler
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Rent callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Rent callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])
            
            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Get cached payment data
            cached_data = cache.get(f"stk_{checkout_request_id}") if checkout_request_id else None
            
            if cached_data:
                try:
                    payment = Payment.objects.get(id=cached_data["payment_id"])
                    unit = payment.unit
                    
                    # Update payment record
                    payment.status = "Success"
                    payment.mpesa_receipt = mpesa_receipt or f"RENT-{payment.id}-{uuid.uuid4().hex[:8].upper()}"
                    
                    if amount:
                        payment.amount = Decimal(amount)
                    
                    payment.save()

                    # Update unit rent_paid
                    paid_amount = Decimal(amount) if amount else payment.amount
                    unit.rent_paid += paid_amount
                    unit.rent_remaining = unit.rent - unit.rent_paid
                    unit.save()

                    logger.info(f"Rent payment {payment.id} completed successfully for unit {unit.unit_number}")
                    logger.info(f"Unit {unit.unit_number} rent paid: {unit.rent_paid}, remaining: {unit.rent_remaining}")
                    
                    # Clear cache
                    cache.delete(f"stk_{checkout_request_id}")

                except Payment.DoesNotExist:
                    logger.error(f"Rent payment not found for ID: {cached_data['payment_id']}")
                except Unit.DoesNotExist:
                    logger.error(f"Unit not found for rent payment: {cached_data['payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing rent callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for rent checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Rent payment failed - ResultCode: {result_code}, Description: {result_desc}")
            
            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_{checkout_request_id}")
                if cached_data:
                    try:
                        payment = Payment.objects.get(id=cached_data["payment_id"])
                        payment.status = "Failed"
                        payment.failure_reason = result_desc
                        payment.save()
                        logger.info(f"Rent payment {payment.id} marked as failed: {result_desc}")
                    except Payment.DoesNotExist:
                        logger.error(f"Rent payment not found for failed callback: {cached_data['payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in rent callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in rent callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})

@csrf_exempt
def mpesa_deposit_callback(request):
    """
    Enhanced deposit payment callback handler
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Deposit callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Deposit callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])
            
            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Get cached payment data
            cached_data = cache.get(f"stk_deposit_{checkout_request_id}") if checkout_request_id else None
            
            if cached_data:
                try:
                    payment = Payment.objects.get(id=cached_data["payment_id"])
                    unit = payment.unit
                    
                    # Update payment record
                    payment.status = "Success"
                    payment.mpesa_receipt = mpesa_receipt or f"DEP-{payment.id}-{uuid.uuid4().hex[:8].upper()}"
                    
                    if amount:
                        payment.amount = Decimal(amount)
                    
                    payment.save()

                    # Mark unit as occupied and assign tenant
                    unit.is_available = False
                    unit.tenant = payment.tenant
                    unit.assigned_date = timezone.now()
                    unit.save()

                    logger.info(f"Deposit payment {payment.id} completed successfully for unit {unit.unit_number}")
                    logger.info(f"Unit {unit.unit_number} assigned to tenant {payment.tenant.email}")
                    
                    # Clear cache
                    cache.delete(f"stk_deposit_{checkout_request_id}")

                except Payment.DoesNotExist:
                    logger.error(f"Deposit payment not found for ID: {cached_data['payment_id']}")
                except Unit.DoesNotExist:
                    logger.error(f"Unit not found for deposit payment: {cached_data['payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing deposit callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for deposit checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Deposit payment failed - ResultCode: {result_code}, Description: {result_desc}")
            
            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_deposit_{checkout_request_id}")
                if cached_data:
                    try:
                        payment = Payment.objects.get(id=cached_data["payment_id"])
                        payment.status = "Failed"
                        payment.failure_reason = result_desc
                        payment.save()
                        logger.info(f"Deposit payment {payment.id} marked as failed: {result_desc}")
                    except Payment.DoesNotExist:
                        logger.error(f"Deposit payment not found for failed callback: {cached_data['payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in deposit callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in deposit callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})

@csrf_exempt
def mpesa_subscription_callback(request):
    """
    Enhanced subscription payment callback handler
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Subscription callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Subscription callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])
            
            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Get cached subscription payment data
            cached_data = cache.get(f"stk_sub_{checkout_request_id}") if checkout_request_id else None
            
            if cached_data:
                try:
                    subscription_payment = SubscriptionPayment.objects.get(
                        id=cached_data["subscription_payment_id"]
                    )
                    user = subscription_payment.user
                    
                    # Update subscription payment record
                    subscription_payment.status = "Success"
                    subscription_payment.mpesa_receipt_number = (
                        mpesa_receipt or 
                        f"SUB-{subscription_payment.id}-{uuid.uuid4().hex[:8].upper()}"
                    )
                    
                    if amount:
                        subscription_payment.amount = Decimal(amount)
                    
                    subscription_payment.save()

                    # Update or create user subscription
                    subscription, created = Subscription.objects.get_or_create(
                        user=user,
                        defaults={
                            'plan': subscription_payment.subscription_type,
                            'expiry_date': timezone.now() + timedelta(days=30)
                        }
                    )
                    
                    if not created:
                        # Update existing subscription
                        subscription.plan = subscription_payment.subscription_type
                        subscription.expiry_date = timezone.now() + timedelta(days=30)
                        subscription.save()

                    logger.info(f"Subscription payment {subscription_payment.id} completed successfully")
                    logger.info(f"User {user.email} subscription updated to {subscription_payment.subscription_type}")
                    
                    # Clear cache
                    cache.delete(f"stk_sub_{checkout_request_id}")

                except SubscriptionPayment.DoesNotExist:
                    logger.error(f"Subscription payment not found for ID: {cached_data['subscription_payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing subscription callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for subscription checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Subscription payment failed - ResultCode: {result_code}, Description: {result_desc}")
            
            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_sub_{checkout_request_id}")
                if cached_data:
                    try:
                        subscription_payment = SubscriptionPayment.objects.get(
                            id=cached_data["subscription_payment_id"]
                        )
                        subscription_payment.status = "Failed"
                        subscription_payment.failure_reason = result_desc
                        subscription_payment.save()
                        logger.info(f"Subscription payment {subscription_payment.id} marked as failed: {result_desc}")
                    except SubscriptionPayment.DoesNotExist:
                        logger.error(f"Subscription payment not found for failed callback: {cached_data['subscription_payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in subscription callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in subscription callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})

# Update the InitiateDepositPaymentView with the same fixes
class InitiateDepositPaymentView(APIView):
    """
    Initiate REAL deposit payment for unit
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        unit_id = request.data.get('unit_id')
        unit = get_object_or_404(Unit, id=unit_id)

        if not unit.is_available:
            return Response({"error": "Unit is not available"}, status=status.HTTP_400_BAD_REQUEST)

        tenant = request.user
        amount = unit.deposit
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)
        
        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD GENERATION
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_DEPOSIT_CALLBACK_URL,
            "AccountReference": f"DEPOSIT-{unit.unit_code}",
            "TransactionDesc": f"Deposit payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Use correct URL
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending deposit payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="deposit",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache.set(f"stk_deposit_{response_data['CheckoutRequestID']}", {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount),
                "tenant_id": tenant.id
            }, timeout=300)  # 5 minutes

            logger.info(f"Deposit STK push initiated for payment {payment.id}, amount {amount}")

            return Response({
                "success": True,
                "message": "Deposit STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            logger.error(f"Deposit STK push failed: {error_message}")
            return Response({
                "error": "Failed to initiate deposit STK push",
                "details": error_message
            }, status=status.HTTP_400_BAD_REQUEST)
@csrf_exempt
def mpesa_b2c_callback(request):
    """
    Handle M-Pesa B2C payment callback
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"B2C callback received: {callback_data}")

        result = callback_data.get("Result", {})

        if result.get("ResultCode") == 0:
            # Successful B2C payment
            result_parameters = result.get("ResultParameters", {}).get("ResultParameter", [])

            transaction_receipt = None
            transaction_amount = None
            conversation_id = result.get("ConversationID")

            # Extract relevant parameters
            for param in result_parameters:
                if param["Key"] == "TransactionReceipt":
                    transaction_receipt = param["Value"]
                elif param["Key"] == "TransactionAmount":
                    transaction_amount = param["Value"]

            # Get cached B2C payment data if exists
            cached_data = cache.get(f"b2c_{conversation_id}")
            if cached_data:
                # Update payment status or perform business logic here
                # For example, mark disbursement as successful
                logger.info(f"B2C payment successful: Receipt {transaction_receipt}, Amount {transaction_amount}")
                cache.delete(f"b2c_{conversation_id}")
            else:
                logger.info(f"B2C payment successful (no cached data): Receipt {transaction_receipt}, Amount {transaction_amount}")

        else:
            # Failed B2C payment
            logger.error(f"B2C payment failed: {result.get('ResultDesc')}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except Exception as e:
        logger.error(f"B2C callback error: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Error"})
class DepositPaymentStatusView(APIView):
    """
    Check deposit payment status - FIXED VERSION
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, payment_id):
        try:
            payment = Payment.objects.get(id=payment_id)
            
            # Check if user has permission to view this payment
            if request.user.user_type == 'tenant' and payment.tenant != request.user:
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            if request.user.user_type == 'landlord' and payment.unit.property_obj.landlord != request.user:
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            return Response({
                "payment_id": payment.id,
                "status": payment.status,
                "amount": float(payment.amount),
                "mpesa_receipt": payment.mpesa_receipt_number if hasattr(payment, 'mpesa_receipt_number') else payment.mpesa_receipt
            })
        except Payment.DoesNotExist:
            return Response({"error": "Payment not found"}, status=status.HTTP_404_NOT_FOUND)
# ------------------------------
# DRF CLASS-BASED VIEWS
# ------------------------------

class PaymentListCreateView(generics.ListCreateAPIView):
    """
    List and create rent payments
    """
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Payment.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            # Landlords can see payments for their properties
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()

    def perform_create(self, serializer):
        serializer.save(tenant=self.request.user)


class PaymentDetailView(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update, and delete rent payment
    """
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Payment.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()


class SubscriptionPaymentListCreateView(generics.ListCreateAPIView):
    """
    List and create subscription payments
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return SubscriptionPayment.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class SubscriptionPaymentDetailView(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update, and delete subscription payment
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return SubscriptionPayment.objects.filter(user=self.request.user)


class RentSummaryView(APIView):
    """
    Get rent summary for landlord
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        if user.user_type != 'landlord':
            return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)

        # Calculate total collected and outstanding rent
        properties = Property.objects.filter(landlord=user)
        units = Unit.objects.filter(property_obj__in=properties)

        total_collected = Payment.objects.filter(
            unit__in=units,
            status='Success'
        ).aggregate(total=Sum('amount'))['total'] or 0

        total_outstanding = units.aggregate(
            outstanding=Sum('rent_remaining')
        )['outstanding'] or 0

        return Response({
            "total_collected": total_collected,
            "total_outstanding": total_outstanding,
            "properties_count": properties.count(),
            "units_count": units.count()
        })


class UnitTypeListView(generics.ListAPIView):
    """
    List unit types for landlord
    """
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return UnitType.objects.filter(landlord=self.request.user)


class InitiateDepositPaymentView(APIView):
    """
    Initiate REAL deposit payment for unit
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        unit_id = request.data.get('unit_id')
        unit = get_object_or_404(Unit, id=unit_id)

        if not unit.is_available:
            return Response({"error": "Unit is not available"}, status=status.HTTP_400_BAD_REQUEST)

        tenant = request.user
        amount = unit.deposit
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Validate phone number format
        if not phone_number.startswith('254'):
            return Response({"error": "Phone number must be in format 254XXXXXXXXX"}, status=status.HTTP_400_BAD_REQUEST)
        # ✅ ADD VALIDATION HERE
        is_valid, validation_message = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_message}, status=status.HTTP_400_BAD_REQUEST)
        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request for PRODUCTION
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password = base64.b64encode(
            (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode('utf-8')
        ).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_DEPOSIT_CALLBACK_URL,
            "AccountReference": f"DEPOSIT-{unit.unit_code}",
            "TransactionDesc": f"Deposit payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Use production URL
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending deposit payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="deposit",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache.set(f"stk_deposit_{response_data['CheckoutRequestID']}", {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount),
                "tenant_id": tenant.id
            }, timeout=300)  # 5 minutes

            logger.info(f"Deposit STK push initiated for payment {payment.id}, amount {amount}")

            return Response({
                "success": True,
                "message": "Deposit STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            logger.error(f"Deposit STK push failed: {response_data}")
            return Response({
                "error": "Failed to initiate deposit STK push",
                "details": response_data.get('errorMessage', 'Unknown error')
            }, status=status.HTTP_400_BAD_REQUEST)


class DepositPaymentStatusView(APIView):
    """
    Check deposit payment status
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, payment_id):
        payment = get_object_or_404(Payment, id=payment_id)

        # Check if user has permission to view this payment
        if request.user.user_type == 'tenant' and payment.tenant != request.user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        if request.user.user_type == 'landlord' and payment.unit.property_obj.landlord != request.user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        return Response({
            "payment_id": payment.id,
            "status": payment.status,
            "amount": payment.amount,
            "mpesa_receipt": payment.mpesa_receipt
        })


class CleanupPendingPaymentsView(APIView):
    """
    Clean up old pending payments - ENHANCED VERSION
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        # Delete pending payments older than 1 hour
        cutoff_time = timezone.now() - timedelta(hours=1)
        
        # Clean up rent payments
        rent_deleted_count = Payment.objects.filter(
            status='Pending',
            created_at__lt=cutoff_time
        ).delete()

        # Clean up subscription payments  
        subscription_deleted_count = SubscriptionPayment.objects.filter(
            status='Pending',
            transaction_date__lt=cutoff_time
        ).delete()

        total_deleted = rent_deleted_count[0] + subscription_deleted_count[0]

        return Response({"message": f"Cleaned up {total_deleted} pending payments"})


# ------------------------------
# CSV EXPORT VIEWS
# ------------------------------

class LandLordCSVView(APIView):
    """
    Export landlord payment data as CSV
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, property_id):
        user = request.user
        if user.user_type != 'landlord':
            return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)

        property_obj = get_object_or_404(Property, id=property_id, landlord=user)
        units = Unit.objects.filter(property_obj=property_obj)
        payments = Payment.objects.filter(unit__in=units, status='Success')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="landlord_payments_{property_obj.name}.csv"'

        writer = csv.writer(response)
        writer.writerow(['Unit Number', 'Tenant', 'Amount', 'Date', 'M-Pesa Receipt'])

        for payment in payments:
            writer.writerow([
                payment.unit.unit_number,
                payment.tenant.full_name if payment.tenant else '',
                payment.amount,
                payment.transaction_date.strftime('%Y-%m-%d'),
                payment.mpesa_receipt or ''
            ])

        return response


class TenantCSVView(APIView):
    """
    Export tenant payment data as CSV
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, unit_id):
        user = request.user
        unit = get_object_or_404(Unit, id=unit_id)

        if user.user_type == 'tenant' and unit.tenant != user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        if user.user_type == 'landlord' and unit.property_obj.landlord != user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        payments = Payment.objects.filter(unit=unit, status='Success')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="tenant_payments_unit_{unit.unit_number}.csv"'

        writer = csv.writer(response)
        writer.writerow(['Amount', 'Date', 'M-Pesa Receipt', 'Type'])

        for payment in payments:
            writer.writerow([
                payment.amount,
                payment.transaction_date.strftime('%Y-%m-%d'),
                payment.mpesa_receipt or '',
                payment.payment_type
            ])

        return response


class TestMpesaView(APIView):
    """
    Test endpoint for M-Pesa integration
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        return Response({
            "message": "M-Pesa test endpoint",
            "mpesa_env": settings.MPESA_ENV,
            "shortcode": settings.MPESA_SHORTCODE
        })

    def post(self, request):
        # Test token generation
        token = generate_access_token()
        if token:
            return Response({
                "success": True,
                "message": "M-Pesa token generated successfully",
                "token_preview": token[:10] + "..."
            })
        else:
            return Response({
                "success": False,
                "message": "Failed to generate M-Pesa token"
            }, status=400)
// Payments
from django.db import models
from accounts.models import CustomUser, Unit, Subscription
from datetime import timedelta
from django.core.exceptions import ValidationError
import uuid

class Payment(models.Model):
    PAYMENT_TYPES = [
        ('rent', 'Rent'),
        ('deposit', 'Deposit'),
        ('maintenance', 'Maintenance'),
        ('other', 'Other'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
    ]

    tenant = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        limit_choices_to={'user_type': 'tenant'},
        related_name='payments'
    )
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name='payments')
    
    # Payment details
    payment_type = models.CharField(max_length=20, choices=PAYMENT_TYPES, default='rent')
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')
    
    # M-Pesa fields
    mpesa_receipt = models.CharField(max_length=50, blank=True, null=True)
    mpesa_checkout_request_id = models.CharField(max_length=100, blank=True, null=True)
    
    # Additional fields
    reference_number = models.CharField(max_length=50, unique=True, blank=True)
    description = models.TextField(blank=True)
    payment_method = models.CharField(max_length=20, default='mpesa', choices=[
        ('mpesa', 'M-Pesa'),
        ('cash', 'Cash'),
        ('bank', 'Bank Transfer'),
    ])
    
    # Timestamps - using created_at consistently
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    failure_reason = models.TextField(blank=True, null=True)

    def clean(self):
        if self.payment_type == 'rent' and not self.unit:
            raise ValidationError("Rent payments must be associated with a unit")
            
    def save(self, *args, **kwargs):
        # Generate reference number if not set
        if not self.reference_number:
            self.reference_number = f"PAY-{uuid.uuid4().hex[:12].upper()}"
        super().save(*args, **kwargs)
        
    def __str__(self):
        return f"Payment {self.reference_number} - {self.amount} ({self.status})"


class SubscriptionPayment(models.Model):
    user = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        null=True,
        blank=True
    )
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    mpesa_receipt_number = models.CharField(
        max_length=50,
        blank=True,  # Allow empty strings
        null=True,
        default=""
    )
    mpesa_checkout_request_id = models.CharField(
        max_length=100,
        blank=True,
        null=True,
        help_text="M-Pesa checkout request ID for tracking STK push"
    )
    transaction_date = models.DateTimeField(auto_now_add=True)
    subscription_type = models.CharField(max_length=20, choices=Subscription.PLAN_CHOICES)
    status = models.CharField(
        max_length=20,
        choices=[("Pending", "Pending"), ("Success", "Success"), ("Failed", "Failed")],
        default="Pending"
    )

    class Meta:
        # Simple unique constraint for non-empty receipt numbers
        constraints = [
            models.UniqueConstraint(
                fields=['mpesa_receipt_number'],
                name='unique_mpesa_receipt',
                condition=~models.Q(mpesa_receipt_number='')
            )
        ]

    def __str__(self):
        return f"Subscription Payment {self.id} - {self.subscription_type}"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)

    def _get_plan_duration(self):
        durations = {
            "free": timedelta(days=60),
            "starter": timedelta(days=30),
            "basic": timedelta(days=30),
            "professional": timedelta(days=30),
            # "onetime" will be treated as lifetime (None) by the subscription logic
        }
        return durations.get(self.subscription_type, timedelta(days=30))
from rest_framework import serializers
from .models import Payment, SubscriptionPayment


class PaymentSerializer(serializers.ModelSerializer):
    date = serializers.DateTimeField(source='transaction_date', read_only=True)
    phone = serializers.CharField(source='tenant.phone_number', read_only=True)
    tenant_name = serializers.CharField(source='tenant.full_name', read_only=True)

    class Meta:
        model = Payment
        fields = ['id', 'tenant', 'tenant_name', 'unit', 'payment_type', 'amount', 'mpesa_receipt', 'date', 'phone', 'status']
        read_only_fields = ['transaction_date', 'status']


class SubscriptionPaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubscriptionPayment
        fields = '__all__'
        read_only_fields = ['transaction_date']
from django.urls import path
from .views import (
    # STK Push + Callbacks
    stk_push,
    stk_push_subscription,
    mpesa_rent_callback,
    mpesa_subscription_callback,
    mpesa_b2c_callback,
    mpesa_deposit_callback,

    # DRF views
    PaymentListCreateView,
    PaymentDetailView,
    SubscriptionPaymentListCreateView,
    SubscriptionPaymentDetailView,
    RentSummaryView,
    UnitTypeListView,
    InitiateDepositPaymentView,
    DepositPaymentStatusView,
    CleanupPendingPaymentsView,
    TestMpesaView,

    # CSV reports
    LandLordCSVView as landlord_csv,
    TenantCSVView as tenant_csv,
)
from django.views.decorators.csrf import csrf_exempt

urlpatterns = [
    # ------------------------------
    # M-PESA STK PUSH + CALLBACKS
    # ------------------------------
    path("stk-push/<int:unit_id>/", stk_push, name="stk-push"),
    path("stk-push-subscription/", stk_push_subscription, name="stk-push-subscription"),
    path("callback/rent/", mpesa_rent_callback, name="mpesa-rent-callback"),
    path("callback/subscription/", mpesa_subscription_callback, name="mpesa-subscription-callback"),
    path("callback/b2c/", mpesa_b2c_callback, name="mpesa-b2c-callback"),
    path("callback/deposit/", mpesa_deposit_callback, name="mpesa-deposit-callback"),

    # ------------------------------
    # RENT PAYMENTS (DRF)
    # ------------------------------
    path("rent-payments/", PaymentListCreateView.as_view(), name="rent-payment-list-create"),
    path("rent-payments/<int:pk>/", PaymentDetailView.as_view(), name="rent-payment-detail"),

    # ------------------------------
    # SUBSCRIPTION PAYMENTS (DRF)
    # ------------------------------
    path("subscription-payments/", SubscriptionPaymentListCreateView.as_view(), name="subscription-payment-list-create"),
    path("subscription-payments/<int:pk>/", SubscriptionPaymentDetailView.as_view(), name="subscription-payment-detail"),
    path("rent-payments/summary/", RentSummaryView.as_view(), name="rent-summary"),

    # ------------------------------
    # UNIT TYPES
    # ------------------------------
    path("unit-types/", UnitTypeListView.as_view(), name="unit-types"),

    # ------------------------------
    # INITIATE DEPOSIT PAYMENT
    # ------------------------------
    path("initiate-deposit/", InitiateDepositPaymentView.as_view(), name="initiate-deposit"),
    path('deposit-status/<int:payment_id>/', DepositPaymentStatusView.as_view(), name='deposit-status'),
    # ------------------------------
    # CSV REPORTS
    # ------------------------------
    path("landlord-csv/<int:property_id>/", landlord_csv.as_view(), name="landlord-csv"),
    path("tenant-csv/<int:unit_id>/", tenant_csv.as_view(), name="tenant-csv"),

    # ------------------------------
    # CLEANUP AND SIMULATION ENDPOINTS
    # ------------------------------
    path("cleanup-pending-payments/", CleanupPendingPaymentsView.as_view(), name="cleanup-pending-payments"),
    # ------------------------------
    # TEST ENDPOINTS
    # ------------------------------
    path("test-mpesa/", TestMpesaView.as_view(), name="test-mpesa"),
]
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status, generics
from rest_framework.decorators import api_view, permission_classes
from django.conf import settings
from django.shortcuts import get_object_or_404
from django.core.cache import cache
from django.utils import timezone
from django.db.models import Sum, Q
from django.http import HttpResponse
import json
import requests
from decimal import Decimal
from datetime import datetime, timedelta
import csv
import io
import uuid
import base64
import logging

from accounts.models import CustomUser, Unit, UnitType, Property, Subscription
from .models import Payment, SubscriptionPayment
from .generate_token import generate_access_token
from .serializers import PaymentSerializer, SubscriptionPaymentSerializer

logger = logging.getLogger(__name__)

def validate_mpesa_payment(phone_number, amount):
    """
    Validate payment parameters before initiating STK push
    """
    try:
        # Validate phone number format
        if not phone_number or not isinstance(phone_number, str):
            return False, "Phone number is required"
        
        # Clean phone number
        phone_number = phone_number.strip().replace(' ', '').replace('+', '')
        
        # Convert to 254 format if needed
        if phone_number.startswith('0') and len(phone_number) == 10:
            phone_number = '254' + phone_number[1:]
        elif phone_number.startswith('7') and len(phone_number) == 9:
            phone_number = '254' + phone_number
        elif phone_number.startswith('254') and len(phone_number) == 12:
            # Already in correct format
            pass
        else:
            return False, "Phone number must be in format 254XXXXXXXXX"
        
        # Validate phone number contains only digits
        if not phone_number.isdigit():
            return False, "Phone number must contain only digits"
        
        # Validate amount
        try:
            amount = float(amount)
            if amount <= 0:
                return False, "Amount must be greater than 0"
            
            if amount > 150000:  # M-Pesa transaction limit
                return False, "Amount exceeds M-Pesa transaction limit (KES 150,000)"
            if amount < 1:  # Minimum amount
                return False, "Amount must be at least KES 1"
        except (ValueError, TypeError):
            return False, "Amount must be a valid number"
        
        return True, phone_number  # Return cleaned phone number
    
    except Exception as e:
        logger.error(f"Payment validation error: {str(e)}")
        return False, "Payment validation failed"
# ------------------------------
# M-PESA STK PUSH FUNCTIONS
# ------------------------------
@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def stk_push(request, unit_id):
    """
    Initiate REAL STK push for rent payment
    """
    try:
        unit = get_object_or_404(Unit, id=unit_id)
        tenant = request.user

        # Validate tenant owns the unit AND user is a tenant
        if request.user.user_type != 'tenant':
            return Response({"error": "Only tenants can make rent payments"}, status=status.HTTP_403_FORBIDDEN)
        # Validate tenant owns the unit
        if unit.tenant != tenant:
            return Response({"error": "You don't have permission to pay for this unit"}, status=status.HTTP_403_FORBIDDEN)

        # Check if rent is already paid
        if unit.rent_remaining <= 0:
            return Response({"error": "Rent is already paid for this unit"}, status=status.HTTP_400_BAD_REQUEST)

        amount = unit.rent_remaining
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)
        
        # Use cleaned phone number
        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD GENERATION
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_RENT_CALLBACK_URL,
            "AccountReference": f"RENT-{unit.unit_code}",
            "TransactionDesc": f"Rent payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Use correct URL based on environment
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        logger.info(f"Sending STK push to: {url}")
        logger.info(f"Payload: {payload}")

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        logger.info(f"STK push response: {response_data}")

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="rent",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache_key = f"stk_{response_data['CheckoutRequestID']}"
            cache_data = {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount),
                "tenant_id": tenant.id
            }
            cache.set(cache_key, cache_data, timeout=300)  # 5 minutes

            logger.info(f"STK push initiated successfully. Payment ID: {payment.id}, Cache Key: {cache_key}")

            return Response({
                "success": True,
                "message": "STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            logger.error(f"STK push failed: {error_message}")
            return Response({
                "error": "Failed to initiate STK push",
                "details": error_message,
                "response_data": response_data
            }, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        logger.error(f"STK push error: {str(e)}", exc_info=True)
        return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def stk_push_subscription(request):
    """
    Initiate STK push for subscription payment
    """
    try:
        user = request.user
        plan = request.data.get('plan')
        phone_number = request.data.get('phone_number')

        if not plan or not phone_number:
            return Response({"error": "Plan and phone number are required"}, status=status.HTTP_400_BAD_REQUEST)

        # Validate plan
        plan_amounts = {
            'starter': 1000,
            'basic': 2000,
            'professional': 3000
        }

        if plan not in plan_amounts:
            return Response({"error": "Invalid plan"}, status=status.HTTP_400_BAD_REQUEST)

        amount = plan_amounts[plan]

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)
        
        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": amount,
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_SUBSCRIPTION_CALLBACK_URL,
            "AccountReference": f"SUB-{user.id}",
            "TransactionDesc": f"Subscription payment for {plan} plan"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Make STK push request
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending subscription payment record
            subscription_payment = SubscriptionPayment.objects.create(
                user=user,
                amount=Decimal(amount),
                subscription_type=plan,
                status="Pending",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache_key = f"stk_sub_{response_data['CheckoutRequestID']}"
            cache.set(cache_key, {
                "subscription_payment_id": subscription_payment.id,
                "user_id": user.id,
                "plan": plan,
                "amount": amount
            }, timeout=300)  # 5 minutes

            return Response({
                "success": True,
                "message": "Subscription STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "subscription_payment_id": subscription_payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            return Response({
                "error": "Failed to initiate subscription STK push",
                "details": error_message
            }, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        logger.error(f"Subscription STK push error: {str(e)}", exc_info=True)
        return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# ------------------------------
# M-PESA CALLBACK FUNCTIONS (FIXED VERSIONS)
# ------------------------------
@csrf_exempt
def mpesa_rent_callback(request):
    """
    Enhanced rent payment callback handler
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Rent callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Rent callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])
            
            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Get cached payment data
            cached_data = cache.get(f"stk_{checkout_request_id}") if checkout_request_id else None
            
            if cached_data:
                try:
                    payment = Payment.objects.get(id=cached_data["payment_id"])
                    unit = payment.unit
                    
                    # Update payment record
                    payment.status = "Success"
                    payment.mpesa_receipt = mpesa_receipt or f"RENT-{payment.id}-{uuid.uuid4().hex[:8].upper()}"
                    
                    if amount:
                        payment.amount = Decimal(amount)
                    
                    payment.save()

                    # Update unit rent_paid
                    paid_amount = Decimal(amount) if amount else payment.amount
                    unit.rent_paid += paid_amount
                    unit.rent_remaining = unit.rent - unit.rent_paid
                    unit.save()

                    logger.info(f"Rent payment {payment.id} completed successfully for unit {unit.unit_number}")
                    logger.info(f"Unit {unit.unit_number} rent paid: {unit.rent_paid}, remaining: {unit.rent_remaining}")
                    
                    # Clear cache
                    cache.delete(f"stk_{checkout_request_id}")

                except Payment.DoesNotExist:
                    logger.error(f"Rent payment not found for ID: {cached_data['payment_id']}")
                except Unit.DoesNotExist:
                    logger.error(f"Unit not found for rent payment: {cached_data['payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing rent callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for rent checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Rent payment failed - ResultCode: {result_code}, Description: {result_desc}")
            
            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_{checkout_request_id}")
                if cached_data:
                    try:
                        payment = Payment.objects.get(id=cached_data["payment_id"])
                        payment.status = "Failed"
                        payment.failure_reason = result_desc
                        payment.save()
                        logger.info(f"Rent payment {payment.id} marked as failed: {result_desc}")
                    except Payment.DoesNotExist:
                        logger.error(f"Rent payment not found for failed callback: {cached_data['payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in rent callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in rent callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})

@csrf_exempt
def mpesa_deposit_callback(request):
    """
    Enhanced deposit payment callback handler
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Deposit callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Deposit callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])
            
            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Get cached payment data
            cached_data = cache.get(f"stk_deposit_{checkout_request_id}") if checkout_request_id else None
            
            if cached_data:
                try:
                    payment = Payment.objects.get(id=cached_data["payment_id"])
                    unit = payment.unit
                    
                    # Update payment record
                    payment.status = "Success"
                    payment.mpesa_receipt = mpesa_receipt or f"DEP-{payment.id}-{uuid.uuid4().hex[:8].upper()}"
                    
                    if amount:
                        payment.amount = Decimal(amount)
                    
                    payment.save()

                    # Mark unit as occupied and assign tenant
                    unit.is_available = False
                    unit.tenant = payment.tenant
                    unit.assigned_date = timezone.now()
                    unit.save()

                    logger.info(f"Deposit payment {payment.id} completed successfully for unit {unit.unit_number}")
                    logger.info(f"Unit {unit.unit_number} assigned to tenant {payment.tenant.email}")
                    
                    # Clear cache
                    cache.delete(f"stk_deposit_{checkout_request_id}")

                except Payment.DoesNotExist:
                    logger.error(f"Deposit payment not found for ID: {cached_data['payment_id']}")
                except Unit.DoesNotExist:
                    logger.error(f"Unit not found for deposit payment: {cached_data['payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing deposit callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for deposit checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Deposit payment failed - ResultCode: {result_code}, Description: {result_desc}")
            
            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_deposit_{checkout_request_id}")
                if cached_data:
                    try:
                        payment = Payment.objects.get(id=cached_data["payment_id"])
                        payment.status = "Failed"
                        payment.failure_reason = result_desc
                        payment.save()
                        logger.info(f"Deposit payment {payment.id} marked as failed: {result_desc}")
                    except Payment.DoesNotExist:
                        logger.error(f"Deposit payment not found for failed callback: {cached_data['payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in deposit callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in deposit callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})

@csrf_exempt
def mpesa_subscription_callback(request):
    """
    Enhanced subscription payment callback handler
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Subscription callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})
        result_code = stk_callback.get("ResultCode")
        result_desc = stk_callback.get("ResultDesc", "")
        checkout_request_id = stk_callback.get("CheckoutRequestID")

        logger.info(f"Subscription callback - ResultCode: {result_code}, CheckoutRequestID: {checkout_request_id}")

        if result_code == 0:
            # Payment successful
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])
            
            # Extract payment details
            mpesa_receipt = None
            amount = None
            phone_number = None

            for item in callback_metadata:
                if item.get("Name") == "MpesaReceiptNumber":
                    mpesa_receipt = item.get("Value")
                elif item.get("Name") == "Amount":
                    amount = item.get("Value")
                elif item.get("Name") == "PhoneNumber":
                    phone_number = item.get("Value")

            # Get cached subscription payment data
            cached_data = cache.get(f"stk_sub_{checkout_request_id}") if checkout_request_id else None
            
            if cached_data:
                try:
                    subscription_payment = SubscriptionPayment.objects.get(
                        id=cached_data["subscription_payment_id"]
                    )
                    user = subscription_payment.user
                    
                    # Update subscription payment record
                    subscription_payment.status = "Success"
                    subscription_payment.mpesa_receipt_number = (
                        mpesa_receipt or 
                        f"SUB-{subscription_payment.id}-{uuid.uuid4().hex[:8].upper()}"
                    )
                    
                    if amount:
                        subscription_payment.amount = Decimal(amount)
                    
                    subscription_payment.save()

                    # Update or create user subscription
                    subscription, created = Subscription.objects.get_or_create(
                        user=user,
                        defaults={
                            'plan': subscription_payment.subscription_type,
                            'expiry_date': timezone.now() + timedelta(days=30)
                        }
                    )
                    
                    if not created:
                        # Update existing subscription
                        subscription.plan = subscription_payment.subscription_type
                        subscription.expiry_date = timezone.now() + timedelta(days=30)
                        subscription.save()

                    logger.info(f"Subscription payment {subscription_payment.id} completed successfully")
                    logger.info(f"User {user.email} subscription updated to {subscription_payment.subscription_type}")
                    
                    # Clear cache
                    cache.delete(f"stk_sub_{checkout_request_id}")

                except SubscriptionPayment.DoesNotExist:
                    logger.error(f"Subscription payment not found for ID: {cached_data['subscription_payment_id']}")
                except Exception as e:
                    logger.error(f"Error processing subscription callback: {str(e)}")

            else:
                logger.warning(f"No cached data found for subscription checkout: {checkout_request_id}")

        else:
            # Payment failed
            logger.error(f"Subscription payment failed - ResultCode: {result_code}, Description: {result_desc}")
            
            # Update payment status to failed
            if checkout_request_id:
                cached_data = cache.get(f"stk_sub_{checkout_request_id}")
                if cached_data:
                    try:
                        subscription_payment = SubscriptionPayment.objects.get(
                            id=cached_data["subscription_payment_id"]
                        )
                        subscription_payment.status = "Failed"
                        subscription_payment.failure_reason = result_desc
                        subscription_payment.save()
                        logger.info(f"Subscription payment {subscription_payment.id} marked as failed: {result_desc}")
                    except SubscriptionPayment.DoesNotExist:
                        logger.error(f"Subscription payment not found for failed callback: {cached_data['subscription_payment_id']}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except json.JSONDecodeError:
        logger.error("Invalid JSON in subscription callback")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Invalid JSON"})
    except Exception as e:
        logger.error(f"Unexpected error in subscription callback: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Internal error"})

# Update the InitiateDepositPaymentView with the same fixes
class InitiateDepositPaymentView(APIView):
    """
    Initiate REAL deposit payment for unit
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        unit_id = request.data.get('unit_id')
        unit = get_object_or_404(Unit, id=unit_id)

        if not unit.is_available:
            return Response({"error": "Unit is not available"}, status=status.HTTP_400_BAD_REQUEST)

        tenant = request.user
        amount = unit.deposit
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # ✅ ADD VALIDATION HERE
        is_valid, validation_result = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_result}, status=status.HTTP_400_BAD_REQUEST)
        
        phone_number = validation_result

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request - FIXED PASSWORD GENERATION
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password_string = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp
        password = base64.b64encode(password_string.encode('utf-8')).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_DEPOSIT_CALLBACK_URL,
            "AccountReference": f"DEPOSIT-{unit.unit_code}",
            "TransactionDesc": f"Deposit payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Use correct URL
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending deposit payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="deposit",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache.set(f"stk_deposit_{response_data['CheckoutRequestID']}", {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount),
                "tenant_id": tenant.id
            }, timeout=300)  # 5 minutes

            logger.info(f"Deposit STK push initiated for payment {payment.id}, amount {amount}")

            return Response({
                "success": True,
                "message": "Deposit STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            error_message = response_data.get('errorMessage', response_data.get('ResponseDescription', 'Unknown error'))
            logger.error(f"Deposit STK push failed: {error_message}")
            return Response({
                "error": "Failed to initiate deposit STK push",
                "details": error_message
            }, status=status.HTTP_400_BAD_REQUEST)
@csrf_exempt
def mpesa_b2c_callback(request):
    """
    Handle M-Pesa B2C payment callback
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"B2C callback received: {callback_data}")

        result = callback_data.get("Result", {})

        if result.get("ResultCode") == 0:
            # Successful B2C payment
            result_parameters = result.get("ResultParameters", {}).get("ResultParameter", [])

            transaction_receipt = None
            transaction_amount = None
            conversation_id = result.get("ConversationID")

            # Extract relevant parameters
            for param in result_parameters:
                if param["Key"] == "TransactionReceipt":
                    transaction_receipt = param["Value"]
                elif param["Key"] == "TransactionAmount":
                    transaction_amount = param["Value"]

            # Get cached B2C payment data if exists
            cached_data = cache.get(f"b2c_{conversation_id}")
            if cached_data:
                # Update payment status or perform business logic here
                # For example, mark disbursement as successful
                logger.info(f"B2C payment successful: Receipt {transaction_receipt}, Amount {transaction_amount}")
                cache.delete(f"b2c_{conversation_id}")
            else:
                logger.info(f"B2C payment successful (no cached data): Receipt {transaction_receipt}, Amount {transaction_amount}")

        else:
            # Failed B2C payment
            logger.error(f"B2C payment failed: {result.get('ResultDesc')}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except Exception as e:
        logger.error(f"B2C callback error: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Error"})
class DepositPaymentStatusView(APIView):
    """
    Check deposit payment status - FIXED VERSION
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, payment_id):
        try:
            payment = Payment.objects.get(id=payment_id)
            
            # Check if user has permission to view this payment
            if request.user.user_type == 'tenant' and payment.tenant != request.user:
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            if request.user.user_type == 'landlord' and payment.unit.property_obj.landlord != request.user:
                return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

            return Response({
                "payment_id": payment.id,
                "status": payment.status,
                "amount": float(payment.amount),
                "mpesa_receipt": payment.mpesa_receipt_number if hasattr(payment, 'mpesa_receipt_number') else payment.mpesa_receipt
            })
        except Payment.DoesNotExist:
            return Response({"error": "Payment not found"}, status=status.HTTP_404_NOT_FOUND)
# ------------------------------
# DRF CLASS-BASED VIEWS
# ------------------------------

class PaymentListCreateView(generics.ListCreateAPIView):
    """
    List and create rent payments
    """
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Payment.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            # Landlords can see payments for their properties
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()

    def perform_create(self, serializer):
        serializer.save(tenant=self.request.user)


class PaymentDetailView(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update, and delete rent payment
    """
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Payment.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()


class SubscriptionPaymentListCreateView(generics.ListCreateAPIView):
    """
    List and create subscription payments
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return SubscriptionPayment.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class SubscriptionPaymentDetailView(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update, and delete subscription payment
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return SubscriptionPayment.objects.filter(user=self.request.user)


class RentSummaryView(APIView):
    """
    Get rent summary for landlord
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        if user.user_type != 'landlord':
            return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)

        # Calculate total collected and outstanding rent
        properties = Property.objects.filter(landlord=user)
        units = Unit.objects.filter(property_obj__in=properties)

        total_collected = Payment.objects.filter(
            unit__in=units,
            status='Success'
        ).aggregate(total=Sum('amount'))['total'] or 0

        total_outstanding = units.aggregate(
            outstanding=Sum('rent_remaining')
        )['outstanding'] or 0

        return Response({
            "total_collected": total_collected,
            "total_outstanding": total_outstanding,
            "properties_count": properties.count(),
            "units_count": units.count()
        })


class UnitTypeListView(generics.ListAPIView):
    """
    List unit types for landlord
    """
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return UnitType.objects.filter(landlord=self.request.user)


class InitiateDepositPaymentView(APIView):
    """
    Initiate REAL deposit payment for unit
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        unit_id = request.data.get('unit_id')
        unit = get_object_or_404(Unit, id=unit_id)

        if not unit.is_available:
            return Response({"error": "Unit is not available"}, status=status.HTTP_400_BAD_REQUEST)

        tenant = request.user
        amount = unit.deposit
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Validate phone number format
        if not phone_number.startswith('254'):
            return Response({"error": "Phone number must be in format 254XXXXXXXXX"}, status=status.HTTP_400_BAD_REQUEST)
        # ✅ ADD VALIDATION HERE
        is_valid, validation_message = validate_mpesa_payment(phone_number, amount)
        if not is_valid:
            return Response({"error": validation_message}, status=status.HTTP_400_BAD_REQUEST)
        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request for PRODUCTION
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password = base64.b64encode(
            (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode('utf-8')
        ).decode('utf-8')

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_DEPOSIT_CALLBACK_URL,
            "AccountReference": f"DEPOSIT-{unit.unit_code}",
            "TransactionDesc": f"Deposit payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Use production URL
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending deposit payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="deposit",
                mpesa_checkout_request_id=response_data["CheckoutRequestID"]
            )

            # Cache checkout request ID for callback
            cache.set(f"stk_deposit_{response_data['CheckoutRequestID']}", {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount),
                "tenant_id": tenant.id
            }, timeout=300)  # 5 minutes

            logger.info(f"Deposit STK push initiated for payment {payment.id}, amount {amount}")

            return Response({
                "success": True,
                "message": "Deposit STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            logger.error(f"Deposit STK push failed: {response_data}")
            return Response({
                "error": "Failed to initiate deposit STK push",
                "details": response_data.get('errorMessage', 'Unknown error')
            }, status=status.HTTP_400_BAD_REQUEST)


class DepositPaymentStatusView(APIView):
    """
    Check deposit payment status
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, payment_id):
        payment = get_object_or_404(Payment, id=payment_id)

        # Check if user has permission to view this payment
        if request.user.user_type == 'tenant' and payment.tenant != request.user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        if request.user.user_type == 'landlord' and payment.unit.property_obj.landlord != request.user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        return Response({
            "payment_id": payment.id,
            "status": payment.status,
            "amount": payment.amount,
            "mpesa_receipt": payment.mpesa_receipt
        })


class CleanupPendingPaymentsView(APIView):
    """
    Clean up old pending payments - ENHANCED VERSION
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        # Delete pending payments older than 1 hour
        cutoff_time = timezone.now() - timedelta(hours=1)
        
        # Clean up rent payments
        rent_deleted_count = Payment.objects.filter(
            status='Pending',
            created_at__lt=cutoff_time
        ).delete()

        # Clean up subscription payments  
        subscription_deleted_count = SubscriptionPayment.objects.filter(
            status='Pending',
            transaction_date__lt=cutoff_time
        ).delete()

        total_deleted = rent_deleted_count[0] + subscription_deleted_count[0]

        return Response({"message": f"Cleaned up {total_deleted} pending payments"})


# ------------------------------
# CSV EXPORT VIEWS
# ------------------------------

class LandLordCSVView(APIView):
    """
    Export landlord payment data as CSV
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, property_id):
        user = request.user
        if user.user_type != 'landlord':
            return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)

        property_obj = get_object_or_404(Property, id=property_id, landlord=user)
        units = Unit.objects.filter(property_obj=property_obj)
        payments = Payment.objects.filter(unit__in=units, status='Success')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="landlord_payments_{property_obj.name}.csv"'

        writer = csv.writer(response)
        writer.writerow(['Unit Number', 'Tenant', 'Amount', 'Date', 'M-Pesa Receipt'])

        for payment in payments:
            writer.writerow([
                payment.unit.unit_number,
                payment.tenant.full_name if payment.tenant else '',
                payment.amount,
                payment.transaction_date.strftime('%Y-%m-%d'),
                payment.mpesa_receipt or ''
            ])

        return response


class TenantCSVView(APIView):
    """
    Export tenant payment data as CSV
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, unit_id):
        user = request.user
        unit = get_object_or_404(Unit, id=unit_id)

        if user.user_type == 'tenant' and unit.tenant != user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        if user.user_type == 'landlord' and unit.property_obj.landlord != user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        payments = Payment.objects.filter(unit=unit, status='Success')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="tenant_payments_unit_{unit.unit_number}.csv"'

        writer = csv.writer(response)
        writer.writerow(['Amount', 'Date', 'M-Pesa Receipt', 'Type'])

        for payment in payments:
            writer.writerow([
                payment.amount,
                payment.transaction_date.strftime('%Y-%m-%d'),
                payment.mpesa_receipt or '',
                payment.payment_type
            ])

        return response


class TestMpesaView(APIView):
    """
    Test endpoint for M-Pesa integration
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        return Response({
            "message": "M-Pesa test endpoint",
            "mpesa_env": settings.MPESA_ENV,
            "shortcode": settings.MPESA_SHORTCODE
        })

    def post(self, request):
        # Test token generation
        token = generate_access_token()
        if token:
            return Response({
                "success": True,
                "message": "M-Pesa token generated successfully",
                "token_preview": token[:10] + "..."
            })
        else:
            return Response({
                "success": False,
                "message": "Failed to generate M-Pesa token"
            }, status=400)
// Communication App

# services/messaging.py
from django.conf import settings
from django.core.mail import send_mail


def send_bulk_emails(tenants):
    """
    Send rent reminder emails to a list of tenants.
    Each tenant receives a personalized message with their outstanding balance.
    """
    for tenant in tenants:
        subject = "Rent Payment Reminder"
        message = (
            f"Hello {tenant.full_name},\n\n"
            f"This is a reminder to pay your rent.\n"
            f"Outstanding balance: KES {tenant.unit.rent_remaining}."
        )
        try:
            send_mail(subject, message, settings.EMAIL_HOST_USER, [tenant.email])
        except Exception as e:
            print(f"Email failed for {tenant.email}: {e}")





def send_deadline_reminder_emails(tenants):
    """
    Send rent deadline reminder emails to a list of tenants.
    Each email includes the payment deadline date, outstanding balance, and login link.
    """
    for tenant in tenants:
        unit = tenant.unit
        subject = "Rent Payment Deadline Reminder"
        login_link = f"{settings.FRONTEND_URL}/login"
        message = (
            f"Hello {tenant.full_name},\n\n"
            f"This is a reminder that your rent payment is due on {unit.rent_due_date}.\n"
            f"Outstanding balance: KES {unit.rent_remaining}.\n\n"
            f"Please log in to your account to make the payment: {login_link}\n\n"
            "Thank you,\n"
            "Makau Rentals Team"
        )
        try:
            send_mail(subject, message, settings.EMAIL_HOST_USER, [tenant.email])
        except Exception as e:
            print(f"Email failed for {tenant.email}: {e}")


def send_deadline_reminders():
    """
    Send reminders to tenants based on their custom reminder preferences.
    """
    from datetime import timedelta
    from django.utils import timezone
    from accounts.models import CustomUser

    today = timezone.now().date()
    tenants_to_remind = []

    # Get all tenants with units and outstanding rent
    tenants = CustomUser.objects.filter(
        user_type="tenant",
        unit__isnull=False,
        unit__rent_remaining__gt=0
    ).select_related('unit')

    for tenant in tenants:
        unit = tenant.unit
        if tenant.reminder_mode == 'days_before':
            reminder_date = unit.rent_due_date - timedelta(days=tenant.reminder_value)
            if reminder_date == today:
                tenants_to_remind.append(tenant)
        elif tenant.reminder_mode == 'fixed_day':
            if today.day == tenant.reminder_value:
                # Optionally, check if due date is within a reasonable period, e.g., next 30 days
                if unit.rent_due_date and unit.rent_due_date >= today and (unit.rent_due_date - today).days <= 30:
                    tenants_to_remind.append(tenant)

    if tenants_to_remind:
        send_deadline_reminder_emails(tenants_to_remind)

# TODO:
# - This module handles sending bulk emails to tenants for rent reminders.
# - It uses Django's send_mail for email notifications.
# - The send_deadline_reminders() function is scheduled via Celery Beat to run automatically.

def send_report_email(report):
    """
    Send an email to the landlord when a new report is created.
    """
    landlord = report.unit.property_obj.landlord
    subject = f"New Issue Report: {report.issue_title}"
    issue_url = f"{settings.FRONTEND_URL}/reports/{report.id}"
    message = (
        f"Hello {landlord.full_name},\n\n"
        f"A new issue report has been submitted by tenant {report.tenant.full_name}.\n\n"
        f"Unit Number: {report.unit.unit_number}\n"
        f"Issue Category: {report.issue_category}\n"
        f"Priority Level: {report.priority_level}\n"
        f"Issue Title: {report.issue_title}\n"
        f"Description:\n{report.description}\n\n"
        f"To resolve the issue, please visit: {issue_url}\n\n"
        "Best regards,\n"
        "Makau Rentals System"
    )
    try:
        send_mail(subject, message, settings.EMAIL_HOST_USER, [landlord.email])
    except Exception as e:
        print(f"Failed to send report email: {e}")


def send_landlord_email(subject, message, tenants):
    """
    Send a custom email from landlord to a list of tenants.
    """
    recipient_emails = [tenant.email for tenant in tenants]
    try:
        send_mail(subject, message, settings.EMAIL_HOST_USER, recipient_emails)
    except Exception as e:
        print(f"Failed to send landlord email: {e}")
from django.db import models
from accounts.models import CustomUser, Unit
from django.utils import timezone

from django.db import models
from accounts.models import CustomUser, Unit
from django.utils import timezone

class Report(models.Model):
    ISSUE_CATEGORIES = [
        ('electrical', 'Electrical'),
        ('plumbing', 'Plumbing'),
        ('noise', 'Noise'),
        ('safety', 'Safety/Violence'),
        ('wifi', 'WiFi'),
        ('maintenance', 'General Maintenance'),
        ('pest', 'Pest Control'),
        ('security', 'Security'),
        ('cleanliness', 'Cleanliness'),
        ('other', 'Other'),
    ]

    PRIORITY_LEVELS = [
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('urgent', 'Urgent'),
    ]

    STATUS_CHOICES = [
        ('open', 'Open'),
        ('in_progress', 'In Progress'),
        ('resolved', 'Resolved'),
        ('closed', 'Closed'),
    ]

    # Basic required fields
    tenant = models.ForeignKey(
        CustomUser, 
        on_delete=models.CASCADE, 
        related_name='reports',
        limit_choices_to={'user_type': 'tenant'}
    )
    unit = models.ForeignKey(
        Unit, 
        on_delete=models.CASCADE, 
        related_name='reports'
    )
    issue_category = models.CharField(max_length=20, choices=ISSUE_CATEGORIES)
    priority_level = models.CharField(max_length=10, choices=PRIORITY_LEVELS, default='medium')
    issue_title = models.CharField(max_length=255)
    description = models.TextField()
    status = models.CharField(max_length=15, choices=STATUS_CHOICES, default='open')

    # Additional fields you added
    reported_date = models.DateTimeField(auto_now_add=True)
    resolved_date = models.DateTimeField(null=True, blank=True)
    assigned_to = models.ForeignKey(
        CustomUser, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        limit_choices_to={'user_type': 'landlord'},
        related_name='assigned_reports'
    )
    estimated_cost = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    actual_cost = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    
    # File attachments
    attachment = models.FileField(upload_to='report_attachments/', null=True, blank=True)
    
    class Meta:
        ordering = ['-reported_date']
        verbose_name = 'Maintenance Report'
        verbose_name_plural = 'Maintenance Reports'

    def save(self, *args, **kwargs):
        # Auto-assign priority based on category if not set
        if not self.priority_level or self.priority_level == 'medium':
            urgent_categories = ['safety', 'electrical', 'plumbing', 'security']
            self.priority_level = 'urgent' if self.issue_category in urgent_categories else 'medium'
        
        # Auto-set resolved_date when status changes to resolved
        if self.status == 'resolved' and not self.resolved_date:
            self.resolved_date = timezone.now()
        elif self.status != 'resolved' and self.resolved_date:
            self.resolved_date = None
            
        super().save(*args, **kwargs)

    @property
    def days_open(self):
        """Calculate how many days the report has been open"""
        if self.status == 'resolved' and self.resolved_date:
            return (self.resolved_date - self.reported_date).days
        return (timezone.now() - self.reported_date).days

    @property
    def is_urgent(self):
        """Check if the report is urgent based on priority and days open"""
        return self.priority_level == 'urgent' or self.days_open > 7

    def __str__(self):
        return f"Report #{self.id} - {self.issue_title} ({self.tenant.full_name})"

from rest_framework import permissions
from django.core.cache import cache
from accounts.models import CustomUser, Subscription

class IsTenantWithUnit(permissions.BasePermission):
    """
    Allows access only to tenants who have at least one assigned unit.
    """
    def has_permission(self, request, view):
        if not request.user.is_authenticated or request.user.user_type != 'tenant':
            return False
        
        # Check cache first
        cache_key = f"tenant_has_unit:{request.user.id}"
        has_unit = cache.get(cache_key)
        
        if has_unit is None:
            # Check if tenant has any units assigned (OneToOneField so use hasattr)
            has_unit = hasattr(request.user, 'unit') and request.user.unit is not None
            cache.set(cache_key, has_unit, timeout=300)  # Cache for 5 minutes
        
        return has_unit

class IsLandlordWithActiveSubscription(permissions.BasePermission):
    """
    Allows access only to landlords with active subscriptions.
    """
    def has_permission(self, request, view):
        if not request.user.is_authenticated or request.user.user_type != 'landlord':
            return False
        
        # Use cache to avoid repeated database queries
        cache_key = f"subscription_status:{request.user.id}"
        has_active_sub = cache.get(cache_key)
        
        if has_active_sub is None:
            try:
                subscription = Subscription.objects.get(user=request.user)
                has_active_sub = subscription.is_active()
            except Subscription.DoesNotExist:
                has_active_sub = False
            cache.set(cache_key, has_active_sub, timeout=300)  # Cache for 5 minutes
        
        return has_active_sub
from django.urls import path
from .views import (
    CreateReportView,
    OpenReportsView,
    UrgentReportsView,
    InProgressReportsView,
    ResolvedReportsView,
    UpdateReportStatusView,
    SendEmailView,
)

urlpatterns = [
    # Create a new report (POST)
    path('reports/create/', CreateReportView.as_view(), name='create-report'),  # Added /create/

    # List open reports for the authenticated user (GET)
    path('reports/open/', OpenReportsView.as_view(), name='open-reports'),

    # List urgent reports for the authenticated user (GET)
    path('reports/urgent/', UrgentReportsView.as_view(), name='urgent-reports'),

    # List in-progress reports for the authenticated user (GET)
    path('reports/in-progress/', InProgressReportsView.as_view(), name='in-progress-reports'),

    # List resolved reports for the authenticated user (GET)
    path('reports/resolved/', ResolvedReportsView.as_view(), name='resolved-reports'),

    # Update the status of a specific report (PATCH/PUT)
    path('reports/<int:pk>/update-status/', UpdateReportStatusView.as_view(), name='update-report-status'),

    # Send email to tenants (POST)
    path('reports/send-email/', SendEmailView.as_view(), name='send-email'),  # Added /reports/ prefix
]
from rest_framework import generics, permissions
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Report
from .serializers import ReportSerializer, UpdateReportStatusSerializer, SendEmailSerializer
from .permissions import IsTenantWithUnit, IsLandlordWithActiveSubscription
from accounts.permissions import CanAccessReport
from accounts.models import CustomUser, Unit
from .messaging import send_landlord_email
from rest_framework.permissions import IsAuthenticated


class CreateReportView(generics.CreateAPIView):
    queryset = Report.objects.all()
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated, IsTenantWithUnit]

    def perform_create(self, serializer):
        report = serializer.save()
        # Import here to avoid circular imports
        from app.tasks import send_report_email_task
        send_report_email_task.delay(report.id)

class OpenReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user

        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='open')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='open')
        return Report.objects.none()

class UrgentReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, priority_level='urgent')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, priority_level='urgent')
        return Report.objects.none()

class InProgressReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='in_progress')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='in_progress')
        return Report.objects.none()

class ResolvedReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='resolved')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='resolved')
        return Report.objects.none()

class UpdateReportStatusView(generics.UpdateAPIView):
    queryset = Report.objects.all()
    serializer_class = UpdateReportStatusSerializer
    permission_classes = [permissions.IsAuthenticated, CanAccessReport]

class SendEmailView(APIView):
    permission_classes = [permissions.IsAuthenticated, IsLandlordWithActiveSubscription]

    def post(self, request):
        serializer = SendEmailSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            subject = serializer.validated_data['subject']
            message = serializer.validated_data['message']
            send_to_all = serializer.validated_data['send_to_all']

            if send_to_all:
                # Get all tenants of the landlord
                landlord_properties = request.user.property_set.all()
                tenants = CustomUser.objects.filter(
                    user_type='tenant',
                    unit__property_obj__in=landlord_properties
                ).distinct()
            else:
                tenants = serializer.validated_data['tenants']

            send_landlord_email(subject, message, tenants)
            return Response({"message": "Emails sent successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
class ReportStatisticsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        user = request.user
        if user.user_type == 'landlord':
            reports = Report.objects.filter(unit__property_obj__landlord=user)
        else:
            reports = Report.objects.filter(tenant=user)
            
        stats = {
            'total': reports.count(),
            'open': reports.filter(status='open').count(),
            'in_progress': reports.filter(status='in_progress').count(),
            'resolved': reports.filter(status='resolved').count(),
            'urgent': reports.filter(priority_level='urgent', status__in=['open', 'in_progress']).count(),
            'average_resolution_time': self.get_average_resolution_time(reports),
        }
        return Response(stats)
    
    def get_average_resolution_time(self, reports):
        resolved_reports = reports.filter(status='resolved', resolved_date__isnull=False)
        if not resolved_reports:
            return 0
            
        total_days = sum((r.resolved_date - r.reported_date).days for r in resolved_reports)
        return total_days / resolved_reports.count()
>>>>>>> 394b10546b58926e7a572ca6fd906654abfb21ad
