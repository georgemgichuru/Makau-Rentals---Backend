from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status
from accounts.serializers import (
    PropertySerializer,
    UnitSerializer,
    UnitNumberSerializer,
    UserSerializer,
    PasswordResetSerializer,
    PasswordResetConfirmSerializer,
    ReminderPreferencesSerializer,
    AvailableUnitsSerializer,
)
from rest_framework.permissions import IsAuthenticated
from django.core.cache import cache
from .models import Property, Unit, CustomUser, Subscription, UnitType
from payments.models import Payment
from .permissions import IsLandlord, IsTenant, IsSuperuser, HasActiveSubscription
import logging

logger = logging.getLogger(__name__)

from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.db.models import Count, Sum, Q
from django.utils import timezone
from datetime import timedelta
from decimal import Decimal

# accounts/views.py
from rest_framework_simplejwt.views import TokenObtainPairView
from .serializers import MyTokenObtainPairSerializer
from .serializers import UnitTypeSerializer

class MyTokenObtainPairView(TokenObtainPairView):
    serializer_class = MyTokenObtainPairSerializer


class UnitTypeListCreateView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        unit_types = request.user.unit_types.all()
        serializer = UnitTypeSerializer(unit_types, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = UnitTypeSerializer(data=request.data)
        if serializer.is_valid():
            unit_type = serializer.save(landlord=request.user)
            
            # Automatically create units based on the unit_count
            unit_count = request.data.get('unit_count', 1)
            property_id = request.data.get('property_id')
            
            if property_id and unit_count > 0:
                try:
                    property_obj = Property.objects.get(id=property_id, landlord=request.user)
                    self.create_units_for_unit_type(property_obj, unit_type, unit_count)
                except Property.DoesNotExist:
                    return Response({"error": "Property not found or you do not have permission"}, status=404)
            
            return Response(serializer.data, status=201)
        return Response(serializer.errors, status=400)
    
    def create_units_for_unit_type(self, property_obj, unit_type, unit_count):
        """Create multiple units for a given unit type"""
        # Get existing units to determine next unit number
        existing_units = Unit.objects.filter(property_obj=property_obj)
        last_unit = existing_units.order_by('-unit_number').first()
        
        if last_unit and last_unit.unit_number.isdigit():
            start_number = int(last_unit.unit_number) + 1
        else:
            start_number = 1
        
        units_created = []
        for i in range(unit_count):
            unit_number = start_number + i
            unit_code = f"U-{property_obj.id}-{unit_type.name.replace(' ', '-')}-{unit_number}"
            
            unit = Unit.objects.create(
                property_obj=property_obj,
                unit_code=unit_code,
                unit_number=str(unit_number),
                unit_type=unit_type,
                is_available=True,
                rent=unit_type.rent,
                deposit=unit_type.deposit,
            )
            units_created.append(unit)
        
        return units_created


class LandlordDashboardStatsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        landlord = request.user

        # Total active tenants: tenants assigned to units of this landlord and active
        total_active_tenants = CustomUser.objects.filter(
            user_type='tenant',
            is_active=True,
            unit__property_obj__landlord=landlord
        ).distinct().count()

        # Total units available
        total_units_available = Unit.objects.filter(
            property_obj__landlord=landlord,
            is_available=True
        ).count()

        # Total units occupied
        total_units_occupied = Unit.objects.filter(
            property_obj__landlord=landlord,
            is_available=False
        ).count()

        # Monthly revenue: sum of successful rent payments in the current month for this landlord
        now = timezone.now()
        start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        monthly_revenue_agg = Payment.objects.filter(
            unit__property_obj__landlord=landlord,
            payment_type='rent',
            status='Success',
            transaction_date__gte=start_of_month,
            transaction_date__lte=now
        ).aggregate(total=Sum('amount'))
        monthly_revenue = monthly_revenue_agg['total'] or 0

        data = {
            "total_active_tenants": total_active_tenants,
            "total_units_available": total_units_available,
            "total_units_occupied": total_units_occupied,
            "monthly_revenue": float(monthly_revenue),
        }

        return Response(data)


class UnitTypeDetailView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get_object(self, pk, user):
        return UnitType.objects.get(id=pk, landlord=user)

    def get(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            serializer = UnitTypeSerializer(ut)
            return Response(serializer.data)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)

    def put(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            serializer = UnitTypeSerializer(ut, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)

    def delete(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            ut.delete()
            return Response({"message": "UnitType deleted"}, status=200)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)


# Lists a single user (cached)
# View to get user details
class UserDetailView(APIView):
    permission_classes = [HasActiveSubscription]

    def get(self, request, user_id):
        cache_key = f"user:{user_id}"
        user_data = cache.get(cache_key)

        if not user_data:
            try:
                user = CustomUser.objects.get(id=user_id)
                serializer = UserSerializer(user)
                user_data = serializer.data
                cache.set(cache_key, user_data, timeout=300)  # cache for 5 minutes
            except CustomUser.DoesNotExist:
                return Response({"error": "User not found"}, status=404)

        return Response(user_data)


# New admin view to list landlords and their subscription statuses (superuser only)
class AdminLandlordSubscriptionStatusView(APIView):
    permission_classes = [IsAuthenticated, IsSuperuser]

    def get(self, request):
        landlords = CustomUser.objects.filter(user_type='landlord')
        data = []
        for landlord in landlords:
            subscription = getattr(landlord, 'subscription', None)
            status = 'Subscribed' if subscription and subscription.is_active() else 'Inactive or None'
            data.append({
                'landlord_id': landlord.id,
                'email': landlord.email,
                'name': landlord.full_name,
                'subscription_plan': subscription.plan if subscription else 'None',
                'subscription_status': status,
                'expiry_date': subscription.expiry_date if subscription else None,
            })
        return Response(data)


# Lists all tenants (cached)
# View to list all tenants (landlord only)
class UserListView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        cache_key = "tenants:list"
        tenants_data = cache.get(cache_key)

        if not tenants_data:
            tenants = CustomUser.objects.filter(user_type="tenant")
            serializer = UserSerializer(tenants, many=True)
            tenants_data = serializer.data
            cache.set(cache_key, tenants_data, timeout=300)

        return Response(tenants_data)


# Create a new user (invalidate cache)
# View to create a new user Landlord or Tenant
class UserCreateView(APIView):
    def post(self, request):
        print("Signup request received:", request.data)  # Debug logging
        
        serializer = UserSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            print(f"User created successfully: {user.email}, ID: {user.id}")  # Debug logging

            # Landlord onboarding: optionally auto-create properties and units if provided
            if user.user_type == 'landlord':
                # Expect optional 'properties' array in request.data, each item: {name, city, state, unit_count, vacant_units}
                properties = request.data.get('properties')
                from .models import Property, Unit, UnitType
                import uuid

                if properties and isinstance(properties, list):
                    for prop in properties:
                        name = prop.get('name') or f"Property-{uuid.uuid4().hex[:6].upper()}"
                        city = prop.get('city', '')
                        state = prop.get('state', '')
                        unit_count = int(prop.get('unit_count', 0))
                        p = Property.objects.create(landlord=user, name=name, city=city, state=state, unit_count=unit_count)

                        # Create at least one unit if unit_count > 0
                        for i in range(1, unit_count + 1):
                            unit_number = str(i)
                            unit_code = f"U-{p.id}-{i}"
                            # Determine vacancy status based on optional vacant_units or default all vacant
                            vacant_units = int(prop.get('vacant_units', unit_count))
                            is_available = i <= vacant_units

                            # Optionally link to a unit_type if provided via name
                            unit_type_obj = None
                            unit_type_name = prop.get('unit_type')
                            if unit_type_name:
                                unit_type_obj, _ = UnitType.objects.get_or_create(landlord=user, name=unit_type_name)

                            Unit.objects.create(
                                property_obj=p,
                                unit_code=unit_code,
                                unit_number=unit_number,
                                unit_type=unit_type_obj,
                                is_available=is_available,
                                rent=unit_type_obj.rent if unit_type_obj else 0,
                                deposit=unit_type_obj.deposit if unit_type_obj else 0,
                            )

            # Tenant created: attempt to assign unit if landlord_code and unit_code provided
            if user.user_type == "tenant":
                cache.delete("tenants:list")
                landlord_code = request.data.get('landlord_code')
                unit_code = request.data.get('unit_code')
                if landlord_code and unit_code:
                    try:
                        landlord = CustomUser.objects.get(landlord_code=landlord_code, user_type='landlord')
                        unit = Unit.objects.get(unit_code=unit_code, property_obj__landlord=landlord)
                        # Check for deposit payments
                        from payments.models import Payment
                        deposit_payments = Payment.objects.filter(
                            tenant=user,
                            payment_type='deposit',
                            status='Success',
                            amount__gte=unit.deposit
                        )
                        if deposit_payments.exists():
                            unit.tenant = user
                            unit.is_available = False
                            unit.save()
                        else:
                            # leave unassigned; frontend should request deposit
                            pass
                    except CustomUser.DoesNotExist:
                        # landlord not found; ignore
                        pass
                    except Unit.DoesNotExist:
                        pass

            return Response(serializer.data, status=201)
        else:
            print("Serializer errors:", serializer.errors)  # Debug logging
            return Response(serializer.errors, status=400)


# Create a new property (invalidate landlord cache)
# View to create a new property (landlord only)
PLAN_LIMITS = {
    "free": 2,         # trial landlords can only create 2 properties
    "starter": 3,      # starter (up to 10 units) -> small number of properties
    "basic": 10,       # basic (10-50 units)
    "professional": 25,# professional (50-100 units)
    "onetime": None,   # unlimited
}

class CreatePropertyView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        logger.info(f"CreatePropertyView: User {request.user.id} attempting to create property")
        user = request.user

        # Fetch subscription
        try:
            subscription = Subscription.objects.get(user=user)
            logger.info(f"Subscription found: {subscription.plan}")
        except Subscription.DoesNotExist:
            logger.error(f"No subscription found for user {user.id}")
            return Response({"error": "No active subscription found."}, status=403)

        plan = subscription.plan.lower()

        # Check if subscription is active
        if not subscription.is_active():
            logger.warning(f"Subscription expired for user {user.id}")
            return Response({"error": "Your subscription has expired. Please renew or upgrade."}, status=403)

        # Get plan limit
        max_properties = PLAN_LIMITS.get(plan)
        if max_properties is None:
            logger.error(f"Unknown plan {plan} for user {user.id}")
            return Response({"error": f"Unknown plan type: {plan}"}, status=400)

        # Count current properties
        current_count = Property.objects.filter(landlord=user).count()
        logger.info(f"Current properties count: {current_count}, max: {max_properties}")
        if current_count >= max_properties:
            logger.warning(f"Property limit reached for user {user.id}")
            return Response({
                "error": f"Your current plan ({plan}) allows a maximum of {max_properties} properties. Upgrade to add more."
            }, status=403)

        # Proceed with creation
        serializer = PropertySerializer(data=request.data)
        if serializer.is_valid():
            logger.info(f"Serializer valid, saving property for user {user.id}")
            property = serializer.save(landlord=user)
            try:
                cache.delete(f"landlord:{user.id}:properties")  # clear cache if you're caching landlord properties
                logger.info(f"Cache cleared for user {user.id}")
            except Exception as e:
                logger.warning(f"Cache delete failed: {e}")
            logger.info(f"Property created successfully: {property.id}")
            return Response(serializer.data, status=201)

        logger.error(f"Serializer errors: {serializer.errors}")
        return Response(serializer.errors, status=400)

# List landlord properties (cached)
class LandlordPropertiesView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        cache_key = f"landlord:{request.user.id}:properties"
        properties_data = cache.get(cache_key)

        if not properties_data:
            properties = Property.objects.filter(landlord=request.user)
            serializer = PropertySerializer(properties, many=True)
            properties_data = serializer.data
            cache.set(cache_key, properties_data, timeout=300)

        return Response(properties_data)


# Create a new unit (invalidate landlord cache)
class CreateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        serializer = UnitSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            unit = serializer.save()
            cache.delete(f"landlord:{request.user.id}:properties")
            return Response(serializer.data, status=201)
        return Response(serializer.errors, status=400)


# List units of a property (cached)
class PropertyUnitsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request, property_id):
        cache_key = f"property:{property_id}:units"
        units_data = cache.get(cache_key)

        if not units_data:
            try:
                property = Property.objects.get(id=property_id, landlord=request.user)
                units = Unit.objects.filter(property_obj=property)
                serializer = UnitSerializer(units, many=True)
                units_data = serializer.data
                cache.set(cache_key, units_data, timeout=300)
            except Property.DoesNotExist:
                return Response(
                    {"error": "Property not found or you do not have permission"},
                    status=404,
                )

        return Response(units_data)


# Assign tenant to unit (invalidate cache)
class AssignTenantView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    @method_decorator(csrf_exempt)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

    def post(self, request, unit_id, tenant_id):
        logger.info(f"AssignTenantView: Landlord {request.user.id} attempting to assign tenant {tenant_id} to unit {unit_id}")

        try:
            # Validate unit exists and belongs to landlord
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            logger.info(f"Unit found: {unit.unit_code}, available: {unit.is_available}")

            # Validate unit is available
            if not unit.is_available:
                logger.warning(f"Unit {unit_id} is not available for assignment")
                return Response({
                    "error": "Unit is not available for assignment",
                    "status": "failed"
                }, status=400)

            # Validate tenant exists and is a tenant
            tenant = CustomUser.objects.get(id=tenant_id, user_type="tenant")
            logger.info(f"Tenant found: {tenant.full_name} (ID: {tenant.id})")

            # Check if tenant already has a unit assigned
            existing_unit = Unit.objects.filter(tenant=tenant).first()
            if existing_unit:
                logger.warning(f"Tenant {tenant_id} already has unit {existing_unit.id} assigned")
                return Response({
                    "error": f"Tenant already has unit {existing_unit.unit_number} assigned",
                    "status": "failed"
                }, status=400)

            # CHECK IF DEPOSIT IS PAID BEFORE ASSIGNMENT
            from payments.models import Payment
            deposit_paid = Payment.objects.filter(
                tenant=tenant,
                unit=unit,
                payment_type='deposit',
                status='Success',
                amount__gte=unit.deposit
            ).exists()
            
            if not deposit_paid:
                logger.warning(f"Tenant {tenant_id} has not paid deposit for unit {unit_id}")
                return Response({
                    "error": "Tenant must pay deposit before being assigned to unit",
                    "status": "failed"
                }, status=400)

            # If deposit is paid, assign tenant immediately
            unit.tenant = tenant
            unit.is_available = False
            unit.save()
            
            logger.info(f"✅ Tenant {tenant.full_name} assigned to unit {unit.unit_number}")

            return Response({
                'message': f'Tenant {tenant.full_name} successfully assigned to unit {unit.unit_number}',
                'status': 'success'
            }, status=200)

        except Unit.DoesNotExist:
            logger.error(f"Unit {unit_id} not found or not owned by landlord {request.user.id}")
            return Response({
                "error": "Unit not found or you do not have permission",
                "status": "failed"
            }, status=404)
        except CustomUser.DoesNotExist:
            logger.error(f"Tenant {tenant_id} not found or invalid user type")
            return Response({
                "error": "Tenant not found or invalid user type",
                "status": "failed"
            }, status=404)
        except Exception as e:
            logger.error(f"Unexpected error in AssignTenantView: {str(e)}")
            return Response({
                "error": "An unexpected error occurred",
                "status": "failed"
            }, status=500)


# Password reset
class PasswordResetView(APIView):
    def post(self, request):
        serializer = PasswordResetSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(
                {"message": "Password reset email sent."}, status=status.HTTP_200_OK
            )
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
# Update property
class UpdatePropertyView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def put(self, request, property_id):
        try:
            property = Property.objects.get(id=property_id, landlord=request.user)
            serializer = PropertySerializer(property, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"landlord:{request.user.id}:properties")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Property.DoesNotExist:
            return Response({"error": "Property not found or you do not have permission"}, status=404)

    def delete(self, request, property_id):
        try:
            property = Property.objects.get(id=property_id, landlord=request.user)
            property.delete()
            cache.delete(f"landlord:{request.user.id}:properties")
            return Response({"message": "Property deleted successfully."}, status=200)
        except Property.DoesNotExist:
            return Response({"error": "Property not found or you do not have permission"}, status=404)

# Update unit
class UpdateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def put(self, request, unit_id):
        try:
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            serializer = UnitSerializer(unit, data=request.data, partial=True, context={'request': request})
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"landlord:{request.user.id}:properties")
                cache.delete(f"property:{unit.property_obj.id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Unit.DoesNotExist:
            return Response({"error": "Unit not found or you do not have permission"}, status=404)

    def delete(self, request, unit_id):
        try:
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            property_id = unit.property_obj.id
            unit.delete()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{property_id}:units")
            return Response({"message": "Unit deleted successfully."}, status=200)
        except Unit.DoesNotExist:
            return Response({"error": "Unit not found or you do not have permission"}, status=404)


class TenantUpdateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsTenant]

    def put(self, request):
        try:
            unit = Unit.objects.get(tenant=request.user)
            serializer = UnitNumberSerializer(unit, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"property:{unit.property_obj.id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Unit.DoesNotExist:
            return Response({"error": "No unit assigned to you"}, status=404)

# Update user
class UpdateUserView(APIView):  
    permission_classes = [IsAuthenticated]

    def put(self, request, user_id):
        if request.user.id != user_id:
            return Response({"error": "You do not have permission to update this user."}, status=403)
        try:
            user = CustomUser.objects.get(id=user_id)
            serializer = UserSerializer(user, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"user:{user_id}")
                if user.user_type == "tenant":
                    cache.delete("tenants:list")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except CustomUser.DoesNotExist:
            return Response({"error": "User not found"}, status=404)

    def delete(self, request, user_id):
        if request.user.id != user_id:
            return Response({"error": "You do not have permission to delete this user."}, status=403)
        try:
            user = CustomUser.objects.get(id=user_id)
            user.delete()
            cache.delete(f"user:{user_id}")
            if user.user_type == "tenant":
                cache.delete("tenants:list")
            return Response({"message": "User deleted successfully."}, status=200)
        except CustomUser.DoesNotExist:
            return Response({"error": "User not found"}, status=404)


class AdjustRentView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        landlord = request.user
        adjustment_type = request.data.get('adjustment_type')  # 'percentage' or 'fixed'
        value = request.data.get('value')  # decimal, positive for increase, negative for decrease
        unit_type_id = request.data.get('unit_type_id')  # optional, if provided, adjust only units of this type

        if adjustment_type not in ['percentage', 'fixed']:
            return Response({"error": "adjustment_type must be 'percentage' or 'fixed'"}, status=400)

        try:
            value = Decimal(value)
        except (ValueError, TypeError):
            return Response({"error": "value must be a valid number"}, status=400)

        # Filter units
        units = Unit.objects.filter(property_obj__landlord=landlord)
        if unit_type_id:
            try:
                unit_type = UnitType.objects.get(id=unit_type_id, landlord=landlord)
                units = units.filter(unit_type=unit_type)
            except UnitType.DoesNotExist:
                return Response({"error": "UnitType not found or not owned by you"}, status=404)

        updated_count = 0
        for unit in units:
            old_rent = unit.rent
            if adjustment_type == 'percentage':
                new_rent = old_rent * (Decimal(1) + value / Decimal(100))
            else:  # fixed
                new_rent = old_rent + value
            # Ensure rent doesn't go negative
            new_rent = max(Decimal(0), new_rent)
            unit.rent = new_rent
            unit.save()  # This will update rent_remaining
            updated_count += 1

        # Invalidate caches
        cache.delete(f"landlord:{landlord.id}:properties")
        # Also invalidate rent_summary cache
        from payments.views import RentSummaryView
        cache.delete(f"rent_summary:{landlord.id}")

        return Response({"message": f"Rent adjusted for {updated_count} units successfully"})

    def put(self, request):
        landlord = request.user
        new_rent = request.data.get('new_rent')
        unit_type_id = request.data.get('unit_type_id')  # optional

        if new_rent is None:
            return Response({"error": "new_rent is required"}, status=400)

        try:
            new_rent = Decimal(new_rent)
        except (ValueError, TypeError):
            return Response({"error": "new_rent must be a valid number"}, status=400)

        units = Unit.objects.filter(property_obj__landlord=landlord)
        if unit_type_id:
            try:
                unit_type = UnitType.objects.get(id=unit_type_id, landlord=landlord)
                units = units.filter(unit_type=unit_type)
            except UnitType.DoesNotExist:
                return Response({"error": "UnitType not found or not owned by you"}, status=404)

        updated_count = 0
        for unit in units:
            unit.rent = new_rent
            unit.save()
            updated_count += 1

        # Invalidate caches
        cache.delete(f"landlord:{landlord.id}:properties")
        from payments.views import RentSummaryView
        cache.delete(f"rent_summary:{landlord.id}")

        return Response({"message": f"Rent set to {new_rent} for {updated_count} units successfully"})

# View to check subscription status (landlord only)
class SubscriptionStatusView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord]

    def get(self, request):
        user = request.user
        try:
            subscription = Subscription.objects.get(user=user)
            data = {
                "plan": subscription.plan,
                "is_active": subscription.is_active(),
                "expiry_date": subscription.expiry_date,
                "status": "Subscribed" if subscription.is_active() else "Inactive"
            }
        except Subscription.DoesNotExist:
            data = {"status": "No subscription found"}
        return Response(data)

# View to update landlord's Mpesa till number (landlord only)
class UpdateTillNumberView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def patch(self, request):
        user = request.user
        till_number = request.data.get('mpesa_till_number')
        if not till_number:
            return Response({"error": "mpesa_till_number is required"}, status=400)

        user.mpesa_till_number = till_number
        user.save()
        return Response({"message": "Till number updated successfully", "mpesa_till_number": till_number})

    def put(self, request):
        return self.patch(request)


# Endpoint to get or update the currently authenticated user
class MeView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        serializer = UserSerializer(request.user)
        return Response(serializer.data)

    def patch(self, request):
        serializer = UserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            # invalidate cache for this user
            cache.delete(f"user:{request.user.id}")
            return Response(serializer.data)
        return Response(serializer.errors, status=400)

    def put(self, request):
        return self.patch(request)


# View to update tenant reminder preferences
class UpdateReminderPreferencesView(APIView):
    permission_classes = [IsAuthenticated, IsTenant]

    def patch(self, request):
        serializer = ReminderPreferencesSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)


# Password reset confirm view
class PasswordResetConfirmView(APIView):
    def post(self, request):
        serializer = PasswordResetConfirmSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "Password has been reset successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


# View to list available units for landlords to share with tenants
class LandlordAvailableUnitsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        units = Unit.objects.filter(property_obj__landlord=request.user, is_available=True)
        serializer = AvailableUnitsSerializer(units, many=True)
        return Response(serializer.data)

import base64
import datetime
import json
import requests
import csv
import time
from decimal import Decimal, InvalidOperation
from django.http import HttpResponse
from datetime import timedelta
from django.conf import settings
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import logging
from django.utils import timezone
from django.core.cache import cache
from django.shortcuts import get_object_or_404
from accounts.models import CustomUser, Subscription, Property, Unit, UnitType
# Removed require_subscription import as it's no longer used
from accounts.serializers import UnitTypeSerializer
from .models import Payment, SubscriptionPayment
from .generate_token import generate_access_token, initiate_b2c_payment
from rest_framework import generics, permissions
from .serializers import PaymentSerializer, SubscriptionPaymentSerializer
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.utils.decorators import method_decorator
from accounts.permissions import IsLandlord, HasActiveSubscription
# ------------------------------
# STK PUSH INITIATION (Tenant Rent Payment) - UPDATED
# ------------------------------
@csrf_exempt
def stk_push(request, unit_id):
    """
    Initiates an M-Pesa STK Push for a tenant's rent payment.
    """
    logger = logging.getLogger(__name__)

    # Check authentication first
    if not request.user.is_authenticated:
        return JsonResponse({"error": "Authentication required"}, status=401)

    if request.user.user_type != 'tenant':
        return JsonResponse({"error": "Only tenants can make rent payments"}, status=403)

    try:
        if request.method != 'POST':
            return JsonResponse({"error": "POST method required."}, status=405)

        # Parse JSON body
        try:
            body = json.loads(request.body.decode('utf-8'))
        except json.JSONDecodeError:
            return JsonResponse({"error": "Invalid JSON body."}, status=400)

        # Get amount from JSON data
        amount_str = body.get('amount')
        if not amount_str:
            return JsonResponse({"error": "Amount is required."}, status=400)

        try:
            amount = Decimal(amount_str)
        except InvalidOperation:
            return JsonResponse({"error": "Invalid amount format."}, status=400)
        
        # Rate limiting: Check if user has made too many requests
        rate_limit_key = f"stk_push_rate_limit:{request.user.id}"
        recent_requests = cache.get(rate_limit_key, 0)
        if recent_requests >= 5:  # Max 5 requests per minute
            return JsonResponse({"error": "Too many requests. Please try again later."}, status=429)
        
        # Update rate limit counter
        cache.set(rate_limit_key, recent_requests + 1, timeout=60)
        
        # REQUIRE tenant to be assigned to unit for rent payments
        try:
            unit = Unit.objects.get(id=unit_id, tenant=request.user)
        except Unit.DoesNotExist:
            return JsonResponse({"error": "Unit not found or you are not assigned to this unit. Please pay deposit first."}, status=404)
        
        # Validate amount
        if amount <= 0:
            return JsonResponse({"error": "Amount must be positive."}, status=400)
        
        # Allow any amount that's at least the rent (for testing)
        if amount < unit.rent:
            return JsonResponse({"error": f"Amount must be at least the monthly rent ({unit.rent})."}, status=400)
        
        # More generous maximum for testing
        max_amount = unit.rent * 24  # Allow up to 2 years rent for testing
        if amount > max_amount:
            return JsonResponse({"error": f"Amount cannot exceed two years' rent ({max_amount})."}, status=400)
        
        # Check for duplicate pending payment
        duplicate_key = f"pending_payment:{request.user.id}:{unit_id}"
        if cache.get(duplicate_key):
            return JsonResponse({"error": "A payment request is already pending for this unit."}, status=400)
        
        # Create a pending payment record
        payment = Payment.objects.create(
            tenant=request.user,
            unit=unit,
            amount=amount,
            status="Pending"
        )
        
        # Mark payment as pending in Redis (5-minute expiry)
        cache.set(duplicate_key, payment.id, timeout=300)
        
        # Check if tenant has paid deposit for this unit (REQUIRED)
        deposit_paid = Payment.objects.filter(
            tenant=request.user,
            unit=unit,
            payment_type='deposit',
            status='Success',
            amount__gte=unit.deposit
        ).exists()
        if not deposit_paid:
            return JsonResponse({"error": "You must pay the deposit for this unit before making rent payments."}, status=400)

        # Rest of the function remains the same...
        try:
            # Generate access token (with Redis caching and retry)
            access_token_cache_key = "mpesa_access_token"
            access_token = cache.get(access_token_cache_key)
            if not access_token:
                try:
                    access_token = generate_access_token()
                except Exception as e:
                    logger.error(f"Access token generation failed, retrying: {str(e)}")
                    # Retry once after a short delay
                    import time
                    time.sleep(1)
                    access_token = generate_access_token()
            # Cache access token for 55 minutes (MPESA tokens expire in 1 hour)
            cache.set(access_token_cache_key, access_token, timeout=3300)
        except Exception as e:
            logger.error(f"Access token generation failed after retry: {str(e)}")
            return JsonResponse({"error": "Payment service temporarily unavailable. Please try again later."}, status=503)
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        password = base64.b64encode(
            (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode("utf-8")
        ).decode("utf-8")
        
        # Always use central shortcode for rent payments
        business_shortcode = settings.MPESA_SHORTCODE
        
        # Build payload for Safaricom API
        payload = {
            "BusinessShortCode": business_shortcode,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": str(int(amount)),  # Ensure whole number for M-Pesa
            "PartyA": request.user.phone_number,
            "PartyB": business_shortcode,
            "PhoneNumber": request.user.phone_number,
            "CallBackURL": settings.MPESA_RENT_CALLBACK_URL,
            "AccountReference": str(payment.id),
            "TransactionDesc": f"Rent for Unit {unit.unit_number}"
        }
        
        headers = {"Authorization": f"Bearer {access_token}"}
        
        try:
            response = requests.post(
                "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest",
                json=payload,
                headers=headers,
                timeout=30
            )
            response.raise_for_status()
            response_data = response.json()
        except requests.exceptions.RequestException as e:
            # Don't fail the payment - mark it as pending for manual processing
            logger.error(f"M-Pesa API request failed: {str(e)}")
            return JsonResponse({
                "message": "Payment initiation received. Please check your phone to complete payment.",
                "payment_id": payment.id
            })
        except json.JSONDecodeError as e:
            logger.error(f"Invalid response from M-Pesa API: {str(e)}")
            return JsonResponse({
                "message": "Payment initiation received. Please check your phone to complete payment.",
                "payment_id": payment.id
            })
        
        if response_data.get("ResponseCode") == "0":
            # Return success immediately without waiting
            return JsonResponse({
                "message": "Payment initiated successfully. Please check your phone to complete payment.",
                "checkout_request_id": response_data.get("CheckoutRequestID"),
                "payment_id": payment.id
            })
        else:
            # M-Pesa returned an error but we don't fail the payment
            error_msg = response_data.get("ResponseDescription", "Unknown error")
            logger.error(f"M-Pesa STK push error: {error_msg}")
            return JsonResponse({
                "message": "Payment initiation received. Please check your phone to complete payment.",
                "payment_id": payment.id,
                "note": "If payment doesn't appear on your phone, please try again in a few minutes."
            })
            
    except Exception as e:
        logger.error(f"Unexpected error in stk_push: {str(e)}")
        return JsonResponse({"error": "Payment service temporarily unavailable. Please try again later."}, status=503)
# ------------------------------
# STK PUSH INITIATION (Landlord Subscription Payment) - UPDATED
# ------------------------------
@csrf_exempt
def stk_push_subscription(request):
    """
    Initiates an M-Pesa STK Push for a landlord's subscription payment.
    - Uses minimal amounts for testing (50 KSH)
    - Better error handling
    """
    try:
        # Get subscription plan from request
        plan = None
        phone_number = None
        
        try:
            if request.method == 'POST':
                try:
                    body = json.loads(request.body.decode('utf-8') or '{}')
                except Exception:
                    body = {}
                plan = body.get('plan') or request.GET.get('plan')
                phone_number = body.get('phone_number')
            else:
                plan = request.GET.get('plan')
        except Exception:
            plan = request.GET.get('plan')
        
        if not plan:
            return JsonResponse({"error": "Plan parameter is required."}, status=400)
        if not phone_number:
            return JsonResponse({"error": "Phone number is required."}, status=400)
        
        # Map plan to amount - MINIMAL AMOUNTS FOR TESTING
        plan_amounts = {
            "starter": 50,      # Only 50 KSH for testing
            "basic": 100,       # Only 100 KSH for testing  
            "professional": 200, # Only 200 KSH for testing
            "onetime": 500,     # Only 500 KSH for testing
        }
        
        if plan not in plan_amounts:
            return JsonResponse({"error": "Invalid plan."}, status=400)
        
        amount = plan_amounts[plan]
        
        # Rate limiting
        rate_limit_key = f"stk_push_subscription_rate_limit:{phone_number}"
        recent_requests = cache.get(rate_limit_key, 0)
        if recent_requests >= 3:
            return JsonResponse({"error": "Too many requests. Please try again later."}, status=429)
        
        cache.set(rate_limit_key, recent_requests + 1, timeout=60)
        
        # Check for duplicate pending subscription payment
        duplicate_key = f"pending_subscription_payment:{phone_number}:{plan}"
        if cache.get(duplicate_key):
            return JsonResponse({"error": "A subscription payment request is already pending."}, status=400)
        
        # Determine user
        user = None
        if request.user.is_authenticated and request.user.user_type == 'landlord':
            user = request.user
        
        # Create a pending subscription payment record
        subscription_payment = SubscriptionPayment.objects.create(
            user=user,
            amount=amount,
            mpesa_receipt_number="",
            subscription_type=plan
        )
        
        # Mark payment as pending in Redis (5-minute expiry)
        cache.set(duplicate_key, subscription_payment.id, timeout=300)
        
        try:
            # Generate access token
            access_token_cache_key = "mpesa_access_token"
            access_token = cache.get(access_token_cache_key)
            if not access_token:
                access_token = generate_access_token()
            cache.set(access_token_cache_key, access_token, timeout=3300)
        except Exception as e:
            print(f"Access token generation warning: {str(e)}")
            try:
                access_token = generate_access_token()
            except Exception as token_error:
                return JsonResponse({"error": "Subscription service temporarily unavailable. Please try again later."}, status=503)
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        password = base64.b64encode(
            (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode("utf-8")
        ).decode("utf-8")
        
        # Build payload for Safaricom API
        party_phone = phone_number
        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": str(amount),
            "PartyA": party_phone,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": party_phone,
            "CallBackURL": settings.MPESA_SUBSCRIPTION_CALLBACK_URL,
            "AccountReference": str(subscription_payment.id),
            "TransactionDesc": f"Subscription payment for {plan} plan"
        }
        
        headers = {"Authorization": f"Bearer {access_token}"}
        
        try:
            response = requests.post(
                "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest",
                json=payload,
                headers=headers,
                timeout=30
            )
            response.raise_for_status()
            response_data = response.json()
        except requests.exceptions.RequestException as e:
            print(f"M-Pesa subscription API request failed: {str(e)}")
            return JsonResponse({
                "message": "Subscription payment initiation received.",
                "payment_id": subscription_payment.id
            })
        
        if response_data.get("ResponseCode") == "0":
            return JsonResponse({
                "message": "Subscription payment initiated successfully.",
                "checkout_request_id": response_data.get("CheckoutRequestID"),
                "payment_id": subscription_payment.id
            })
        else:
            error_msg = response_data.get("ResponseDescription", "Unknown error")
            print(f"M-Pesa subscription STK push error: {error_msg}")
            return JsonResponse({
                "message": "Subscription payment initiation received.",
                "payment_id": subscription_payment.id
            })
            
    except Exception as e:
        print(f"Unexpected error in stk_push_subscription: {str(e)}")
        return JsonResponse({"error": "Subscription service temporarily unavailable. Please try again later."}, status=503)
# ------------------------------
# RENT PAYMENT CALLBACK
# ------------------------------
# In payments/views.py - FIX THE MPESA RENT CALLBACK
@csrf_exempt
def mpesa_rent_callback(request):
    """
    Handles M-Pesa callback for rent payments.
    - Updates Payment status
    - Updates Unit rent balances
    - Initiates B2C disbursement to landlord
    - Invalidates relevant caches
    """
    logger = logging.getLogger(__name__)
    logger.info("🔄 Rent callback received")

    try:
        data = json.loads(request.body.decode("utf-8"))
        logger.info(f"📥 Rent callback data: {json.dumps(data, indent=2)}")

        body = data.get("Body", {}).get("stkCallback", {})
        result_code = body.get("ResultCode")
        logger.info(f"🔍 Rent callback result code: {result_code}")

        if result_code == 0:  # ✅ Transaction successful
            metadata_items = body.get("CallbackMetadata", {}).get("Item", [])
            logger.info(f"📋 Rent callback metadata items: {len(metadata_items)}")
            metadata = {item["Name"]: item.get("Value") for item in metadata_items}
            logger.info(f"🔧 Raw metadata: {metadata}")

            # Convert amount to Decimal for consistency
            amount_str = metadata.get("Amount")
            amount = None
            if amount_str:
                try:
                    amount = Decimal(amount_str)
                    logger.info(f"💰 Rent callback amount: {amount} (Decimal)")
                except (ValueError, TypeError) as e:
                    logger.error(f"❌ Invalid amount format: {amount_str}, error: {e}")

            receipt = metadata.get("MpesaReceiptNumber")
            payment_id = metadata.get("AccountReference")
            phone = str(metadata.get("PhoneNumber")) if metadata.get("PhoneNumber") else None

            logger.info(f"💰 Rent callback metadata: amount={amount}, receipt={receipt}, payment_id={payment_id}, phone={phone}")

            if payment_id:
                logger.info(f"🔍 Looking for payment with ID: {payment_id}")
                try:
                    payment = Payment.objects.get(id=payment_id, status="Pending")
                    logger.info(f"✅ Found pending rent payment: {payment.id} for tenant {payment.tenant.email}")

                    payment.status = "Success"
                    payment.mpesa_receipt = receipt
                    payment.save()
                    logger.info(f"✅ Payment {payment.id} status updated to Success")

                    # Update unit balances - FIXED: Use Decimal amount
                    unit = payment.unit
                    unit.rent_paid += amount  # Now both are Decimal
                    unit.rent_remaining = max(unit.rent - unit.rent_paid, Decimal('0'))
                    unit.save()
                    logger.info(f"✅ Unit {unit.unit_number} balances updated: paid={unit.rent_paid}, remaining={unit.rent_remaining}")

                    # Invalidate relevant caches
                    cache.delete_many([
                        f"pending_payment:{payment.tenant.id}:{unit.id}",
                        f"payments:tenant:{payment.tenant.id}",
                        f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                        f"rent_summary:{unit.property_obj.landlord.id}",
                        f"unit:{unit.id}:details"
                    ])
                    logger.info(f"🗑️ Cache invalidated for payment {payment.id}")
                    logger.info(f"✅ Rent payment successful: {receipt} for payment {payment_id}")

                    # Initiate B2C disbursement to landlord
                    landlord = unit.property_obj.landlord
                    recipient = landlord.mpesa_till_number or landlord.phone_number
                    logger.info(f"🏦 Initiating B2C disbursement to landlord {landlord.email}, recipient: {recipient}")
                    if recipient:
                        try:
                            b2c_response = initiate_b2c_payment(
                                amount=amount,
                                recipient=recipient,
                                payment_id=payment_id,
                                remarks=f"Rent payment disbursement for Unit {unit.unit_number}"
                            )
                            logger.info(f"✅ B2C disbursement initiated for payment {payment_id}: {b2c_response}")
                        except ValueError as e:
                            logger.error(f"❌ B2C disbursement failed for payment {payment_id}: {str(e)}")
                    else:
                        logger.error(f"❌ No recipient (till number or phone) for landlord {landlord.id}")

                except Payment.DoesNotExist:
                    logger.error(f"❌ Payment with id {payment_id} not found or already processed")
                except Exception as e:
                    logger.error(f"❌ Error updating payment {payment_id}: {e}")
            else:
                logger.warning("⚠️ No payment_id in rent callback, cannot process payment")
        else:
            # ❌ Transaction failed - UPDATE PAYMENT STATUS TO FAILED
            error_msg = body.get("ResultDesc", "Unknown error")
            logger.error(f"❌ Rent transaction failed: {error_msg} (ResultCode: {result_code})")
            # Try to find and update the payment to Failed
            try:
                payment_id = body.get("AccountReference")
                if payment_id:
                    payment = Payment.objects.get(id=payment_id, status="Pending")
                    payment.status = "Failed"
                    payment.save()
                    logger.info(f"✅ Rent payment {payment_id} marked as Failed")
                    # Invalidate caches
                    cache.delete_many([
                        f"pending_payment:{payment.tenant.id}:{payment.unit.id}",
                        f"payments:tenant:{payment.tenant.id}",
                        f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                    ])
                    logger.info(f"🗑️ Cache invalidated for failed payment {payment_id}")
            except Payment.DoesNotExist:
                logger.error(f"Payment with id {payment_id} not found for failure update")
            except Exception as e:
                logger.error(f"Error updating failed payment: {e}")

    except json.JSONDecodeError as e:
        logger.error(f"❌ Invalid JSON in rent callback: {e}")
    except Exception as e:
        logger.error("❌ Unexpected error processing rent callback:", exc_info=True)

    # CRITICAL: Always respond with success to Safaricom to acknowledge callback receipt
    logger.info("✅ Responding with success to M-Pesa rent callback")
    return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})
# ------------------------------
# SUBSCRIPTION PAYMENT CALLBACK
# ------------------------------
@csrf_exempt
def mpesa_subscription_callback(request):
    """
    Handles M-Pesa callback for subscription payments.
    - Finds user by phone number
    - Creates/updates subscription payment
    - Updates user subscription
    - Handles duplicate receipts gracefully
    """
    logger = logging.getLogger(__name__)
    logger.info("🔄 Subscription callback received")

    try:
        data = json.loads(request.body.decode("utf-8"))
        logger.info(f"📥 Subscription callback data: {json.dumps(data, indent=2)}")

        body = data.get("Body", {}).get("stkCallback", {})
        result_code = body.get("ResultCode")
        logger.info(f"🔍 Subscription callback result code: {result_code}")

        if result_code == 0:  # ✅ Transaction successful
            metadata_items = body.get("CallbackMetadata", {}).get("Item", [])
            logger.info(f"📋 Subscription callback metadata items: {len(metadata_items)}")
            metadata = {item["Name"]: item.get("Value") for item in metadata_items}
            logger.info(f"🔧 Raw metadata: {metadata}")

            # Convert amount to Decimal for consistency
            amount_str = metadata.get("Amount")
            amount = None
            if amount_str:
                try:
                    amount = Decimal(amount_str)
                    logger.info(f"💰 Subscription callback amount: {amount} (Decimal)")
                except (ValueError, TypeError) as e:
                    logger.error(f"❌ Invalid amount format: {amount_str}, error: {e}")

            receipt = metadata.get("MpesaReceiptNumber")
            account_reference = metadata.get("AccountReference")
            phone = str(metadata.get("PhoneNumber")) if metadata.get("PhoneNumber") else None

            logger.info(f"💰 Subscription callback metadata: amount={amount}, receipt={receipt}, account_reference={account_reference}, phone={phone}")

            # Helper function to find user by phone with multiple formats
            def find_user_by_phone(phone_str):
                if not phone_str:
                    return None

                phone_variants = [phone_str]

                # Generate all possible phone number formats
                if phone_str.startswith('+254'):
                    phone_variants.extend([
                        phone_str[4:],           # 722714334
                        '0' + phone_str[4:],     # 0722714334
                        phone_str[1:],           # 254722714334
                    ])
                elif phone_str.startswith('254'):
                    phone_variants.extend([
                        '+' + phone_str,         # +254722714334
                        '0' + phone_str[3:],     # 0722714334
                        phone_str[3:],           # 722714334
                    ])
                elif phone_str.startswith('0'):
                    phone_variants.extend([
                        '+254' + phone_str[1:],  # +254722714334
                        '254' + phone_str[1:],   # 254722714334
                        phone_str[1:],           # 722714334
                    ])
                else:
                    # Assume it's local without 0, add variants
                    phone_variants.extend([
                        '+254' + phone_str,      # +254722714334
                        '254' + phone_str,       # 254722714334
                        '0' + phone_str,         # 0722714334
                    ])

                # Remove duplicates
                phone_variants = list(set(phone_variants))
                logger.info(f"🔍 Searching for user with phone variants: {phone_variants}")
                return CustomUser.objects.filter(
                    user_type='landlord',
                    phone_number__in=phone_variants
                ).first()

            # Find user by phone number
            user = find_user_by_phone(phone)
            if not user:
                logger.error(f"❌ No landlord found with phone number: {phone}")
                # Still acknowledge callback but log error
            else:
                logger.info(f"✅ Found user: {user.email} for phone: {phone}")

                # Determine subscription type from amount
                subscription_type = None
                if amount == Decimal('50'):
                    subscription_type = 'starter'
                elif amount == Decimal('100'):
                    subscription_type = 'basic'
                elif amount == Decimal('200'):
                    subscription_type = 'professional'
                elif amount == Decimal('500'):
                    subscription_type = 'onetime'
                else:
                    logger.warning(f"⚠️ Unknown subscription amount: {amount}, cannot determine plan")

                if subscription_type:
                    # Handle duplicate receipts gracefully
                    try:
                        subscription_payment, created = SubscriptionPayment.objects.get_or_create(
                            mpesa_receipt_number=receipt,
                            defaults={
                                'user': user,
                                'amount': amount,
                                'subscription_type': subscription_type,
                            }
                        )

                        if created:
                            logger.info(f"✅ Created new subscription payment: {subscription_payment.id}")
                        else:
                            logger.warning(f"⚠️ Subscription payment with receipt {receipt} already exists, skipping duplicate")

                        # Update or create subscription
                        subscription, sub_created = Subscription.objects.get_or_create(
                            user=user,
                            defaults={
                                'plan': subscription_type,
                                'expiry_date': timezone.now() + timedelta(days=30) if subscription_type != 'onetime' else None
                            }
                        )

                        if not sub_created:
                            # Update existing subscription
                            subscription.plan = subscription_type
                            if subscription_type == 'onetime':
                                subscription.expiry_date = None  # Lifetime
                            else:
                                subscription.expiry_date = timezone.now() + timedelta(days=30)
                            subscription.save()
                            logger.info(f"✅ Updated subscription for user {user.email} to {subscription_type}")
                        else:
                            logger.info(f"✅ Created new subscription for user {user.email}: {subscription_type}")

                        # Invalidate relevant caches
                        cache.delete_many([
                            f"subscription_payments:{user.id}",
                            f"rent_summary:{user.id}",
                        ])
                        logger.info(f"🗑️ Cache invalidated for subscription payment")

                    except Exception as e:
                        logger.error(f"❌ Error processing subscription payment: {e}")
                else:
                    logger.error(f"❌ Could not determine subscription type for amount: {amount}")
        else:
            # Transaction failed
            error_msg = body.get("ResultDesc", "Unknown error")
            logger.error(f"❌ Subscription transaction failed: {error_msg} (ResultCode: {result_code})")

    except json.JSONDecodeError as e:
        logger.error(f"❌ Invalid JSON in subscription callback: {e}")
    except Exception as e:
        logger.error("❌ Unexpected error processing subscription callback:", exc_info=True)

    # CRITICAL: Always respond with success to Safaricom to acknowledge callback receipt
    logger.info("✅ Responding with success to M-Pesa subscription callback")
    return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})
# ------------------------------
# RENT PAYMENTS (DRF Views) - CACHED
# ------------------------------
class PaymentListCreateView(generics.ListCreateAPIView):
    """
    GET:
    - Tenants: only see their own rent payments (cached)
    - Landlords: see all rent payments for units in their properties (cached)
    POST:
    - Only tenants can create a new rent payment
    """
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]
    def get_queryset(self):
       user = self.request.user
       cache_key = f"payments:{user.user_type}:{user.id}"
       # Try to get cached data
       cached_data = cache.get(cache_key)
       if cached_data:
           # Return a queryset-like object (we'll handle this in the serializer)
           return Payment.objects.none()  # Serializer will use cached data
       # If not cached, fetch from database
       if user.user_type == "tenant":
           queryset = Payment.objects.filter(tenant=user).order_by('-transaction_date')
       elif user.user_type == "landlord":
           queryset = Payment.objects.filter(
               unit__property_obj__landlord=user).order_by('-transaction_date')
       else:
           queryset = Payment.objects.none()
       # Cache the results for 5 minutes
       if queryset.exists():
           cache.set(cache_key, PaymentSerializer(queryset, many=True).data, timeout=300)
       return queryset
    def list(self, request, *args, **kwargs):
       # Custom list method to handle cached data
       user = self.request.user
       cache_key = f"payments:{user.user_type}:{user.id}"
       cached_data = cache.get(cache_key)
       if cached_data:
           return Response(cached_data)
       return super().list(request, *args, **kwargs)
    def perform_create(self, serializer):
       if self.request.user.user_type == "tenant":
           payment = serializer.save(tenant=self.request.user)
           # Invalidate cache after creation
           cache.delete(f"payments:tenant:{self.request.user.id}")
           cache.delete(f"payments:landlord:{payment.unit.property_obj.landlord.id}")
       else:
           raise PermissionError("Only tenants can create rent payments.")
class PaymentDetailView(generics.RetrieveAPIView):
    """
    GET:
    - Tenants: can only view their own payment details (cached)
    - Landlords: can view payment details for units in their properties (cached)
    """
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == "tenant":
            return Payment.objects.filter(tenant=user)
        elif user.user_type == "landlord":
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()

    def retrieve(self, request, *args, **kwargs):
        payment_id = kwargs.get('pk')
        cache_key = f"payment:{payment_id}:details"
        cached_data = cache.get(cache_key)
        if cached_data:
            return Response(cached_data)
        response = super().retrieve(request, *args, **kwargs)
        cache.set(cache_key, response.data, timeout=300)
        return response

# ------------------------------
# SUBSCRIPTION PAYMENTS (DRF Views) - CACHED
# ------------------------------
class SubscriptionPaymentListCreateView(generics.ListCreateAPIView):
    """
    GET:
    - Landlords: only see their own subscription payments (cached)
    - Tenants: no access
    POST:
    - Only landlords can create subscription payments
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == "landlord":
            return SubscriptionPayment.objects.filter(user=user).order_by('-transaction_date')
        return SubscriptionPayment.objects.none()

    def list(self, request, *args, **kwargs):
        user = self.request.user
        if user.user_type != "landlord":
            return Response({"error": "Only landlords can view subscription payments."}, status=403)
        cache_key = f"subscription_payments:{user.id}"
        cached_data = cache.get(cache_key)
        if cached_data:
            return Response(cached_data)
        response = super().list(request, *args, **kwargs)
        cache.set(cache_key, response.data, timeout=300)
        return response

    def perform_create(self, serializer):
        if self.request.user.user_type == "landlord":
            serializer.save(user=self.request.user)
            # Invalidate cache after creation
            cache.delete(f"subscription_payments:{self.request.user.id}")
        else:
            raise PermissionError("Only landlords can make subscription payments.")
class SubscriptionPaymentDetailView(generics.RetrieveAPIView):
    """
    GET:
    - Landlords: can only view their own subscription payment details (cached)
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == "landlord":
            return SubscriptionPayment.objects.filter(user=user)
        return SubscriptionPayment.objects.none()

    def retrieve(self, request, *args, **kwargs):
        payment_id = kwargs.get('pk')
        cache_key = f"subscription_payment:{payment_id}:details"
        cached_data = cache.get(cache_key)
        if cached_data:
            return Response(cached_data)
        response = super().retrieve(request, *args, **kwargs)
        cache.set(cache_key, response.data, timeout=300)
        return response

class RentSummaryView(APIView):
    """
    Provides a financial summary for landlords (cached):
    - Total rent collected across all their properties
    - Total outstanding rent
    - Per-unit breakdown (unit number, tenant, paid, remaining)
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        if user.user_type != "landlord":
            return Response({"error": "Only landlords can view rent summaries."}, status=403)
        # Check cache first
        cache_key = f"rent_summary:{user.id}"
        cached_summary = cache.get(cache_key)
        if cached_summary:
            return Response(cached_summary)
        # Get all units owned by this landlord
        units = Unit.objects.filter(property_obj__landlord=user)
        total_collected = 0
        total_outstanding = 0
        unit_breakdown = []
        for unit in units:
            collected = float(unit.rent_paid)
            outstanding = float(unit.rent_remaining)
            total_collected += collected
            total_outstanding += outstanding
            unit_breakdown.append({
                "unit_number": unit.unit_number,
                "tenant": unit.tenant.email if unit.tenant else None,
                "rent": float(unit.rent),
                "rent_paid": collected,
                "rent_remaining": outstanding,
                "is_available": unit.is_available,
            })
        summary = {
            "landlord": user.email,
            "total_collected": total_collected,
            "total_outstanding": total_outstanding,
            "units": unit_breakdown,
            "last_updated": timezone.now().isoformat(),
        }
        # Cache for 10 minutes
        cache.set(cache_key, summary, timeout=600)
        return Response(summary)
# ------------------------------
# GENERATE RENT PAYMENTS CSV REPORT
# ------------------------------
class LandLordCSVView(APIView):
    """
    Generate CSV report for landlord with Redis caching for frequent requests
    """
    permission_classes = [IsAuthenticated, HasActiveSubscription]

    def get(self, request, property_id):
        cache_key = f"landlord_csv:{property_id}:{request.user.id}"
        cached_response = cache.get(cache_key)
        if cached_response:
            response = HttpResponse(cached_response, content_type='text/csv')
            response['Content-Disposition'] = 'attachment; filename="landlord_data.csv"'
            return response
        property = get_object_or_404(Property, pk=property_id)
        # Verify the property belongs to the logged-in landlord
        if property.landlord != request.user:
            return HttpResponse("Unauthorized", status=403)
        units = property.unit_list.all()
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="landlord_data.csv"'
        writer = csv.writer(response)
        writer.writerow(['Tenant', 'Unit Number', 'Floor', 'Bedrooms', 'Bathrooms', 'Rent',
                         'Rent Paid', 'Rent Remaining', 'Rent Due Date', 'Deposit', 'Is Available'])
        for unit in units:
            writer.writerow([
                unit.tenant.email if unit.tenant else 'Vacant',
                unit.unit_number,
                unit.floor,
                unit.bedrooms,
                unit.bathrooms,
                unit.rent,
                unit.rent_paid,
                unit.rent_remaining,  # Fixed: was unit.balance
                unit.rent_due_date,
                unit.deposit,
                unit.is_available
            ])
        # Cache the CSV content for 5 minutes (for frequent downloads)
        cache.set(cache_key, response.content, timeout=300)
        return response
class TenantCSVView(APIView):
    """
    Generate CSV report for tenant with Redis caching
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, unit_id):
        cache_key = f"tenant_csv:{unit_id}:{request.user.id}"
        cached_response = cache.get(cache_key)
        if cached_response:
            response = HttpResponse(cached_response, content_type='text/csv')
            response['Content-Disposition'] = 'attachment; filename="tenant_data.csv"'
            return response
        unit = get_object_or_404(Unit, pk=unit_id)
        # Verify the unit belongs to the logged-in tenant
        if unit.tenant != request.user:
            return HttpResponse("Unauthorized", status=403)
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="tenant_data.csv"'
        writer = csv.writer(response)
        writer.writerow(['Property', 'Unit Number', 'Floor', 'Bedrooms', 'Bathrooms',
                         'Rent', 'Rent Paid', 'Rent Remaining', 'Rent Due Date', 'Deposit'])
        writer.writerow([
            unit.property_obj.name,
            unit.unit_number,
            unit.floor,
            unit.bedrooms,
            unit.bathrooms,
            unit.rent,
            unit.rent_paid,
            unit.rent_remaining,  # Fixed: was unit.balance
            unit.rent_due_date,
            unit.deposit
        ])
        # Cache the CSV content for 5 minutes
        cache.set(cache_key, response.content, timeout=300)
        return response
# ------------------------------
# UNIT TYPES LIST (For Tenants to Choose Room Types)
# ------------------------------
class UnitTypeListView(APIView):
    def get(self, request):
        landlord_code = request.query_params.get('landlord_code')
        if landlord_code:
            try:
                landlord = CustomUser.objects.get(
                    landlord_code=landlord_code, user_type='landlord')
                unit_types = UnitType.objects.filter(landlord=landlord)
            except CustomUser.DoesNotExist:
                return Response({'error': 'Invalid landlord code'}, status=400)
        else:
            unit_types = UnitType.objects.all()
        serializer = UnitTypeSerializer(unit_types, many=True)
        return Response(serializer.data)
# ------------------------------
# INITIATE DEPOSIT PAYMENT
# ------------------------------
class InitiateDepositPaymentView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        unit_id = request.data.get('unit_id')
        if not unit_id:
            return Response({'error': 'unit_id is required'}, status=400)
        
        try:
            # Only allow deposit payment for available units
            unit = Unit.objects.get(id=unit_id, is_available=True)
        except Unit.DoesNotExist:
            return Response({'error': 'Unit not found or not available for deposit payment'}, status=400)

        amount = unit.deposit
        
        # Validate amount
        if amount is None or amount <= 0:
            return Response({"error": "Deposit amount is not set or invalid."}, status=400)
        
        # Ensure amount is a whole number (M-Pesa requires integer amounts)
        if not (amount % 1 == 0):
            return Response({"error": "Deposit amount must be a whole number."}, status=400)
        
        # Convert to integer for M-Pesa
        amount = int(amount)
        
        # Rate limiting
        rate_limit_key = f"deposit_stk_push_rate_limit:{request.user.id}"
        recent_requests = cache.get(rate_limit_key, 0)
        if recent_requests >= 5:
            return Response({"error": "Too many requests. Please try again later."}, status=429)
        
        cache.set(rate_limit_key, recent_requests + 1, timeout=60)
        
        # Check for duplicate pending payment
        duplicate_key = f"pending_deposit_payment:{request.user.id}:{unit_id}"
        if cache.get(duplicate_key):
            return Response({"error": "A deposit payment request is already pending for this unit."}, status=400)
        
        # Create a pending payment record
        payment = Payment.objects.create(
            tenant=request.user,
            unit=unit,
            payment_type='deposit',
            amount=amount,
            status="Pending"
        )
        
        # Mark payment as pending in Redis (5-minute expiry)
        cache.set(duplicate_key, payment.id, timeout=300)
        
        try:
            # Generate access token
            access_token_cache_key = "mpesa_access_token"
            access_token = cache.get(access_token_cache_key)
            if not access_token:
                access_token = generate_access_token()
            cache.set(access_token_cache_key, access_token, timeout=3300)
        except Exception as e:
            return Response({"error": f"Payment initiation failed: {str(e)}"}, status=400)
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        password = base64.b64encode(
            (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode("utf-8")
        ).decode("utf-8")
        
        business_shortcode = settings.MPESA_SHORTCODE

        # Normalize phone number for M-Pesa (remove + if present)
        phone_number = request.user.phone_number
        if phone_number.startswith('+'):
            phone_number = phone_number[1:]

        # Build payload for Safaricom API
        payload = {
            "BusinessShortCode": business_shortcode,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": str(payment.amount),
            "PartyA": phone_number,
            "PartyB": business_shortcode,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_DEPOSIT_CALLBACK_URL,
            "AccountReference": str(payment.id),
            "TransactionDesc": f"Deposit for Unit {unit.unit_number}"
        }
        
        headers = {"Authorization": f"Bearer {access_token}"}
        
        try:
            response = requests.post(
                "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest",
                json=payload,
                headers=headers,
                timeout=30
            )
            response_data = response.json()
            
            if response_data.get("ResponseCode") == "0":
                return Response({
                    "message": "Deposit payment initiated successfully. Please check your phone to complete payment.",
                    "checkout_request_id": response_data.get("CheckoutRequestID"),
                    "payment_id": payment.id
                })
            else:
                # STK push failed - mark payment as failed immediately
                payment.status = "Failed"
                payment.save()
                cache.delete(duplicate_key)
                return Response({
                    "error": "Payment initiation failed: {}".format(
                        response_data.get("ResponseDescription", "Unknown error")
                    )
                }, status=400)
                
        except requests.exceptions.RequestException as e:
            # Network error - mark payment as failed
            payment.status = "Failed"
            payment.save()
            cache.delete(duplicate_key)
            return Response({"error": "Payment service temporarily unavailable. Please try again later."}, status=503)
# ------------------------------
# TRIGGER DEPOSIT CALLBACK (FOR TESTING)
# ------------------------------
class TriggerDepositCallbackView(APIView):
    """
    Manual endpoint to trigger deposit callback for testing.
    Accepts payment_id as query parameter.
    """
    permission_classes = [IsAuthenticated]  # Allow authenticated users for testing

    def post(self, request):
        from django.http import HttpRequest
        import json
        import logging

        logger = logging.getLogger(__name__)

        payment_id = request.query_params.get('payment_id')
        if not payment_id:
            return Response({"error": "payment_id query parameter required"}, status=400)

        try:
            payment = Payment.objects.get(id=payment_id, payment_type='deposit')
        except Payment.DoesNotExist:
            return Response({"error": f"Deposit payment with id {payment_id} not found"}, status=404)

        # Create mock callback data
        mock_callback_data = {
            "Body": {
                "stkCallback": {
                    "MerchantRequestID": "mock-request-id",
                    "CheckoutRequestID": "mock-checkout-id",
                    "ResultCode": 0,
                    "ResultDesc": "The service request is processed successfully.",
                    "CallbackMetadata": {
                        "Item": [
                            {"Name": "Amount", "Value": str(payment.amount)},
                            {"Name": "MpesaReceiptNumber", "Value": f"TEST{payment_id}"},
                            {"Name": "TransactionDate", "Value": "20231201120000"},
                            {"Name": "PhoneNumber", "Value": payment.tenant.phone_number},
                            {"Name": "AccountReference", "Value": str(payment.id)}
                        ]
                    }
                }
            }
        }

        # Simulate the callback by calling the actual callback function
        mock_request = HttpRequest()
        mock_request.method = 'POST'
        mock_request._body = json.dumps(mock_callback_data).encode('utf-8')

        logger.info(f"🔧 Manually triggering deposit callback for payment {payment_id}")
        response = mpesa_deposit_callback(mock_request)

        return Response({
            "message": f"Deposit callback triggered for payment {payment_id}",
            "mock_data": mock_callback_data,
            "callback_response": response.content.decode('utf-8')
        })

# ------------------------------
# B2C PAYMENT CALLBACK
# ------------------------------
@csrf_exempt
def mpesa_b2c_callback(request):
    """
    Handles M-Pesa callback for B2C disbursements.
    - Logs the result of the disbursement
    - Could update payment records if needed
    """
    try:
        data = json.loads(request.body.decode("utf-8"))
        result = data.get("Result", {})
        result_code = result.get("ResultCode")
        result_desc = result.get("ResultDesc")
        if result_code == 0:  # ✅ Disbursement successful
            print(f"✅ B2C disbursement successful: {result_desc}")
        else:
            print(f"❌ B2C disbursement failed: {result_desc}")
    except Exception as e:
        print("Error processing B2C callback:", e)
    # Always respond with success to Safaricom
    return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

# ------------------------------
# DEPOSIT PAYMENT CALLBACK
# ------------------------------
@csrf_exempt
def mpesa_deposit_callback(request):
    """
    Handles M-Pesa callback for deposit payments.
    ✅ Automatically confirms deposits and assigns tenant to unit
    ✅ No timeout restriction (safe for delayed callbacks)
    ✅ Always acknowledges Safaricom callback with success
    """
    import logging
    from decimal import Decimal
    from django.utils import timezone
    import json

    logger = logging.getLogger(__name__)
    logger.info("🔄 Deposit callback received")

    try:
        # --- Parse callback data ---
        data = json.loads(request.body.decode("utf-8"))
        logger.info(f"📥 Deposit callback payload: {json.dumps(data, indent=2)}")

        body = data.get("Body", {}).get("stkCallback", {})
        result_code = body.get("ResultCode")
        logger.info(f"🔍 Deposit callback result code: {result_code}")

        if result_code == 0:  # ✅ Transaction successful
            metadata_items = body.get("CallbackMetadata", {}).get("Item", [])
            metadata = {item["Name"]: item.get("Value") for item in metadata_items}
            logger.info(f"🔧 Parsed metadata: {metadata}")

            # Extract values
            amount_str = metadata.get("Amount")
            receipt = metadata.get("MpesaReceiptNumber")
            payment_id = metadata.get("AccountReference")
            phone = str(metadata.get("PhoneNumber")) if metadata.get("PhoneNumber") else None

            # Convert amount safely
            try:
                amount = Decimal(amount_str)
            except Exception:
                amount = Decimal('0')
            logger.info(f"💰 Amount={amount}, Receipt={receipt}, PaymentID={payment_id}, Phone={phone}")

            # --- Update the payment record ---
            if not payment_id:
                logger.error("❌ Missing AccountReference (payment_id) in callback.")
                return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

            try:
                payment = Payment.objects.get(id=payment_id, payment_type="deposit")
            except Payment.DoesNotExist:
                logger.error(f"❌ Payment with id {payment_id} not found.")
                return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

            # Update payment status
            payment.status = "Success"
            payment.mpesa_receipt = receipt
            payment.transaction_date = timezone.now()
            payment.save()
            logger.info(f"✅ Payment {payment.id} marked as Success")

            # --- Assign tenant automatically ---
            unit = payment.unit
            if unit.is_available or not unit.tenant:
                unit.tenant = payment.tenant
                unit.is_available = False
                unit.save()
                logger.info(f"🏠 Tenant {payment.tenant.email} assigned to unit {unit.unit_number}")
            else:
                logger.warning(f"⚠️ Unit {unit.unit_number} already occupied. Skipping assignment.")

            # --- Invalidate caches ---
            cache.delete_many([
                f"pending_deposit_payment:{payment.tenant.id}:{unit.id}",
                f"payments:tenant:{payment.tenant.id}",
                f"payments:landlord:{unit.property_obj.landlord.id}",
                f"rent_summary:{unit.property_obj.landlord.id}",
                f"unit:{unit.id}:details",
                f"property:{unit.property_obj.id}:units"
            ])
            logger.info(f"🗑️ Cache cleared for payment {payment.id}")

        else:
            # ❌ Transaction failed
            error_msg = body.get("ResultDesc", "Unknown error")
            payment_id = body.get("AccountReference")
            logger.error(f"❌ Deposit transaction failed: {error_msg} (Payment ID: {payment_id})")

            if payment_id:
                try:
                    payment = Payment.objects.get(id=payment_id, payment_type="deposit")
                    payment.status = "Failed"
                    payment.save()
                    cache.delete_many([
                        f"pending_deposit_payment:{payment.tenant.id}:{payment.unit.id}",
                        f"payments:tenant:{payment.tenant.id}",
                        f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                    ])
                    logger.info(f"✅ Marked payment {payment_id} as Failed")
                except Payment.DoesNotExist:
                    logger.error(f"Payment {payment_id} not found for failure update")

    except json.JSONDecodeError as e:
        logger.error(f"❌ Invalid JSON in deposit callback: {e}")
    except Exception as e:
        logger.exception("❌ Unexpected error in deposit callback")

    # --- Always respond success to Safaricom ---
    logger.info("✅ Acknowledging M-Pesa callback with success")
    return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

# ------------------------------
# DEPOSIT PAYMENT STATUS VIEW
# ------------------------------
class DepositPaymentStatusView(APIView):
    """
    Allows tenants to check the status of their deposit payment.
    Includes automatic timeout detection (10 minutes).
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, payment_id):
        try:
            payment = Payment.objects.get(
                id=payment_id,
                tenant=request.user,
                payment_type='deposit'
            )
        except Payment.DoesNotExist:
            return Response({"error": "Deposit payment not found"}, status=404)

        # Check for timeout (10 minutes)
        if payment.status == "Pending":
            time_elapsed = timezone.now() - payment.transaction_date
            if time_elapsed.total_seconds() > 600:  # 10 minutes
                payment.status = "Failed"
                payment.save()
                logger.warning(f"Payment {payment.id} timed out after 10 minutes")

                # Invalidate caches
                cache.delete_many([
                    f"pending_deposit_payment:{payment.tenant.id}:{payment.unit.id}",
                    f"payments:tenant:{payment.tenant.id}",
                    f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                ])

        return Response({
            "payment_id": payment.id,
            "status": payment.status,
            "amount": payment.amount,
            "unit_number": payment.unit.unit_number,
            "transaction_date": payment.transaction_date,
            "mpesa_receipt": payment.mpesa_receipt
        })

# ------------------------------
# CLEANUP PENDING PAYMENTS VIEW
# ------------------------------
class CleanupPendingPaymentsView(APIView):
    """
    Admin endpoint to cleanup pending payments older than 10 minutes.
    Marks them as Failed and invalidates relevant caches.
    """
    permission_classes = [IsAuthenticated]  # TODO: Add admin permission

    def post(self, request):
        # Add logger import at the top of the function
        logger = logging.getLogger(__name__)

        # Find all pending payments older than 10 minutes
        cutoff_time = timezone.now() - timedelta(minutes=10)
        pending_payments = Payment.objects.filter(
            status="Pending",
            transaction_date__lt=cutoff_time
        )

        cleaned_count = 0
        for payment in pending_payments:
            payment.status = "Failed"
            payment.save()
            cleaned_count += 1

            # Invalidate relevant caches
            if payment.payment_type == 'deposit':
                cache.delete_many([
                    f"pending_deposit_payment:{payment.tenant.id}:{payment.unit.id}",
                    f"payments:tenant:{payment.tenant.id}",
                    f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                ])
            else:  # rent payment
                cache.delete_many([
                    f"pending_payment:{payment.tenant.id}:{payment.unit.id}",
                    f"payments:tenant:{payment.tenant.id}",
                    f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                ])

        logger.info(f"Cleaned up {cleaned_count} pending payments older than 10 minutes")

        return Response({
            "message": f"Cleaned up {cleaned_count} pending payments",
            "cutoff_time": cutoff_time.isoformat()
        })

# ------------------------------
# SIMULATE DEPOSIT CALLBACK VIEW
# ------------------------------
class SimulateDepositCallbackView(APIView):
    """
    Endpoint to simulate deposit callback for testing purposes.
    Accepts payment_id as query parameter and simulates success/failure.
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        payment_id = request.query_params.get('payment_id')
        if not payment_id:
            return Response({"error": "payment_id query parameter required"}, status=400)

        try:
            payment = Payment.objects.get(id=payment_id, payment_type='deposit')
        except Payment.DoesNotExist:
            return Response({"error": f"Deposit payment with id {payment_id} not found"}, status=404)

        # Check if callback is within timeout (10 minutes)
        time_elapsed = timezone.now() - payment.transaction_date
        if time_elapsed.total_seconds() > 600:  # 10 minutes
            return Response({"error": "Payment has timed out (10 minutes)"}, status=400)

        # Simulate successful callback
        mock_callback_data = {
            "Body": {
                "stkCallback": {
                    "MerchantRequestID": "mock-request-id",
                    "CheckoutRequestID": "mock-checkout-id",
                    "ResultCode": 0,
                    "ResultDesc": "The service request is processed successfully.",
                    "CallbackMetadata": {
                        "Item": [
                            {"Name": "Amount", "Value": str(payment.amount)},
                            {"Name": "MpesaReceiptNumber", "Value": f"SIM{payment_id}"},
                            {"Name": "TransactionDate", "Value": timezone.now().strftime("%Y%m%d%H%M%S")},
                            {"Name": "PhoneNumber", "Value": payment.tenant.phone_number},
                            {"Name": "AccountReference", "Value": str(payment.id)}
                        ]
                    }
                }
            }
        }

        # Create mock request to call the actual callback function
        from django.http import HttpRequest
        mock_request = HttpRequest()
        mock_request.method = 'POST'
        mock_request._body = json.dumps(mock_callback_data).encode('utf-8')

        logger.info(f"🔧 Simulating deposit callback for payment {payment_id}")
        response = mpesa_deposit_callback(mock_request)

        return Response({
            "message": f"Deposit callback simulated for payment {payment_id}",
            "mock_data": mock_callback_data,
            "callback_response": response.content.decode('utf-8')
        })
from rest_framework import generics, permissions
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Report
from .serializers import ReportSerializer, UpdateReportStatusSerializer, SendEmailSerializer
from .permissions import IsTenantWithUnit, IsLandlordWithActiveSubscription
from accounts.permissions import CanAccessReport
from accounts.models import CustomUser, Unit
from .messaging import send_landlord_email

class CreateReportView(generics.CreateAPIView):
    queryset = Report.objects.all()
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated, IsTenantWithUnit]

    def perform_create(self, serializer):
        report = serializer.save()
        # Import here to avoid circular imports
        from app.tasks import send_report_email_task
        send_report_email_task.delay(report.id)

class OpenReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user

        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='open')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='open')
        return Report.objects.none()

class UrgentReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, priority_level='urgent')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, priority_level='urgent')
        return Report.objects.none()

class InProgressReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='in_progress')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='in_progress')
        return Report.objects.none()

class ResolvedReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='resolved')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='resolved')
        return Report.objects.none()

class UpdateReportStatusView(generics.UpdateAPIView):
    queryset = Report.objects.all()
    serializer_class = UpdateReportStatusSerializer
    permission_classes = [permissions.IsAuthenticated, CanAccessReport]

class SendEmailView(APIView):
    permission_classes = [permissions.IsAuthenticated, IsLandlordWithActiveSubscription]

    def post(self, request):
        serializer = SendEmailSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            subject = serializer.validated_data['subject']
            message = serializer.validated_data['message']
            send_to_all = serializer.validated_data['send_to_all']

            if send_to_all:
                # Get all tenants of the landlord
                landlord_properties = request.user.property_set.all()
                tenants = CustomUser.objects.filter(
                    user_type='tenant',
                    unit__property_obj__in=landlord_properties
                ).distinct()
            else:
                tenants = serializer.validated_data['tenants']

            send_landlord_email(subject, message, tenants)
            return Response({"message": "Emails sent successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from rest_framework.routers import DefaultRouter
from . import views
from django.urls import path
from .views import (UserDetailView, UserListView, UserCreateView, PasswordResetView,
                    CreatePropertyView, LandlordPropertiesView, CreateUnitView,
                    UpdatePropertyView,UpdateUnitView,UpdateUserView, SubscriptionStatusView,
                    UpdateTillNumberView, MyTokenObtainPairView, AdminLandlordSubscriptionStatusView,
                    MeView, PasswordResetConfirmView, UnitTypeListCreateView, UnitTypeDetailView,
                    LandlordDashboardStatsView, TenantUpdateUnitView, AdjustRentView,
                    PropertyUnitsView, AssignTenantView, UpdateReminderPreferencesView,
                    LandlordAvailableUnitsView,
)

router = DefaultRouter()
# Remove or comment these out if you're not using ViewSets
# router.register('properties', views.PropertyViewSet, basename='property')
# router.register('units', views.UnitViewSet, basename='unit')
# router.register('users', views.UserViewSet, basename='user')

urlpatterns = [
    # Authentication endpoints
    path("signup/", UserCreateView.as_view(), name="signup"),
    path('token/', MyTokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    
    # User endpoints
    path("users/<int:user_id>/", UserDetailView.as_view(), name="user-detail"),
    path("users/", UserListView.as_view(), name="user-list"),
    path('users/<int:user_id>/update/', UpdateUserView.as_view(), name='user-update'),
    path('me/', MeView.as_view(), name='me'),
    
    # Password reset
    path('password-reset/', PasswordResetView.as_view(), name='password-reset'),
    path('password-reset-confirm/', PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    
    # Property endpoints - FIXED URL NAMES
    path('properties/create/', CreatePropertyView.as_view(), name='property-create'),  # Changed from 'create-property'
    path('properties/', LandlordPropertiesView.as_view(), name='property-list'),  # Changed from 'landlord-properties'
    path('properties/<int:property_id>/update/', UpdatePropertyView.as_view(), name='property-update'),
    path('properties/<int:property_id>/units/', PropertyUnitsView.as_view(), name='property-units'),
    
    # Unit endpoints - FIXED URL NAMES
    path('units/create/', CreateUnitView.as_view(), name='unit-create'),  # Changed from 'create-unit'
    path('units/<int:unit_id>/update/', UpdateUnitView.as_view(), name='unit-update'),
    path('units/tenant/update/', TenantUpdateUnitView.as_view(), name='tenant-unit-update'),
    path('units/<int:unit_id>/assign/<int:tenant_id>/', AssignTenantView.as_view(), name='assign-tenant'),  # Changed from 'assign-tenant-to-unit'
    
    # UnitType endpoints
    path('unit-types/', UnitTypeListCreateView.as_view(), name='unit-types'),  # Changed from 'unittype-list-create'
    path('unit-types/<int:pk>/', UnitTypeDetailView.as_view(), name='unit-type-detail'),  # Changed from 'unittype-detail'
    
    # Subscription endpoints
    path('subscription-status/', SubscriptionStatusView.as_view(), name='subscription-status'),
    path('update-till-number/', UpdateTillNumberView.as_view(), name='update-till-number'),
    path('admin/landlord-subscriptions/', AdminLandlordSubscriptionStatusView.as_view(), name='admin-landlord-subscriptions'),
    path('dashboard-stats/', LandlordDashboardStatsView.as_view(), name='dashboard-stats'),
    path('adjust-rent/', AdjustRentView.as_view(), name='adjust-rent'),
    
    # Other endpoints
    path('update-reminder-preferences/', UpdateReminderPreferencesView.as_view(), name='update-reminder-preferences'),
    path('available-units/', LandlordAvailableUnitsView.as_view(), name='available-units'),  # Changed from 'landlord-available-units'
]
from django.urls import path
from .views import (
    # STK Push + Callbacks
    stk_push,
    stk_push_subscription,
    mpesa_rent_callback,
    mpesa_subscription_callback,
    mpesa_b2c_callback,
    mpesa_deposit_callback,

    # DRF views
    PaymentListCreateView,
    PaymentDetailView,
    SubscriptionPaymentListCreateView,
    SubscriptionPaymentDetailView,
    RentSummaryView,
    UnitTypeListView,
    InitiateDepositPaymentView,
    TriggerDepositCallbackView,
    DepositPaymentStatusView,
    CleanupPendingPaymentsView,
    SimulateDepositCallbackView,

    # CSV reports
    LandLordCSVView as landlord_csv,
    TenantCSVView as tenant_csv,
)
from django.views.decorators.csrf import csrf_exempt

urlpatterns = [
    # ------------------------------
    # M-PESA STK PUSH + CALLBACKS
    # ------------------------------
    path("stk-push/<int:unit_id>/", stk_push, name="stk-push"),
    path("stk-push-subscription/", stk_push_subscription, name="stk-push-subscription"),
    path("callback/rent/", mpesa_rent_callback, name="mpesa-rent-callback"),
    path("callback/subscription/", mpesa_subscription_callback, name="mpesa-subscription-callback"),
    path("callback/b2c/", mpesa_b2c_callback, name="mpesa-b2c-callback"),
    path("callback/deposit/", mpesa_deposit_callback, name="mpesa-deposit-callback"),

    # ------------------------------
    # MANUAL CALLBACK TRIGGER (FOR TESTING)
    # ------------------------------
    path("trigger-deposit-callback/", TriggerDepositCallbackView.as_view(), name="trigger-deposit-callback"),

    # ------------------------------
    # RENT PAYMENTS (DRF)
    # ------------------------------
    path("rent-payments/", PaymentListCreateView.as_view(), name="rent-payment-list-create"),
    path("rent-payments/<int:pk>/", PaymentDetailView.as_view(), name="rent-payment-detail"),

    # ------------------------------
    # SUBSCRIPTION PAYMENTS (DRF)
    # ------------------------------
    path("subscription-payments/", SubscriptionPaymentListCreateView.as_view(), name="subscription-payment-list-create"),
    path("subscription-payments/<int:pk>/", SubscriptionPaymentDetailView.as_view(), name="subscription-payment-detail"),
    path("rent-payments/summary/", RentSummaryView.as_view(), name="rent-summary"),

    # ------------------------------
    # UNIT TYPES
    # ------------------------------
    path("unit-types/", UnitTypeListView.as_view(), name="unit-types"),

    # ------------------------------
    # INITIATE DEPOSIT PAYMENT
    # ------------------------------
    path("initiate-deposit/", InitiateDepositPaymentView.as_view(), name="initiate-deposit"),
    path('deposit-status/<int:payment_id>/', DepositPaymentStatusView.as_view(), name='deposit-status'),
    # ------------------------------
    # CSV REPORTS
    # ------------------------------
    path("landlord-csv/<int:property_id>/", landlord_csv.as_view(), name="landlord-csv"),
    path("tenant-csv/<int:unit_id>/", tenant_csv.as_view(), name="tenant-csv"),

    # ------------------------------
    # CLEANUP AND SIMULATION ENDPOINTS
    # ------------------------------
    path("cleanup-pending-payments/", CleanupPendingPaymentsView.as_view(), name="cleanup-pending-payments"),
    path("simulate-deposit-callback/", SimulateDepositCallbackView.as_view(), name="simulate-deposit-callback"),
]
from django.urls import path
from .views import (
    CreateReportView,
    OpenReportsView,
    UrgentReportsView,
    InProgressReportsView,
    ResolvedReportsView,
    UpdateReportStatusView,
    SendEmailView,
)

urlpatterns = [
    # Create a new report (POST)
    path('reports/create/', CreateReportView.as_view(), name='create-report'),  # Added /create/

    # List open reports for the authenticated user (GET)
    path('reports/open/', OpenReportsView.as_view(), name='open-reports'),

    # List urgent reports for the authenticated user (GET)
    path('reports/urgent/', UrgentReportsView.as_view(), name='urgent-reports'),

    # List in-progress reports for the authenticated user (GET)
    path('reports/in-progress/', InProgressReportsView.as_view(), name='in-progress-reports'),

    # List resolved reports for the authenticated user (GET)
    path('reports/resolved/', ResolvedReportsView.as_view(), name='resolved-reports'),

    # Update the status of a specific report (PATCH/PUT)
    path('reports/<int:pk>/update-status/', UpdateReportStatusView.as_view(), name='update-report-status'),

    # Send email to tenants (POST)
    path('reports/send-email/', SendEmailView.as_view(), name='send-email'),  # Added /reports/ prefix
]
#!/usr/bin/env pwsh
<#
.SYNOPSIS
    Makau Rentals - Real Life Application Workflow Demo
.DESCRIPTION
    This script demonstrates the complete workflow of the Makau Rentals application
    from landlord signup to tenant payments and maintenance reports using the live API.
    Now includes real M-Pesa integration with 1 KSH transactions.
.NOTES
    Author: Makau Rentals
    Date: $(Get-Date)
#>

# Configuration
$BaseUrl = "https://makau-rentals-backend.onrender.com"
$ApiUrl = "$BaseUrl/api"

# Colors for output
$Green = "Green"
$Yellow = "Yellow" 
$Red = "Red"
$Cyan = "Cyan"
$Magenta = "Magenta"

# Global variables to store created data
$Global:LandlordToken = $null
$Global:TenantToken = $null
$Global:LandlordId = $null
$Global:TenantId = $null
$Global:PropertyId = $null
$Global:UnitId = $null
$Global:UnitTypeId = $null
$Global:LandlordEmail = $null
$Global:TenantEmail = $null
$Global:LandlordCode = $null

function Write-ColorOutput {
    param(
        [string]$Message,
        [string]$Color = "White"
    )
    Write-Host $Message -ForegroundColor $Color
}

function Write-Section {
    param([string]$Title)
    Write-Host "`n" + "="*60 -ForegroundColor $Cyan
    Write-Host $Title -ForegroundColor $Cyan
    Write-Host "="*60 -ForegroundColor $Cyan
}

function Write-Step {
    param([string]$Step)
    Write-Host "`n>> $Step" -ForegroundColor $Yellow
}

function Invoke-ApiRequest {
    param(
        [string]$Endpoint,
        [string]$Method = "GET",
        [object]$Body = $null,
        [string]$Token = $null,
        [int]$TimeoutSec = 30
    )
    
    $headers = @{
        "Content-Type" = "application/json"
    }
    
    if ($Token) {
        $headers["Authorization"] = "Bearer $Token"
    }
    
    $uri = "$ApiUrl/$Endpoint"
    
    try {
        if ($Method -eq "GET") {
            $response = Invoke-RestMethod -Uri $uri -Method $Method -Headers $headers -TimeoutSec $TimeoutSec
        } else {
            $jsonBody = if ($Body) { $Body | ConvertTo-Json } else { "{}" }
            $response = Invoke-RestMethod -Uri $uri -Method $Method -Headers $headers -Body $jsonBody -TimeoutSec $TimeoutSec
        }
        
        return @{
            Success = $true
            Data = $response
        }
    }
    catch {
        $errorMessage = $_.Exception.Message
        $statusCode = $_.Exception.Response.StatusCode.value__
        
        try {
            if ($_.ErrorDetails.Message -and $_.ErrorDetails.Message -ne "") {
                $errorDetails = $_.ErrorDetails.Message | ConvertFrom-Json
                $errorMessage = $errorDetails.detail -or $errorDetails.error -or $errorDetails.message -or $errorMessage
            }
        }
        catch {
            # If we can't parse JSON error, use the original message
        }
        
        return @{
            Success = $false
            Error = $errorMessage
            StatusCode = $statusCode
        }
    }
}

function Test-ApiConnection {
    Write-Step "Testing API Connection"
    $response = Invoke-ApiRequest -Endpoint "accounts/me" -Method "GET"
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: API is accessible and responding" $Green
        return $true
    } else {
        if ($response.StatusCode -eq 401) {
            Write-ColorOutput "SUCCESS: API is accessible (unauthorized access expected)" $Green
            return $true
        } else {
            Write-ColorOutput "ERROR: API connection failed: $($response.Error)" $Red
            return $false
        }
    }
}

function Register-Landlord {
    Write-Section "PHASE 1: LANDLORD ONBOARDING"
    
    Write-Step "1. Registering Landlord Account"
    
    $timestamp = Get-Date -Format "yyyyMMddHHmmss"
    $Global:LandlordEmail = "demo_landlord_$timestamp@makau.com"
    $landlordData = @{
        email = $Global:LandlordEmail
        full_name = "Demo Landlord"
        user_type = "landlord"
        password = "DemoPass123!"
        phone_number = "+254722714334"  # Real phone number for M-Pesa testing
        government_id = "12345678"
    }
    
    $response = Invoke-ApiRequest -Endpoint "accounts/signup/" -Method "POST" -Body $landlordData
    
    if ($response.Success) {
        $Global:LandlordId = $response.Data.id
        Write-ColorOutput "SUCCESS: Landlord registered successfully:" $Green
        Write-ColorOutput "   Email: $($landlordData.email)" $Green
        Write-ColorOutput "   ID: $($response.Data.id)" $Green
        Write-ColorOutput "   Landlord Code: $($response.Data.landlord_code)" $Green
        Write-ColorOutput "   Phone: $($landlordData.phone_number)" $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Landlord registration failed: $($response.Error)" $Red
        return $false
    }
}

function Login-Landlord {
    Write-Step "2. Landlord Login"
    
    $loginData = @{
        email = $Global:LandlordEmail
        password = "DemoPass123!"
        user_type = "landlord"
    }
    
    $response = Invoke-ApiRequest -Endpoint "accounts/token/" -Method "POST" -Body $loginData
    
    if ($response.Success) {
        $Global:LandlordToken = $response.Data.access
        Write-ColorOutput "SUCCESS: Landlord logged in successfully" $Green
        Write-ColorOutput "   Token obtained: $($Global:LandlordToken.Substring(0, 20))..." $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Landlord login failed: $($response.Error)" $Red
        return $false
    }
}

function Create-UnitType {
    Write-Step "3. Creating Unit Type"
    
    # Using 1 KSH for demo payments
    $unitTypeData = @{
        name = "Demo Studio"
        deposit = 1.00  # 1 KSH for testing
        rent = 1.00     # 1 KSH for testing
        unit_count = 1
    }
    
    $response = Invoke-ApiRequest -Endpoint "accounts/unit-types/" -Method "POST" -Body $unitTypeData -Token $Global:LandlordToken
    
    if ($response.Success) {
        $Global:UnitTypeId = $response.Data.id
        Write-ColorOutput "SUCCESS: Unit Type created successfully:" $Green
        Write-ColorOutput "   Name: $($response.Data.name)" $Green
        Write-ColorOutput "   Rent: KES $($response.Data.rent)" $Green
        Write-ColorOutput "   Deposit: KES $($response.Data.deposit)" $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Unit Type creation failed: $($response.Error)" $Red
        return $false
    }
}

function Create-Property {
    Write-Step "4. Creating Property"
    
    $propertyData = @{
        name = "Demo Apartments"
        city = "Nairobi"
        state = "Nairobi County"
        unit_count = 1
    }
    
    $response = Invoke-ApiRequest -Endpoint "accounts/properties/create/" -Method "POST" -Body $propertyData -Token $Global:LandlordToken
    
    if ($response.Success) {
        $Global:PropertyId = $response.Data.id
        Write-ColorOutput "SUCCESS: Property created successfully:" $Green
        Write-ColorOutput "   Name: $($response.Data.name)" $Green
        Write-ColorOutput "   Location: $($response.Data.city), $($response.Data.state)" $Green
        Write-ColorOutput "   ID: $($response.Data.id)" $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Property creation failed: $($response.Error)" $Red
        return $false
    }
}

function Create-Unit {
    Write-Step "5. Creating Unit"
    
    $unitData = @{
        property = $Global:PropertyId
        unit_type = $Global:UnitTypeId
        floor = 1
        bedrooms = 1
        bathrooms = 1
        rent = 1.00     # 1 KSH for testing
        deposit = 1.00  # 1 KSH for testing
    }
    
    $response = Invoke-ApiRequest -Endpoint "accounts/units/create/" -Method "POST" -Body $unitData -Token $Global:LandlordToken
    
    if ($response.Success) {
        $Global:UnitId = $response.Data.id
        Write-ColorOutput "SUCCESS: Unit created successfully:" $Green
        Write-ColorOutput "   Unit Number: $($response.Data.unit_number)" $Green
        Write-ColorOutput "   Unit Code: $($response.Data.unit_code)" $Green
        Write-ColorOutput "   Rent: KES $($response.Data.rent)" $Green
        Write-ColorOutput "   Deposit: KES $($response.Data.deposit)" $Green
        Write-ColorOutput "   Available: $($response.Data.is_available)" $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Unit creation failed: $($response.Error)" $Red
        return $false
    }
}

function Get-LandlordCode {
    Write-Step "6. Getting Landlord Code for Tenant Registration"
    
    $response = Invoke-ApiRequest -Endpoint "accounts/me/" -Method "GET" -Token $Global:LandlordToken
    
    if ($response.Success) {
        $Global:LandlordCode = $response.Data.landlord_code
        Write-ColorOutput "SUCCESS: Landlord code retrieved:" $Green
        Write-ColorOutput "   Landlord Code: $Global:LandlordCode" $Green
        return $Global:LandlordCode
    } else {
        Write-ColorOutput "ERROR: Failed to get landlord code: $($response.Error)" $Red
        return $null
    }
}

function Register-Tenant {
    param([string]$LandlordCode)
    
    Write-Section "PHASE 2: TENANT ONBOARDING"
    
    Write-Step "1. Registering Tenant Account"
    
    $timestamp = Get-Date -Format "yyyyMMddHHmmss"
    $Global:TenantEmail = "demo_tenant_$timestamp@makau.com"
    $tenantData = @{
        email = $Global:TenantEmail
        full_name = "Demo Tenant"
        user_type = "tenant"
        password = "DemoPass123!"
        phone_number = "+254722714334"  # Real phone number for M-Pesa testing
        government_id = "87654321"
        landlord_code = $LandlordCode
    }
    
    $response = Invoke-ApiRequest -Endpoint "accounts/signup/" -Method "POST" -Body $tenantData
    
    if ($response.Success) {
        $Global:TenantId = $response.Data.id
        Write-ColorOutput "SUCCESS: Tenant registered successfully:" $Green
        Write-ColorOutput "   Email: $($tenantData.email)" $Green
        Write-ColorOutput "   ID: $($response.Data.id)" $Green
        Write-ColorOutput "   Phone: $($tenantData.phone_number)" $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Tenant registration failed: $($response.Error)" $Red
        return $false
    }
}

function Login-Tenant {
    Write-Step "2. Tenant Login"
    
    $loginData = @{
        email = $Global:TenantEmail
        password = "DemoPass123!"
        user_type = "tenant"
    }
    
    $response = Invoke-ApiRequest -Endpoint "accounts/token/" -Method "POST" -Body $loginData
    
    if ($response.Success) {
        $Global:TenantToken = $response.Data.access
        Write-ColorOutput "SUCCESS: Tenant logged in successfully" $Green
        Write-ColorOutput "   Token obtained: $($Global:TenantToken.Substring(0, 20))..." $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Tenant login failed: $($response.Error)" $Red
        return $false
    }
}

function Update-Unit-Deposit {
    Write-Step "3. Updating Unit Deposit to 1 KSH for Testing"
    
    $unitUpdateData = @{
        deposit = 1.00  # Set to 1 KSH for testing
    }
    
    $response = Invoke-ApiRequest -Endpoint "accounts/units/$Global:UnitId/update/" -Method "PUT" -Body $unitUpdateData -Token $Global:LandlordToken
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Unit deposit updated to 1 KSH for testing" $Green
        return $true
    } else {
        Write-ColorOutput "WARNING: Could not update unit deposit: $($response.Error)" $Yellow
        return $false
    }
}

function Get-User-Profile {
    param([string]$Token, [string]$UserType)
    
    Write-Step "Getting $UserType Profile"
    
    $response = Invoke-ApiRequest -Endpoint "accounts/me/" -Method "GET" -Token $Token
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: $UserType profile retrieved:" $Green
        Write-ColorOutput "   Name: $($response.Data.full_name)" $Green
        Write-ColorOutput "   Email: $($response.Data.email)" $Green
        Write-ColorOutput "   User Type: $($response.Data.user_type)" $Green
        if ($response.Data.phone_number) {
            Write-ColorOutput "   Phone: $($response.Data.phone_number)" $Green
        }
        return $true
    } else {
        Write-ColorOutput "ERROR: Failed to get profile: $($response.Error)" $Red
        return $false
    }
}

function Check-Subscription-Status {
    Write-Step "Checking Landlord Subscription Status"
    
    $response = Invoke-ApiRequest -Endpoint "accounts/subscription-status/" -Method "GET" -Token $Global:LandlordToken
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Subscription status:" $Green
        Write-ColorOutput "   Plan: $($response.Data.plan)" $Green
        Write-ColorOutput "   Active: $($response.Data.is_active)" $Green
        Write-ColorOutput "   Status: $($response.Data.status)" $Green
        if ($response.Data.expiry_date) {
            Write-ColorOutput "   Expiry: $($response.Data.expiry_date)" $Green
        }
        return $true
    } else {
        Write-ColorOutput "ERROR: Failed to get subscription status: $($response.Error)" $Red
        return $false
    }
}

function View-Landlord-Dashboard {
    Write-Section "PHASE 3: LANDLORD MANAGEMENT"
    
    Write-Step "1. Viewing Landlord Dashboard"
    
    $response = Invoke-ApiRequest -Endpoint "accounts/dashboard-stats/" -Method "GET" -Token $Global:LandlordToken
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Dashboard statistics:" $Green
        Write-ColorOutput "   Active Tenants: $($response.Data.total_active_tenants)" $Green
        Write-ColorOutput "   Available Units: $($response.Data.total_units_available)" $Green
        Write-ColorOutput "   Occupied Units: $($response.Data.total_units_occupied)" $Green
        Write-ColorOutput "   Monthly Revenue: KES $($response.Data.monthly_revenue)" $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Failed to get dashboard stats: $($response.Error)" $Red
        return $false
    }
}

function View-Rent-Summary {
    Write-Step "2. Viewing Rent Summary"
    
    $response = Invoke-ApiRequest -Endpoint "payments/rent-payments/summary/" -Method "GET" -Token $Global:LandlordToken
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Rent summary:" $Green
        Write-ColorOutput "   Total Collected: KES $($response.Data.total_collected)" $Green
        Write-ColorOutput "   Total Outstanding: KES $($response.Data.total_outstanding)" $Green
        Write-ColorOutput "   Units: $($response.Data.units.Count)" $Green
        return $true
    } else {
        Write-ColorOutput "ERROR: Failed to get rent summary: $($response.Error)" $Red
        return $false
    }
}

function View-Landlord-Properties {
    Write-Step "3. Viewing Landlord Properties"
    
    $response = Invoke-ApiRequest -Endpoint "accounts/properties/" -Method "GET" -Token $Global:LandlordToken
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Properties list:" $Green
        foreach ($property in $response.Data) {
            Write-ColorOutput "   - $($property.name) ($($property.city)) - $($property.unit_count) units" $Green
        }
        return $true
    } else {
        Write-ColorOutput "ERROR: Failed to get properties: $($response.Error)" $Red
        return $false
    }
}

function Submit-Maintenance-Report {
    Write-Section "PHASE 4: MAINTENANCE & COMMUNICATION"
    
    Write-Step "1. Submitting Maintenance Report"
    
    # First, let's assign the tenant to the unit to fix the 403 error
    Write-ColorOutput "   Note: Tenant must be assigned to unit to submit reports" $Yellow
    
    $reportData = @{
        unit = $Global:UnitId
        issue_category = "maintenance"
        priority_level = "low"
        issue_title = "Demo: Test Maintenance Request"
        description = "This is a demo maintenance report for testing purposes."
    }
    
    $response = Invoke-ApiRequest -Endpoint "communication/reports/create/" -Method "POST" -Body $reportData -Token $Global:TenantToken
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Maintenance report submitted:" $Green
        Write-ColorOutput "   Issue: $($response.Data.issue_title)" $Green
        Write-ColorOutput "   Category: $($response.Data.issue_category)" $Green
        Write-ColorOutput "   Priority: $($response.Data.priority_level)" $Green
        Write-ColorOutput "   Status: $($response.Data.status)" $Green
        return $true
    } else {
        Write-ColorOutput "WARNING: Maintenance report submission failed (tenant not assigned to unit): $($response.Error)" $Yellow
        return $false
    }
}

function View-Tenant-Reports {
    Write-Step "2. Viewing Tenant Reports"
    
    $response = Invoke-ApiRequest -Endpoint "communication/reports/open/" -Method "GET" -Token $Global:TenantToken
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Open reports:" $Green
        if ($response.Data.Count -gt 0) {
            foreach ($report in $response.Data) {
                Write-ColorOutput "   - $($report.issue_title) [$($report.status)]" $Green
            }
        } else {
            Write-ColorOutput "   No open reports found" $Yellow
        }
        return $true
    } else {
        Write-ColorOutput "ERROR: Failed to get reports: $($response.Error)" $Red
        return $false
    }
}

function View-Landlord-Reports {
    Write-Step "3. Viewing Landlord Reports"
    
    $response = Invoke-ApiRequest -Endpoint "communication/reports/open/" -Method "GET" -Token $Global:LandlordToken
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Landlord open reports:" $Green
        if ($response.Data.Count -gt 0) {
            foreach ($report in $response.Data) {
                Write-ColorOutput "   - $($report.issue_title) by $($report.tenant.full_name)" $Green
            }
        } else {
            Write-ColorOutput "   No open reports found" $Yellow
        }
        return $true
    } else {
        Write-ColorOutput "ERROR: Failed to get landlord reports: $($response.Error)" $Red
        return $false
    }
}

function Test-Deposit-Payment {
    Write-Section "PHASE 5: REAL M-PESA PAYMENTS (1 KSH)"
    
    Write-Step "1. Testing Deposit Payment (1 KSH)"
    
    $depositData = @{
        unit_id = $Global:UnitId
    }
    
    Write-ColorOutput "   Initiating 1 KSH deposit payment for unit $Global:UnitId..." $Yellow
    Write-ColorOutput "   Tenant Phone: +254722714334" $Yellow
    Write-ColorOutput "   Amount: 1 KSH" $Yellow
    
    $response = Invoke-ApiRequest -Endpoint "payments/initiate-deposit/" -Method "POST" -Body $depositData -Token $Global:TenantToken -TimeoutSec 45
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Deposit payment initiated:" $Green
        Write-ColorOutput "   Message: $($response.Data.message)" $Green
        if ($response.Data.payment_id) {
            Write-ColorOutput "   Payment ID: $($response.Data.payment_id)" $Green
        }
        if ($response.Data.checkout_request_id) {
            Write-ColorOutput "   Checkout Request ID: $($response.Data.checkout_request_id)" $Green
        }
        
        # Check payment status
        if ($response.Data.payment_id) {
            Write-ColorOutput "   Checking payment status..." $Yellow
            Start-Sleep -Seconds 5
            $statusResponse = Invoke-ApiRequest -Endpoint "payments/deposit-status/$($response.Data.payment_id)/" -Method "GET" -Token $Global:TenantToken
            if ($statusResponse.Success) {
                Write-ColorOutput "   Payment Status: $($statusResponse.Data.status)" $Green
            }
        }
        
        return $true
    } else {
        Write-ColorOutput "ERROR: Deposit payment initiation failed: $($response.Error)" $Red
        return $false
    }
}

function Test-Rent-Payment {
    Write-Step "2. Testing Rent Payment (1 KSH)"
    
    # First, we need to assign the tenant to the unit for rent payments
    Write-ColorOutput "   Note: Rent payments require tenant to be assigned to unit" $Yellow
    
    $rentData = @{
        amount = 1.00  # 1 KSH for testing
    }
    
    Write-ColorOutput "   Initiating 1 KSH rent payment for unit $Global:UnitId..." $Yellow
    Write-ColorOutput "   Tenant Phone: +254722714334" $Yellow
    Write-ColorOutput "   Amount: 1 KSH" $Yellow
    
    $response = Invoke-ApiRequest -Endpoint "payments/stk-push/$Global:UnitId/" -Method "POST" -Body $rentData -Token $Global:TenantToken -TimeoutSec 45
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Rent payment initiated:" $Green
        Write-ColorOutput "   Message: $($response.Data.message)" $Green
        if ($response.Data.payment_id) {
            Write-ColorOutput "   Payment ID: $($response.Data.payment_id)" $Green
        }
        if ($response.Data.checkout_request_id) {
            Write-ColorOutput "   Checkout Request ID: $($response.Data.checkout_request_id)" $Green
        }
        return $true
    } else {
        Write-ColorOutput "WARNING: Rent payment initiation failed (tenant not assigned): $($response.Error)" $Yellow
        return $false
    }
}

function Test-Subscription-Payment {
    Write-Step "3. Testing Subscription Payment (1 KSH)"
    
    $subscriptionData = @{
        plan = "starter"
        phone_number = "+254722714334"  # Landlord's phone for subscription
    }
    
    Write-ColorOutput "   Initiating 1 KSH subscription payment..." $Yellow
    Write-ColorOutput "   Landlord Phone: $($subscriptionData.phone_number)" $Yellow
    Write-ColorOutput "   Plan: $($subscriptionData.plan)" $Yellow
    Write-ColorOutput "   Amount: 1 KSH" $Yellow
    
    $response = Invoke-ApiRequest -Endpoint "payments/stk-push-subscription/" -Method "POST" -Body $subscriptionData -Token $Global:LandlordToken -TimeoutSec 45
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Subscription payment initiated:" $Green
        Write-ColorOutput "   Message: $($response.Data.message)" $Green
        if ($response.Data.payment_id) {
            Write-ColorOutput "   Payment ID: $($response.Data.payment_id)" $Green
        }
        if ($response.Data.checkout_request_id) {
            Write-ColorOutput "   Checkout Request ID: $($response.Data.checkout_request_id)" $Green
        }
        return $true
    } else {
        Write-ColorOutput "ERROR: Subscription payment initiation failed: $($response.Error)" $Red
        return $false
    }
}

function Assign-Tenant-To-Unit {
    Write-Step "4. Assigning Tenant to Unit (Required for Payments)"
    
    $assignData = @{
        # No body needed for this endpoint, uses URL parameters
    }
    
    Write-ColorOutput "   Attempting to assign tenant to unit..." $Yellow
    
    # This endpoint requires unit_id and tenant_id in URL
    $response = Invoke-ApiRequest -Endpoint "accounts/units/$Global:UnitId/assign/$Global:TenantId/" -Method "POST" -Body $assignData -Token $Global:LandlordToken -TimeoutSec 45
    
    if ($response.Success) {
        Write-ColorOutput "SUCCESS: Tenant assigned to unit:" $Green
        Write-ColorOutput "   Message: $($response.Data.message)" $Green
        if ($response.Data.payment_id) {
            Write-ColorOutput "   Payment ID: $($response.Data.payment_id)" $Green
        }
        return $true
    } else {
        Write-ColorOutput "WARNING: Tenant assignment failed: $($response.Error)" $Yellow
        Write-ColorOutput "   This is expected if deposit payment is required first" $Yellow
        return $false
    }
}

function Show-System-Status {
    Write-Section "SYSTEM STATUS SUMMARY"
    
    Write-ColorOutput "Application Components Status:" $Cyan
    
    # Test various endpoints
    $endpoints = @(
        @{Name="Authentication"; Endpoint="accounts/token/"},
        @{Name="User Management"; Endpoint="accounts/me/"},
        @{Name="Properties"; Endpoint="accounts/properties/"},
        @{Name="Payments"; Endpoint="payments/rent-payments/"},
        @{Name="Communication"; Endpoint="communication/reports/open/"}
    )
    
    foreach ($endpoint in $endpoints) {
        $testResponse = Invoke-ApiRequest -Endpoint $endpoint.Endpoint -Method "GET" -Token $Global:LandlordToken
        $status = if ($testResponse.Success -or $testResponse.StatusCode -eq 401) { "ONLINE" } else { "OFFLINE" }
        $color = if ($testResponse.Success -or $testResponse.StatusCode -eq 401) { $Green } else { $Red }
        Write-ColorOutput "   $($endpoint.Name): $status" $color
    }
}

function Main {
    Write-Host "`n" + "="*70 -ForegroundColor $Magenta
    Write-Host "MAKAU RENTALS - REAL LIFE APPLICATION WORKFLOW DEMO" -ForegroundColor $Magenta
    Write-Host "Live Server: $BaseUrl" -ForegroundColor $Magenta
    Write-Host "NOW WITH REAL M-PESA INTEGRATION (1 KSH TRANSACTIONS)" -ForegroundColor $Magenta
    Write-Host "="*70 -ForegroundColor $Magenta
    
    # Test API connection first
    if (-not (Test-ApiConnection)) {
        Write-ColorOutput "Cannot proceed without API connection. Please check if the server is running." $Red
        return
    }
    
    # Landlord workflow
    if (-not (Register-Landlord)) { return }
    if (-not (Login-Landlord)) { return }
    if (-not (Create-UnitType)) { return }
    if (-not (Create-Property)) { return }
    if (-not (Create-Unit)) { return }
    
    $landlordCode = Get-LandlordCode
    if (-not $landlordCode) { return }
    
    # Tenant workflow  
    if (-not (Register-Tenant -LandlordCode $landlordCode)) { return }
    if (-not (Login-Tenant)) { return }
    
    # Update unit deposit to 1 KSH for testing
    Update-Unit-Deposit
    
    # User profiles
    Get-User-Profile -Token $Global:LandlordToken -UserType "Landlord"
    Get-User-Profile -Token $Global:TenantToken -UserType "Tenant"
    
    # Subscription & Dashboard
    Check-Subscription-Status
    View-Landlord-Dashboard
    View-Rent-Summary
    View-Landlord-Properties
    
    # REAL M-Pesa Payment Workflow
    Test-Deposit-Payment
    Start-Sleep -Seconds 10
    Assign-Tenant-To-Unit
    Test-Rent-Payment
    Submit-Maintenance-Report
    View-Tenant-Reports
    View-Landlord-Reports
    
    # System status
    Show-System-Status
    
    Write-Section "DEMO COMPLETED SUCCESSFULLY!"
    Write-ColorOutput "The Makau Rentals application workflow has been successfully demonstrated!" $Green
    Write-ColorOutput "REAL M-PESA PAYMENTS WERE INITIATED WITH 1 KSH TRANSACTIONS!" $Green
    Write-ColorOutput "Demo Summary:" $Cyan
    Write-ColorOutput "   - Landlord account created and authenticated" $Cyan
    Write-ColorOutput "   - Property and unit created with 1 KSH pricing" $Cyan
    Write-ColorOutput "   - Tenant account created and linked to landlord" $Cyan
    Write-ColorOutput "   - Real M-Pesa deposit payment initiated (1 KSH)" $Cyan
    Write-ColorOutput "   - Real M-Pesa rent payment initiated (1 KSH)" $Cyan
    Write-ColorOutput "   - All major application features tested" $Cyan
    Write-ColorOutput "Live API Endpoints:" $Cyan
    Write-ColorOutput "   Base URL: $BaseUrl" $Cyan
    Write-ColorOutput "   API Documentation: $BaseUrl/api/docs/" $Cyan
    Write-ColorOutput "`nIMPORTANT: Check your phone to complete the M-Pesa payments!" $Yellow
    Write-ColorOutput "Phone numbers used:" $Yellow
    Write-ColorOutput "   Landlord: +254722714334" $Yellow
    Write-ColorOutput "   Tenant: +254722714334" $Yellow
}

# Start the demo
try {
    Main
}
catch {
    Write-ColorOutput "An unexpected error occurred: $($_.Exception.Message)" $Red
    Write-ColorOutput "Stack trace: $($_.ScriptStackTrace)" $Red
}

Write-Host "`n" + "="*70 -ForegroundColor $Magenta
Write-Host "Demo script execution completed" -ForegroundColor $Magenta
Write-Host "="*70 -ForegroundColor $Magenta

from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.utils import timezone
from datetime import timedelta
from django.core.exceptions import ValidationError
import uuid


class CustomUserManager(BaseUserManager):
    # ensure the email is normalized and user_type is provided
    def create_user(self, email, full_name, user_type, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        if not user_type:
            raise ValueError("User type must be set (landlord or tenant)")

        email = self.normalize_email(email)
        user = self.model(
            email=email,
            full_name=full_name,
            user_type=user_type,
            **extra_fields
        )
        user.set_password(password)
        user.save(using=self._db)

        # Auto-assign free trial for landlords
        if user_type == "landlord":
            Subscription.objects.create(
                user=user,
                plan="free",
                expiry_date=timezone.now() + timedelta(days=60)
            )
            # generate a public landlord_code
            if not getattr(user, 'landlord_code', None):
                user.landlord_code = f"L-{uuid.uuid4().hex[:10].upper()}"
                user.save(update_fields=['landlord_code'])

        return user

    def create_superuser(self, email, full_name, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        # set default user_type if not provided
        user_type = extra_fields.pop("user_type", "landlord")

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self.create_user(
            email=email,
            full_name=full_name,
            user_type=user_type,
            password=password,
            **extra_fields
        )


class CustomUser(AbstractBaseUser,PermissionsMixin):
    email = models.EmailField(unique=True)
    full_name = models.CharField(max_length=120, default='')
    # Government ID number (National ID or Passport)
    government_id = models.CharField(max_length=20, blank=True, null=True, help_text="Government ID number (e.g., National ID or Passport)")
    # ID or passport image for verification
    id_document = models.ImageField(upload_to='id_documents/', null=True, blank=True)
    # Human-facing landlord code used externally (different from DB id)
    landlord_code = models.CharField(max_length=50, unique=True, null=True, blank=True)
    date_joined = models.DateTimeField(auto_now_add=True)
    type = [('landlord', 'Landlord'), ('tenant', 'Tenant')]
    user_type = models.CharField(max_length=10, choices=type)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)
    mpesa_till_number = models.CharField(max_length=20, blank=True, null=True, help_text="M-Pesa till number for direct payments (landlords only)")
    phone_number = models.CharField(max_length=30, blank=True, null=True, help_text="User phone number in international format")
    emergency_contact = models.CharField(max_length=30, blank=True, null=True, help_text="Emergency contact phone number")
    reminder_mode = models.CharField(
        max_length=20,
        choices=[('days_before', 'Days Before Due Date'), ('fixed_day', 'Fixed Day of Month')],
        default='days_before',
        help_text="How the tenant wants to receive rent reminders"
    )
    reminder_value = models.IntegerField(
        default=10,
        help_text="For 'days_before': days before due date; For 'fixed_day': day of the month (1-31)"
    )

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['full_name']
    objects = CustomUserManager()

    # Check if user has an active subscription
    def has_active_subscription(self):
        if hasattr(self, "subscription"):
            return self.subscription.is_active()
        return False

    def __str__(self):
        return f"{self.full_name} ({self.email})"


class Subscription(models.Model):
    PLAN_CHOICES = [
        ("free", "Free (60-day trial)"),
        ("starter", "Starter (up to 10 units)"),
        ("basic", "Basic (10-50 units)"),
        ("professional", "Professional (50-100 units)"),
        ("onetime", "One-time (Unlimited properties)"),
    ]

    user = models.OneToOneField(CustomUser, on_delete=models.CASCADE, related_name="subscription")
    plan = models.CharField(max_length=20, choices=PLAN_CHOICES, default="free")
    start_date = models.DateTimeField(auto_now_add=True)
    expiry_date = models.DateTimeField(null=True, blank=True)

    def save(self, *args, **kwargs):
        # Set expiry dates based on plan
        if not self.expiry_date:
            if self.plan == "free":
                self.expiry_date = timezone.now() + timedelta(days=60)
            elif self.plan == "starter":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            elif self.plan == "basic":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            elif self.plan == "professional":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            # "onetime" could remain None for lifetime access
        
        super().save(*args, **kwargs)

    # Check if subscription is still valid
    def is_active(self):
        return self.expiry_date is None or self.expiry_date > timezone.now()

    def __str__(self):
        return f"{self.user.email} - {self.plan}"


class Property(models.Model):
    landlord = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    name = models.CharField(max_length=255)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=100)
    unit_count = models.IntegerField()   # integer count of units for this property

    def __str__(self):
        return f"{self.name}, {self.city}"

    def __str__(self):
        return f"{self.name}, {self.city}"

# TODO: Ensure that the landlord can only have a certain amount of units linked to property unit count
class UnitType(models.Model):
    landlord = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='unit_types')
    name = models.CharField(max_length=50)
    deposit = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    number_of_units = models.IntegerField(default=0, help_text="Number of units of this type to create automatically")

    def __str__(self):
        return f"{self.landlord.email} - {self.name}"


class Unit(models.Model):
    property_obj = models.ForeignKey(
        Property,
        on_delete=models.CASCADE,
        related_name="unit_list",
        db_column="property_id"
    )
    # system-generated unit code (unique per unit)
    unit_code = models.CharField(max_length=30, unique=True, default='')
    unit_number = models.CharField(max_length=10)
    floor = models.IntegerField(null=True, blank=True)
    bedrooms = models.IntegerField(default=0)
    bathrooms = models.IntegerField(default=0)

    unit_type = models.ForeignKey(UnitType, on_delete=models.SET_NULL, null=True, blank=True)

    rent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    tenant = models.OneToOneField(CustomUser, on_delete=models.SET_NULL, null=True, blank=True)

    rent_paid = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent_remaining = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent_due_date = models.DateField(null=True, blank=True)

    deposit = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    is_available = models.BooleanField(default=True)

    assigned_date = models.DateTimeField(null=True, blank=True)
    left_date = models.DateTimeField(null=True, blank=True)

    @property
    def balance(self):
        return self.rent_remaining - self.rent_paid

    def clean(self):
        current_units = self.__class__.objects.filter(property_obj=self.property_obj).count()
        if self.property_obj.unit_count is not None and current_units >= self.property_obj.unit_count:
            raise ValidationError("The number of units for this property has reached the limit.")

    def save(self, *args, **kwargs):
        # Calculate rent_remaining as rent - rent_paid
        self.rent_remaining = self.rent - self.rent_paid

        if self.pk:  # existing unit
            old_unit = Unit.objects.get(pk=self.pk)
            if old_unit.tenant != self.tenant:
                if self.tenant and not self.assigned_date:
                    self.assigned_date = timezone.now()
                elif not self.tenant and old_unit.tenant:
                    self.left_date = timezone.now()
        else:  # new unit
            if self.tenant:
                self.assigned_date = timezone.now()
        super().save(*args, **kwargs)


    def __str__(self):
        return f"{self.property_obj.name} - Unit {self.unit_number}"



# REMINDER: payments is shown in the Unit model as rent_paid and rent_remaining
# TODO: Protect the subscription features using a decorator or middleware to ensure only subscribed users can access them
# TODO: Ensure payments for subscription and rent are two different things

from django.db import models
from accounts.models import CustomUser, Unit, Subscription
from datetime import timedelta

class Payment(models.Model):
    PAYMENT_TYPES = [
        ('rent', 'Rent'),
        ('deposit', 'Deposit'),
    ]
    tenant = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        limit_choices_to={'user_type': 'tenant'},
        related_name='payments',
        null=True,
        blank=True
    )
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name='payments', null=True, blank=True)
    unit_type = models.ForeignKey('accounts.UnitType', on_delete=models.CASCADE, related_name='payments', null=True, blank=True)
    payment_type = models.CharField(max_length=10, choices=PAYMENT_TYPES, default='rent')
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    mpesa_receipt = models.CharField(max_length=50, blank=True, null=True)
    transaction_date = models.DateTimeField(auto_now_add=True)
    status = models.CharField(
        max_length=20,
        choices=[("Pending", "Pending"), ("Success", "Success"), ("Failed", "Failed")],
        default="Pending"
    )

    def __str__(self):
        unit_str = f"Unit {self.unit.unit_number}" if self.unit else "Deposit"
        return f"{self.tenant.email} - {unit_str} - KES {self.amount} ({self.status})"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)


class SubscriptionPayment(models.Model):
    user = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        null=True,
        blank=True
    )
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    mpesa_receipt_number = models.CharField(
        max_length=50,
        blank=True,  # Allow empty strings
        default=""
    )
    transaction_date = models.DateTimeField(auto_now_add=True)
    subscription_type = models.CharField(max_length=20, choices=Subscription.PLAN_CHOICES)

    class Meta:
        # Remove or modify the unique constraint to allow empty strings
        constraints = [
            models.UniqueConstraint(
                fields=['mpesa_receipt_number'],
                name='unique_mpesa_receipt',
                condition=~models.Q(mpesa_receipt_number='')  # Only enforce uniqueness for non-empty values
            )
        ]

    def __str__(self):
        return f"Subscription Payment {self.id} - {self.subscription_type}"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)

    def _get_plan_duration(self):
        durations = {
            "free": timedelta(days=60),
            "starter": timedelta(days=30),
            "basic": timedelta(days=30),
            "professional": timedelta(days=30),
            # "onetime" will be treated as lifetime (None) by the subscription logic
        }
        return durations.get(self.subscription_type, timedelta(days=30))
from django.db import models
from accounts.models import CustomUser, Unit

class Report(models.Model):
    ISSUE_CATEGORIES = [
        ('electrical', 'Electrical'),
        ('plumbing', 'Plumbing'),
        ('noise', 'Noise'),
        ('safety/violence', 'Safety/Violence'),
        ('wifi', 'WiFi'),
        ('maintenance', 'Maintenance'),
    ]

    PRIORITY_LEVELS = [
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('urgent', 'Urgent'),
    ]

    STATUS_CHOICES = [
        ('open', 'Open'),
        ('in_progress', 'In Progress'),
        ('resolved', 'Resolved'),
        ('closed', 'Closed'),
    ]

    tenant = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='reports')
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name='reports')
    issue_category = models.CharField(max_length=20, choices=ISSUE_CATEGORIES)
    priority_level = models.CharField(max_length=10, choices=PRIORITY_LEVELS)
    issue_title = models.CharField(max_length=255)
    description = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=15, choices=STATUS_CHOICES, default='open')

    def __str__(self):
        return f"Report by {self.tenant.full_name} - {self.issue_title}"

from .models import CustomUser, Property, Unit, UnitType
from rest_framework import serializers

from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_encode
from django.utils.encoding import force_bytes
from django.core.mail import send_mail

# Overide the token to use email instead of username for JWT authentication
# accounts/serializers.py
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework import serializers
from django.contrib.auth import authenticate
from .models import CustomUser

class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    username_field = "email"

    user_type = serializers.CharField(write_only=True)

    def validate(self, attrs):
        email = attrs.get("email")
        password = attrs.get("password")
        user_type = attrs.get("user_type")

        if email and password and user_type:
            user = authenticate(self.context['request'], email=email, password=password)
            if not user:
                raise serializers.ValidationError("Invalid email or password")
            if user.user_type not in ['tenant', 'landlord']:
                raise serializers.ValidationError("Invalid user type")
            if user.user_type != user_type:
                raise serializers.ValidationError("User type does not match")
            if not user.is_active:
                raise serializers.ValidationError("User account is disabled")
        else:
            raise serializers.ValidationError("Must include 'email', 'password', and 'user_type'")

        data = super().validate(attrs)
        data['user_type'] = user_type
        return data



class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = [
            'id',
            'email',
            'full_name',
            'government_id',
            'id_document',
            'landlord_code',
            'date_joined',
            'user_type',
            'is_active',
            'is_staff',
            'is_superuser',
            'mpesa_till_number',
            'phone_number',
            'emergency_contact',
            'reminder_mode',
            'reminder_value',
            'password'
        ]
        read_only_fields = ['id', 'date_joined', 'is_active', 'is_staff', 'is_superuser', 'landlord_code']
        extra_kwargs = {
            'password': {'write_only': True}
        }

    def create(self, validated_data):
        # Always use the manager to ensure password is hashed
        # adapt to new signature: email, full_name, user_type, password
        email = validated_data.pop('email')
        full_name = validated_data.pop('full_name')
        user_type = validated_data.pop('user_type')
        password = validated_data.pop('password', None)
        user = CustomUser.objects.create_user(email=email, full_name=full_name, user_type=user_type, password=password, **validated_data)
        return user

    def update(self, instance, validated_data):
        for attr, value in validated_data.items():
            if attr == 'password':
                instance.set_password(value)
            else:
                setattr(instance, attr, value)
        instance.save()
        return instance

    def validate_phone_number(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid phone number in international format, e.g. +2547XXXXXXXX")
        return value

    def validate_emergency_contact(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid emergency contact phone number in international format")
        return value

        
class PropertySerializer(serializers.ModelSerializer):
    class Meta:
        model = Property
        fields = ['id', 'landlord', 'name', 'city', 'state', 'unit_count']
        read_only_fields = ['id', 'landlord']
    def create(self, validated_data):
        property = Property.objects.create(**validated_data)
        return property
    
class UnitTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = UnitType
        fields = ['id', 'landlord', 'name', 'deposit', 'rent']
        read_only_fields = ['id', 'landlord']


class UnitSerializer(serializers.ModelSerializer):
    property = serializers.IntegerField(write_only=True, required=False)  # Alias for property_obj

    class Meta:
        model = Unit
        fields = ['id', 'property_obj', 'unit_code', 'unit_number', 'floor', 'bedrooms', 'bathrooms', 'unit_type', 'rent', 'tenant', 'rent_paid', 'rent_remaining', 'deposit', 'is_available', 'property']
        read_only_fields = ['id', 'rent_remaining', 'unit_code']
        extra_kwargs = {
            'unit_number': {'required': False},
            'property_obj': {'required': False},
        }

    def validate(self, attrs):
        user = self.context['request'].user
        # Handle property alias
        if 'property' in attrs:
            try:
                prop = Property.objects.get(id=attrs.pop('property'))
                if prop.landlord != user:
                    raise serializers.ValidationError("Property not owned by you.")
                attrs['property_obj'] = prop
            except Property.DoesNotExist:
                raise serializers.ValidationError("Property not found.")
        # Validate property_obj ownership if set directly
        if 'property_obj' in attrs:
            if attrs['property_obj'].landlord != user:
                raise serializers.ValidationError("Property not owned by you.")
        # Validate unit_type ownership
        if 'unit_type' in attrs and attrs['unit_type']:
            if attrs['unit_type'].landlord != user:
                raise serializers.ValidationError("UnitType not owned by you.")
        return super().validate(attrs)

    def create(self, validated_data):
        # Auto-generate unit_number if not provided
        if not validated_data.get('unit_number'):
            prop = validated_data.get('property_obj')
            if prop:
                existing_units = Unit.objects.filter(property_obj=prop)
                last_unit = existing_units.order_by('-unit_number').first()
                if last_unit and last_unit.unit_number.isdigit():
                    next_num = int(last_unit.unit_number) + 1
                else:
                    next_num = 1
                validated_data['unit_number'] = str(next_num)
        # Auto-generate unit_code if not provided
        if not validated_data.get('unit_code'):
            prop = validated_data.get('property_obj')
            if prop and getattr(prop, 'id', None):
                existing_count = Unit.objects.filter(property_obj=prop).count()
                validated_data['unit_code'] = f"U-{prop.id}-{existing_count+1}"
            else:
                # fallback unique code
                import uuid
                validated_data['unit_code'] = f"U-{uuid.uuid4().hex[:10].upper()}"
        # Set rent and deposit from unit_type if not provided
        unit_type = validated_data.get('unit_type')
        if unit_type:
            if not validated_data.get('rent'):
                validated_data['rent'] = unit_type.rent
            if not validated_data.get('deposit'):
                validated_data['deposit'] = unit_type.deposit
        # Enforce landlord has at least one UnitType defined before creating units
        prop = validated_data.get('property_obj')
        if prop and prop.landlord:
            landlord = prop.landlord
            if not UnitType.objects.filter(landlord=landlord).exists():
                raise serializers.ValidationError("Landlord must create at least one UnitType before creating Units.")

        unit = Unit.objects.create(**validated_data)
        return unit


class UnitNumberSerializer(serializers.ModelSerializer):
    class Meta:
        model = Unit
        fields = ['unit_number']

# TODO: Ensure landlords create properties and units upon sign up this will be done in the frontend
# TODO: Ensure Tenants pay the deposit to book a unit and choose their property upon sign up
# TODO: Ensure Tenants and Landlords can reset their passwords and get email notifications for important actions 


# For reset password functionality
class PasswordResetSerializer(serializers.Serializer):
    email = serializers.EmailField()

    def validate_email(self, value):
        if not CustomUser.objects.filter(email=value).exists():
            raise serializers.ValidationError("User with this email does not exist.")
        return value

    def save(self):
        from django.conf import settings
        email = self.validated_data['email']
        user = CustomUser.objects.get(email=email)
        uid = urlsafe_base64_encode(force_bytes(user.pk))
        token = default_token_generator.make_token(user)
        # Use the configurable frontend URL from settings
        reset_link = f"{settings.FRONTEND_URL}/reset-password/{uid}/{token}/"

        send_mail(
            subject="Password Reset Request",
            message=f"Click the link to reset your password: {reset_link}",
            from_email=None,
            recipient_list=[email],
        )


class PasswordResetConfirmSerializer(serializers.Serializer):
    uid = serializers.CharField()
    token = serializers.CharField()
    new_password = serializers.CharField(write_only=True, min_length=8)

    def validate(self, attrs):
        from django.contrib.auth.tokens import default_token_generator
        from django.utils.http import urlsafe_base64_decode
        from django.contrib.auth.password_validation import validate_password
        try:
            uid = urlsafe_base64_decode(attrs['uid']).decode()
            user = CustomUser.objects.get(pk=uid)
        except (TypeError, ValueError, OverflowError, CustomUser.DoesNotExist):
            raise serializers.ValidationError("Invalid UID")

        if not default_token_generator.check_token(user, attrs['token']):
            raise serializers.ValidationError("Invalid or expired token")

        validate_password(attrs['new_password'], user)
        attrs['user'] = user
        return attrs

    def save(self):
        user = self.validated_data['user']
        new_password = self.validated_data['new_password']
        user.set_password(new_password)
        user.save()
        return user


class ReminderPreferencesSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ['reminder_mode', 'reminder_value']


class AvailableUnitsSerializer(serializers.ModelSerializer):
    landlord_id = serializers.CharField(source='property_obj.landlord.landlord_code', read_only=True)
    property_id = serializers.IntegerField(source='property_obj.id', read_only=True)
    property_name = serializers.CharField(source='property_obj.name', read_only=True)
    unit_number = serializers.CharField(read_only=True)

    class Meta:
        model = Unit
        fields = ['landlord_id', 'property_id', 'property_name', 'unit_number']
from rest_framework import serializers
from .models import Payment, SubscriptionPayment


class PaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Payment
        fields = '__all__'
        read_only_fields = ['transaction_date', 'status']


class SubscriptionPaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubscriptionPayment
        fields = '__all__'
        read_only_fields = ['transaction_date']
from rest_framework import serializers
from .models import Report
from accounts.models import CustomUser, Unit, Property

class ReportSerializer(serializers.ModelSerializer):
    tenant = serializers.PrimaryKeyRelatedField(read_only=True, default=serializers.CurrentUserDefault())
    unit = serializers.PrimaryKeyRelatedField(queryset=Unit.objects.all())

    class Meta:
        model = Report
        fields = [
            'id',
            'tenant',
            'unit',
            'issue_category',
            'priority_level',
            'issue_title',
            'description',
            'created_at',
            'status',
        ]
        read_only_fields = ['id', 'tenant', 'created_at', 'status']

    def validate_unit(self, value):
        # Ensure the unit belongs to the tenant submitting the report
        user = self.context['request'].user
        if value.tenant != user:
            raise serializers.ValidationError("This unit is not assigned to the current tenant.")
        return value

    def create(self, validated_data):
        validated_data['tenant'] = self.context['request'].user
        return super().create(validated_data)

class UpdateReportStatusSerializer(serializers.ModelSerializer):
    class Meta:
        model = Report
        fields = ['status']
        read_only_fields = []

class SendEmailSerializer(serializers.Serializer):
    subject = serializers.CharField(max_length=255)
    message = serializers.CharField()
    tenants = serializers.ListField(
        child=serializers.PrimaryKeyRelatedField(queryset=CustomUser.objects.filter(user_type='tenant')),
        required=False,
        allow_empty=True
    )
    send_to_all = serializers.BooleanField(default=False)

    def validate(self, data):
        if not data.get('send_to_all') and not data.get('tenants'):
            raise serializers.ValidationError("Either provide a list of tenants or set send_to_all to True.")
        if data.get('send_to_all') and data.get('tenants'):
            raise serializers.ValidationError("Cannot specify tenants when send_to_all is True.")
        return data

    def validate_tenants(self, value):
        # Ensure all tenants belong to the landlord's properties
        request = self.context.get('request')
        if request and request.user.user_type == 'landlord':
            landlord_properties = Property.objects.filter(landlord=request.user)
            tenant_units = Unit.objects.filter(property_obj__in=landlord_properties, tenant__in=value)
            valid_tenants = set(tenant_units.values_list('tenant', flat=True))
            if set(t.id for t in value) != valid_tenants:
                raise serializers.ValidationError("Some tenants do not belong to your properties.")
        return value

