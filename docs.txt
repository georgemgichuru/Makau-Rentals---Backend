from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.utils import timezone
from datetime import timedelta
from django.core.exceptions import ValidationError
import uuid


class CustomUserManager(BaseUserManager):
    # ensure the email is normalized and user_type is provided
    def create_user(self, email, full_name, user_type, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        if not user_type:
            raise ValueError("User type must be set (landlord or tenant)")

        email = self.normalize_email(email)
        user = self.model(
            email=email,
            full_name=full_name,
            user_type=user_type,
            **extra_fields
        )
        user.set_password(password)
        user.save(using=self._db)

        # Auto-assign free trial for landlords
        if user_type == "landlord":
            Subscription.objects.create(
                user=user,
                plan="free",
                expiry_date=timezone.now() + timedelta(days=60)
            )
            # generate a public landlord_code
            if not getattr(user, 'landlord_code', None):
                user.landlord_code = f"L-{uuid.uuid4().hex[:10].upper()}"
                user.save(update_fields=['landlord_code'])

        return user

    def create_superuser(self, email, full_name, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        # set default user_type if not provided
        user_type = extra_fields.pop("user_type", "landlord")

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self.create_user(
            email=email,
            full_name=full_name,
            user_type=user_type,
            password=password,
            **extra_fields
        )


class CustomUser(AbstractBaseUser,PermissionsMixin):
    email = models.EmailField(unique=True)
    full_name = models.CharField(max_length=120, default='')
    # Government ID number (National ID or Passport)
    government_id = models.CharField(max_length=20, blank=True, null=True, help_text="Government ID number (e.g., National ID or Passport)")
    # ID or passport image for verification
    id_document = models.ImageField(upload_to='id_documents/', null=True, blank=True)
    # Human-facing landlord code used externally (different from DB id)
    landlord_code = models.CharField(max_length=50, unique=True, null=True, blank=True)
    date_joined = models.DateTimeField(auto_now_add=True)
    type = [('landlord', 'Landlord'), ('tenant', 'Tenant')]
    user_type = models.CharField(max_length=10, choices=type)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)
    mpesa_till_number = models.CharField(max_length=20, blank=True, null=True, help_text="M-Pesa till number for direct payments (landlords only)")
    phone_number = models.CharField(max_length=30, blank=True, null=True, help_text="User phone number in international format")
    emergency_contact = models.CharField(max_length=30, blank=True, null=True, help_text="Emergency contact phone number")
    reminder_mode = models.CharField(
        max_length=20,
        choices=[('days_before', 'Days Before Due Date'), ('fixed_day', 'Fixed Day of Month')],
        default='days_before',
        help_text="How the tenant wants to receive rent reminders"
    )
    reminder_value = models.IntegerField(
        default=10,
        help_text="For 'days_before': days before due date; For 'fixed_day': day of the month (1-31)"
    )

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['full_name']
    objects = CustomUserManager()

    # Check if user has an active subscription
    def has_active_subscription(self):
        if hasattr(self, "subscription"):
            return self.subscription.is_active()
        return False

    def __str__(self):
        return f"{self.full_name} ({self.email})"


class Subscription(models.Model):
    PLAN_CHOICES = [
        ("free", "Free (60-day trial)"),
        ("starter", "Starter (up to 10 units)"),
        ("basic", "Basic (10-50 units)"),
        ("professional", "Professional (50-100 units)"),
        ("onetime", "One-time (Unlimited properties)"),
    ]

    user = models.OneToOneField(CustomUser, on_delete=models.CASCADE, related_name="subscription")
    plan = models.CharField(max_length=20, choices=PLAN_CHOICES, default="free")
    start_date = models.DateTimeField(auto_now_add=True)
    expiry_date = models.DateTimeField(null=True, blank=True)

    def save(self, *args, **kwargs):
        # Set expiry dates based on plan
        if not self.expiry_date:
            if self.plan == "free":
                self.expiry_date = timezone.now() + timedelta(days=60)
            elif self.plan == "starter":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            elif self.plan == "basic":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            elif self.plan == "professional":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            # "onetime" could remain None for lifetime access
        
        super().save(*args, **kwargs)

    # Check if subscription is still valid
    def is_active(self):
        return self.expiry_date is None or self.expiry_date > timezone.now()

    def __str__(self):
        return f"{self.user.email} - {self.plan}"


class Property(models.Model):
    landlord = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    name = models.CharField(max_length=255)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=100)
    unit_count = models.IntegerField()   # integer count of units for this property

    def __str__(self):
        return f"{self.name}, {self.city}"

    def __str__(self):
        return f"{self.name}, {self.city}"

# TODO: Ensure that the landlord can only have a certain amount of units linked to property unit count
class UnitType(models.Model):
    landlord = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='unit_types')
    name = models.CharField(max_length=50)
    deposit = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    number_of_units = models.IntegerField(default=0, help_text="Number of units of this type to create automatically")

    def __str__(self):
        return f"{self.landlord.email} - {self.name}"


class Unit(models.Model):
    property_obj = models.ForeignKey(
        Property,
        on_delete=models.CASCADE,
        related_name="unit_list",
        db_column="property_id"
    )
    # system-generated unit code (unique per unit)
    unit_code = models.CharField(max_length=30, unique=True, default='')
    unit_number = models.CharField(max_length=10)
    floor = models.IntegerField(null=True, blank=True)
    bedrooms = models.IntegerField(default=0)
    bathrooms = models.IntegerField(default=0)

    unit_type = models.ForeignKey(UnitType, on_delete=models.SET_NULL, null=True, blank=True)

    rent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    tenant = models.OneToOneField(CustomUser, on_delete=models.SET_NULL, null=True, blank=True)

    rent_paid = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent_remaining = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent_due_date = models.DateField(null=True, blank=True)

    deposit = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    is_available = models.BooleanField(default=True)

    assigned_date = models.DateTimeField(null=True, blank=True)
    left_date = models.DateTimeField(null=True, blank=True)

    @property
    def balance(self):
        return self.rent_remaining - self.rent_paid

    def clean(self):
        current_units = self.__class__.objects.filter(property_obj=self.property_obj).count()
        if self.property_obj.unit_count is not None and current_units >= self.property_obj.unit_count:
            raise ValidationError("The number of units for this property has reached the limit.")

    def save(self, *args, **kwargs):
        # Calculate rent_remaining as rent - rent_paid
        self.rent_remaining = self.rent - self.rent_paid

        if self.pk:  # existing unit
            old_unit = Unit.objects.get(pk=self.pk)
            if old_unit.tenant != self.tenant:
                if self.tenant and not self.assigned_date:
                    self.assigned_date = timezone.now()
                elif not self.tenant and old_unit.tenant:
                    self.left_date = timezone.now()
        else:  # new unit
            if self.tenant:
                self.assigned_date = timezone.now()
        super().save(*args, **kwargs)


    def __str__(self):
        return f"{self.property_obj.name} - Unit {self.unit_number}"



# REMINDER: payments is shown in the Unit model as rent_paid and rent_remaining
# TODO: Protect the subscription features using a decorator or middleware to ensure only subscribed users can access them
# TODO: Ensure payments for subscription and rent are two different things
from .models import CustomUser, Property, Unit, UnitType
from rest_framework import serializers

from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_encode
from django.utils.encoding import force_bytes
from django.core.mail import send_mail

# Overide the token to use email instead of username for JWT authentication
# accounts/serializers.py
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework import serializers
from django.contrib.auth import authenticate
from .models import CustomUser

class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    username_field = "email"

    user_type = serializers.CharField(write_only=True)

    def validate(self, attrs):
        email = attrs.get("email")
        password = attrs.get("password")
        user_type = attrs.get("user_type")

        if email and password and user_type:
            user = authenticate(self.context['request'], email=email, password=password)
            if not user:
                raise serializers.ValidationError("Invalid email or password")
            if user.user_type not in ['tenant', 'landlord']:
                raise serializers.ValidationError("Invalid user type")
            if user.user_type != user_type:
                raise serializers.ValidationError("User type does not match")
            if not user.is_active:
                raise serializers.ValidationError("User account is disabled")
        else:
            raise serializers.ValidationError("Must include 'email', 'password', and 'user_type'")

        data = super().validate(attrs)
        data['user_type'] = user_type
        return data



class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = [
            'id',
            'email',
            'full_name',
            'government_id',
            'id_document',
            'landlord_code',
            'date_joined',
            'user_type',
            'is_active',
            'is_staff',
            'is_superuser',
            'mpesa_till_number',
            'phone_number',
            'emergency_contact',
            'reminder_mode',
            'reminder_value',
            'password'
        ]
        read_only_fields = ['id', 'date_joined', 'is_active', 'is_staff', 'is_superuser', 'landlord_code']
        extra_kwargs = {
            'password': {'write_only': True}
        }

    def create(self, validated_data):
        # Always use the manager to ensure password is hashed
        # adapt to new signature: email, full_name, user_type, password
        email = validated_data.pop('email')
        full_name = validated_data.pop('full_name')
        user_type = validated_data.pop('user_type')
        password = validated_data.pop('password', None)
        user = CustomUser.objects.create_user(email=email, full_name=full_name, user_type=user_type, password=password, **validated_data)
        return user

    def update(self, instance, validated_data):
        for attr, value in validated_data.items():
            if attr == 'password':
                instance.set_password(value)
            else:
                setattr(instance, attr, value)
        instance.save()
        return instance

    def validate_phone_number(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid phone number in international format, e.g. +2547XXXXXXXX")
        return value

    def validate_emergency_contact(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid emergency contact phone number in international format")
        return value

        
class PropertySerializer(serializers.ModelSerializer):
    class Meta:
        model = Property
        fields = ['id', 'landlord', 'name', 'city', 'state', 'unit_count']
        read_only_fields = ['id', 'landlord']
    def create(self, validated_data):
        property = Property.objects.create(**validated_data)
        return property
    
class UnitTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = UnitType
        fields = ['id', 'landlord', 'name', 'deposit', 'rent']
        read_only_fields = ['id', 'landlord']


class UnitSerializer(serializers.ModelSerializer):
    property = serializers.IntegerField(write_only=True, required=False)  # Alias for property_obj

    class Meta:
        model = Unit
        fields = ['id', 'property_obj', 'unit_code', 'unit_number', 'floor', 'bedrooms', 'bathrooms', 'unit_type', 'rent', 'tenant', 'rent_paid', 'rent_remaining', 'deposit', 'is_available', 'property']
        read_only_fields = ['id', 'rent_remaining', 'unit_code']
        extra_kwargs = {
            'unit_number': {'required': False},
            'property_obj': {'required': False},
        }

    def validate(self, attrs):
        user = self.context['request'].user
        # Handle property alias
        if 'property' in attrs:
            try:
                prop = Property.objects.get(id=attrs.pop('property'))
                if prop.landlord != user:
                    raise serializers.ValidationError("Property not owned by you.")
                attrs['property_obj'] = prop
            except Property.DoesNotExist:
                raise serializers.ValidationError("Property not found.")
        # Validate property_obj ownership if set directly
        if 'property_obj' in attrs:
            if attrs['property_obj'].landlord != user:
                raise serializers.ValidationError("Property not owned by you.")
        # Validate unit_type ownership
        if 'unit_type' in attrs and attrs['unit_type']:
            if attrs['unit_type'].landlord != user:
                raise serializers.ValidationError("UnitType not owned by you.")
        return super().validate(attrs)

    def create(self, validated_data):
        # Auto-generate unit_number if not provided
        if not validated_data.get('unit_number'):
            prop = validated_data.get('property_obj')
            if prop:
                existing_units = Unit.objects.filter(property_obj=prop)
                last_unit = existing_units.order_by('-unit_number').first()
                if last_unit and last_unit.unit_number.isdigit():
                    next_num = int(last_unit.unit_number) + 1
                else:
                    next_num = 1
                validated_data['unit_number'] = str(next_num)
        # Auto-generate unit_code if not provided
        if not validated_data.get('unit_code'):
            prop = validated_data.get('property_obj')
            if prop and getattr(prop, 'id', None):
                existing_count = Unit.objects.filter(property_obj=prop).count()
                validated_data['unit_code'] = f"U-{prop.id}-{existing_count+1}"
            else:
                # fallback unique code
                import uuid
                validated_data['unit_code'] = f"U-{uuid.uuid4().hex[:10].upper()}"
        # Set rent and deposit from unit_type if not provided
        unit_type = validated_data.get('unit_type')
        if unit_type:
            if not validated_data.get('rent'):
                validated_data['rent'] = unit_type.rent
            if not validated_data.get('deposit'):
                validated_data['deposit'] = unit_type.deposit
        # Enforce landlord has at least one UnitType defined before creating units
        prop = validated_data.get('property_obj')
        if prop and prop.landlord:
            landlord = prop.landlord
            if not UnitType.objects.filter(landlord=landlord).exists():
                raise serializers.ValidationError("Landlord must create at least one UnitType before creating Units.")

        unit = Unit.objects.create(**validated_data)
        return unit


class UnitNumberSerializer(serializers.ModelSerializer):
    class Meta:
        model = Unit
        fields = ['unit_number']

# TODO: Ensure landlords create properties and units upon sign up this will be done in the frontend
# TODO: Ensure Tenants pay the deposit to book a unit and choose their property upon sign up
# TODO: Ensure Tenants and Landlords can reset their passwords and get email notifications for important actions 


# For reset password functionality
class PasswordResetSerializer(serializers.Serializer):
    email = serializers.EmailField()

    def validate_email(self, value):
        if not CustomUser.objects.filter(email=value).exists():
            raise serializers.ValidationError("User with this email does not exist.")
        return value

    def save(self):
        from django.conf import settings
        email = self.validated_data['email']
        user = CustomUser.objects.get(email=email)
        uid = urlsafe_base64_encode(force_bytes(user.pk))
        token = default_token_generator.make_token(user)
        # Use the configurable frontend URL from settings
        reset_link = f"{settings.FRONTEND_URL}/reset-password/{uid}/{token}/"

        send_mail(
            subject="Password Reset Request",
            message=f"Click the link to reset your password: {reset_link}",
            from_email=None,
            recipient_list=[email],
        )


class PasswordResetConfirmSerializer(serializers.Serializer):
    uid = serializers.CharField()
    token = serializers.CharField()
    new_password = serializers.CharField(write_only=True, min_length=8)

    def validate(self, attrs):
        from django.contrib.auth.tokens import default_token_generator
        from django.utils.http import urlsafe_base64_decode
        from django.contrib.auth.password_validation import validate_password
        try:
            uid = urlsafe_base64_decode(attrs['uid']).decode()
            user = CustomUser.objects.get(pk=uid)
        except (TypeError, ValueError, OverflowError, CustomUser.DoesNotExist):
            raise serializers.ValidationError("Invalid UID")

        if not default_token_generator.check_token(user, attrs['token']):
            raise serializers.ValidationError("Invalid or expired token")

        validate_password(attrs['new_password'], user)
        attrs['user'] = user
        return attrs

    def save(self):
        user = self.validated_data['user']
        new_password = self.validated_data['new_password']
        user.set_password(new_password)
        user.save()
        return user


class ReminderPreferencesSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ['reminder_mode', 'reminder_value']


class AvailableUnitsSerializer(serializers.ModelSerializer):
    landlord_id = serializers.CharField(source='property_obj.landlord.landlord_code', read_only=True)
    property_id = serializers.IntegerField(source='property_obj.id', read_only=True)
    property_name = serializers.CharField(source='property_obj.name', read_only=True)
    unit_number = serializers.CharField(read_only=True)

    class Meta:
        model = Unit
        fields = ['landlord_id', 'property_id', 'property_name', 'unit_number']
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from rest_framework.routers import DefaultRouter
from . import views
from django.urls import path
from .views import (UserDetailView, UserListView, UserCreateView, PasswordResetView,
                    CreatePropertyView, LandlordPropertiesView, CreateUnitView,
                    UpdatePropertyView,UpdateUnitView,UpdateUserView, SubscriptionStatusView,
                    UpdateTillNumberView, MyTokenObtainPairView, AdminLandlordSubscriptionStatusView,
                    MeView, PasswordResetConfirmView, UnitTypeListCreateView, UnitTypeDetailView,
                    LandlordDashboardStatsView, TenantUpdateUnitView, AdjustRentView,
                    PropertyUnitsView, AssignTenantView, UpdateReminderPreferencesView,
                    LandlordAvailableUnitsView,
)

router = DefaultRouter()
# Remove or comment these out if you're not using ViewSets
# router.register('properties', views.PropertyViewSet, basename='property')
# router.register('units', views.UnitViewSet, basename='unit')
# router.register('users', views.UserViewSet, basename='user')

urlpatterns = [
    # Authentication endpoints
    path("signup/", UserCreateView.as_view(), name="signup"),
    path('token/', MyTokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    
    # User endpoints
    path("users/<int:user_id>/", UserDetailView.as_view(), name="user-detail"),
    path("users/", UserListView.as_view(), name="user-list"),
    path('users/<int:user_id>/update/', UpdateUserView.as_view(), name='user-update'),
    path('me/', MeView.as_view(), name='me'),
    
    # Password reset
    path('password-reset/', PasswordResetView.as_view(), name='password-reset'),
    path('password-reset-confirm/', PasswordResetConfirmView.as_view(), name='password-reset-confirm'),
    
    # Property endpoints - FIXED URL NAMES
    path('properties/create/', CreatePropertyView.as_view(), name='property-create'),  # Changed from 'create-property'
    path('properties/', LandlordPropertiesView.as_view(), name='property-list'),  # Changed from 'landlord-properties'
    path('properties/<int:property_id>/update/', UpdatePropertyView.as_view(), name='property-update'),
    path('properties/<int:property_id>/units/', PropertyUnitsView.as_view(), name='property-units'),
    
    # Unit endpoints - FIXED URL NAMES
    path('units/create/', CreateUnitView.as_view(), name='unit-create'),  # Changed from 'create-unit'
    path('units/<int:unit_id>/update/', UpdateUnitView.as_view(), name='unit-update'),
    path('units/tenant/update/', TenantUpdateUnitView.as_view(), name='tenant-unit-update'),
    path('units/<int:unit_id>/assign/<int:tenant_id>/', AssignTenantView.as_view(), name='assign-tenant'),  # Changed from 'assign-tenant-to-unit'
    
    # UnitType endpoints
    path('unit-types/', UnitTypeListCreateView.as_view(), name='unit-types'),  # Changed from 'unittype-list-create'
    path('unit-types/<int:pk>/', UnitTypeDetailView.as_view(), name='unit-type-detail'),  # Changed from 'unittype-detail'
    
    # Subscription endpoints
    path('subscription-status/', SubscriptionStatusView.as_view(), name='subscription-status'),
    path('update-till-number/', UpdateTillNumberView.as_view(), name='update-till-number'),
    path('admin/landlord-subscriptions/', AdminLandlordSubscriptionStatusView.as_view(), name='admin-landlord-subscriptions'),
    path('dashboard-stats/', LandlordDashboardStatsView.as_view(), name='dashboard-stats'),
    path('adjust-rent/', AdjustRentView.as_view(), name='adjust-rent'),
    
    # Other endpoints
    path('update-reminder-preferences/', UpdateReminderPreferencesView.as_view(), name='update-reminder-preferences'),
    path('available-units/', LandlordAvailableUnitsView.as_view(), name='available-units'),  # Changed from 'landlord-available-units'
]
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status
from accounts.serializers import (
    PropertySerializer,
    UnitSerializer,
    UnitNumberSerializer,
    UserSerializer,
    PasswordResetSerializer,
    PasswordResetConfirmSerializer,
    ReminderPreferencesSerializer,
    AvailableUnitsSerializer,
)
from rest_framework.permissions import IsAuthenticated
from django.core.cache import cache
from .models import Property, Unit, CustomUser, Subscription, UnitType
from payments.models import Payment
from .permissions import IsLandlord, IsTenant, IsSuperuser, HasActiveSubscription
import logging

logger = logging.getLogger(__name__)

from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.db.models import Count, Sum, Q
from django.utils import timezone
from datetime import timedelta
from decimal import Decimal

# accounts/views.py
from rest_framework_simplejwt.views import TokenObtainPairView
from .serializers import MyTokenObtainPairSerializer
from .serializers import UnitTypeSerializer

class MyTokenObtainPairView(TokenObtainPairView):
    serializer_class = MyTokenObtainPairSerializer


class UnitTypeListCreateView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        unit_types = request.user.unit_types.all()
        serializer = UnitTypeSerializer(unit_types, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = UnitTypeSerializer(data=request.data)
        if serializer.is_valid():
            unit_type = serializer.save(landlord=request.user)

            # Automatically create units based on the unit_count
            unit_count = int(request.data.get('unit_count', 1))
            property_id = request.data.get('property_id')
            
            if property_id and unit_count > 0:
                try:
                    property_obj = Property.objects.get(id=property_id, landlord=request.user)
                    self.create_units_for_unit_type(property_obj, unit_type, unit_count)
                except Property.DoesNotExist:
                    return Response({"error": "Property not found or you do not have permission"}, status=404)
            
            return Response(serializer.data, status=201)
        return Response(serializer.errors, status=400)
    
    def create_units_for_unit_type(self, property_obj, unit_type, unit_count):
        """Create multiple units for a given unit type"""
        # Get existing units to determine next unit number
        existing_units = Unit.objects.filter(property_obj=property_obj)
        last_unit = existing_units.order_by('-unit_number').first()

        if last_unit and last_unit.unit_number.isdigit():
            start_number = int(last_unit.unit_number) + 1
        else:
            start_number = 1

        units_created = []
        for i in range(unit_count):
            unit_number = start_number + i
            unit_code = f"U-{property_obj.id}-{unit_type.name.replace(' ', '-')}-{unit_number}"

            unit = Unit.objects.create(
                property_obj=property_obj,
                unit_code=unit_code,
                unit_number=str(unit_number),
                unit_type=unit_type,
                is_available=True,
                rent=unit_type.rent,
                deposit=unit_type.deposit,
            )
            units_created.append(unit)

        # Invalidate caches after creating units
        cache.delete(f"landlord:{unit_type.landlord.id}:properties")
        cache.delete(f"property:{property_obj.id}:units")

        return units_created


class LandlordDashboardStatsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        landlord = request.user

        # Total active tenants: tenants assigned to units of this landlord and active
        total_active_tenants = CustomUser.objects.filter(
            user_type='tenant',
            is_active=True,
            unit__property_obj__landlord=landlord
        ).distinct().count()

        # Total units available
        total_units_available = Unit.objects.filter(
            property_obj__landlord=landlord,
            is_available=True
        ).count()

        # Total units occupied
        total_units_occupied = Unit.objects.filter(
            property_obj__landlord=landlord,
            is_available=False
        ).count()

        # Monthly revenue: sum of successful rent payments in the current month for this landlord
        now = timezone.now()
        start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        monthly_revenue_agg = Payment.objects.filter(
            unit__property_obj__landlord=landlord,
            payment_type='rent',
            status='Success',
            transaction_date__gte=start_of_month,
            transaction_date__lte=now
        ).aggregate(total=Sum('amount'))
        monthly_revenue = monthly_revenue_agg['total'] or 0

        data = {
            "total_active_tenants": total_active_tenants,
            "total_units_available": total_units_available,
            "total_units_occupied": total_units_occupied,
            "monthly_revenue": float(monthly_revenue),
        }

        return Response(data)


class UnitTypeDetailView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get_object(self, pk, user):
        return UnitType.objects.get(id=pk, landlord=user)

    def get(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            serializer = UnitTypeSerializer(ut)
            return Response(serializer.data)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)

    def put(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            serializer = UnitTypeSerializer(ut, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)

    def delete(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            ut.delete()
            return Response({"message": "UnitType deleted"}, status=200)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)


# Lists a single user (cached)
# View to get user details
class UserDetailView(APIView):
    permission_classes = [IsAuthenticated, HasActiveSubscription]

    def get(self, request, user_id):
        cache_key = f"user:{user_id}"
        user_data = cache.get(cache_key)

        if not user_data:
            try:
                user = CustomUser.objects.get(id=user_id)
                serializer = UserSerializer(user)
                user_data = serializer.data
                cache.set(cache_key, user_data, timeout=300)  # cache for 5 minutes
            except CustomUser.DoesNotExist:
                return Response({"error": "User not found"}, status=404)

        return Response(user_data)


# New admin view to list landlords and their subscription statuses (superuser only)
class AdminLandlordSubscriptionStatusView(APIView):
    permission_classes = [IsAuthenticated, IsSuperuser]

    def get(self, request):
        landlords = CustomUser.objects.filter(user_type='landlord')
        data = []
        for landlord in landlords:
            subscription = getattr(landlord, 'subscription', None)
            status = 'Subscribed' if subscription and subscription.is_active() else 'Inactive or None'
            data.append({
                'landlord_id': landlord.id,
                'email': landlord.email,
                'name': landlord.full_name,
                'subscription_plan': subscription.plan if subscription else 'None',
                'subscription_status': status,
                'expiry_date': subscription.expiry_date if subscription else None,
            })
        return Response(data)


# Lists all tenants (cached)
# View to list all tenants (landlord only)
class UserListView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        cache_key = "tenants:list"
        tenants_data = cache.get(cache_key)

        if not tenants_data:
            tenants = CustomUser.objects.filter(user_type="tenant")
            serializer = UserSerializer(tenants, many=True)
            tenants_data = serializer.data
            cache.set(cache_key, tenants_data, timeout=300)

        return Response(tenants_data)


# Create a new user (invalidate cache)
# View to create a new user Landlord or Tenant
class UserCreateView(APIView):
    def post(self, request):
        print("Signup request received:", request.data)  # Debug logging
        
        serializer = UserSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            print(f"User created successfully: {user.email}, ID: {user.id}")  # Debug logging

            # Landlord onboarding: optionally auto-create properties and units if provided
            if user.user_type == 'landlord':
                # Expect optional 'properties' array in request.data, each item: {name, city, state, unit_count, vacant_units}
                properties = request.data.get('properties')
                from .models import Property, Unit, UnitType
                import uuid

                if properties and isinstance(properties, list):
                    for prop in properties:
                        name = prop.get('name') or f"Property-{uuid.uuid4().hex[:6].upper()}"
                        city = prop.get('city', '')
                        state = prop.get('state', '')
                        unit_count = int(prop.get('unit_count', 0))
                        p = Property.objects.create(landlord=user, name=name, city=city, state=state, unit_count=unit_count)

                        # Create at least one unit if unit_count > 0
                        for i in range(1, unit_count + 1):
                            unit_number = str(i)
                            unit_code = f"U-{p.id}-{i}"
                            # Determine vacancy status based on optional vacant_units or default all vacant
                            vacant_units = int(prop.get('vacant_units', unit_count))
                            is_available = i <= vacant_units

                            # Optionally link to a unit_type if provided via name
                            unit_type_obj = None
                            unit_type_name = prop.get('unit_type')
                            if unit_type_name:
                                unit_type_obj, _ = UnitType.objects.get_or_create(landlord=user, name=unit_type_name)

                            Unit.objects.create(
                                property_obj=p,
                                unit_code=unit_code,
                                unit_number=unit_number,
                                unit_type=unit_type_obj,
                                is_available=is_available,
                                rent=unit_type_obj.rent if unit_type_obj else 0,
                                deposit=unit_type_obj.deposit if unit_type_obj else 0,
                            )

            # Tenant created: attempt to assign unit if landlord_code and unit_code provided
            if user.user_type == "tenant":
                cache.delete("tenants:list")
                landlord_code = request.data.get('landlord_code')
                unit_code = request.data.get('unit_code')
                if landlord_code and unit_code:
                    try:
                        landlord = CustomUser.objects.get(landlord_code=landlord_code, user_type='landlord')
                        unit = Unit.objects.get(unit_code=unit_code, property_obj__landlord=landlord)
                        # Check for deposit payments
                        from payments.models import Payment
                        deposit_payments = Payment.objects.filter(
                            tenant=user,
                            unit=unit,
                            payment_type='deposit',
                            status='Success',
                            amount__gte=unit.deposit
                        )
                        if deposit_payments.exists():
                            unit.tenant = user
                            unit.is_available = False
                            unit.save()
                        else:
                            # leave unassigned; frontend should request deposit
                            pass
                    except CustomUser.DoesNotExist:
                        # landlord not found; ignore
                        pass
                    except Unit.DoesNotExist:
                        pass

            return Response(serializer.data, status=201)
        else:
            print("Serializer errors:", serializer.errors)  # Debug logging
            return Response(serializer.errors, status=400)


# Create a new property (invalidate landlord cache)
# View to create a new property (landlord only)
PLAN_LIMITS = {
    "free": 2,         # trial landlords can only create 2 properties
    "starter": 3,      # starter (up to 10 units) -> small number of properties
    "basic": 10,       # basic (10-50 units)
    "professional": 25,# professional (50-100 units)
    "onetime": None,   # unlimited
}

class CreatePropertyView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        logger.info(f"CreatePropertyView: User {request.user.id} attempting to create property")
        user = request.user

        # Fetch subscription
        try:
            subscription = Subscription.objects.get(user=user)
            logger.info(f"Subscription found: {subscription.plan}")
        except Subscription.DoesNotExist:
            logger.error(f"No subscription found for user {user.id}")
            return Response({"error": "No active subscription found."}, status=403)

        plan = subscription.plan.lower()

        # Check if subscription is active
        if not subscription.is_active():
            logger.warning(f"Subscription expired for user {user.id}")
            return Response({"error": "Your subscription has expired. Please renew or upgrade."}, status=403)

        # Get plan limit
        max_properties = PLAN_LIMITS.get(plan)
        if max_properties is None and plan != "onetime":
            return Response({"error": f"Unknown plan type: {plan}"}, status=400)

        # Count current properties
        current_count = Property.objects.filter(landlord=user).count()
        logger.info(f"Current properties count: {current_count}, max: {max_properties}")
        if plan != "onetime" and current_count >= max_properties:
            return Response({
                "error": f"Your current plan ({plan}) allows a maximum of {max_properties} properties. Upgrade to add more."
            }, status=403)

        # Proceed with creation
        serializer = PropertySerializer(data=request.data)
        if serializer.is_valid():
            logger.info(f"Serializer valid, saving property for user {user.id}")
            property = serializer.save(landlord=user)
            try:
                cache.delete(f"landlord:{user.id}:properties")  # clear cache if you're caching landlord properties
                logger.info(f"Cache cleared for user {user.id}")
            except Exception as e:
                logger.warning(f"Cache delete failed: {e}")
            logger.info(f"Property created successfully: {property.id}")
            return Response(serializer.data, status=201)

        logger.error(f"Serializer errors: {serializer.errors}")
        return Response(serializer.errors, status=400)

# List landlord properties (cached)
class LandlordPropertiesView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        cache_key = f"landlord:{request.user.id}:properties"
        properties_data = cache.get(cache_key)

        if not properties_data:
            properties = Property.objects.filter(landlord=request.user)
            serializer = PropertySerializer(properties, many=True)
            properties_data = serializer.data
            cache.set(cache_key, properties_data, timeout=300)

        return Response(properties_data)


# Create a new unit (invalidate landlord cache)
class CreateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        serializer = UnitSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            unit = serializer.save()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{unit.property_obj.id}:units")
            return Response(serializer.data, status=201)
        return Response(serializer.errors, status=400)


# List units of a property (cached)
class PropertyUnitsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request, property_id):
        cache_key = f"property:{property_id}:units"
        units_data = cache.get(cache_key)

        if not units_data:
            try:
                property = Property.objects.get(id=property_id, landlord=request.user)
                units = Unit.objects.filter(property_obj=property)
                serializer = UnitSerializer(units, many=True)
                units_data = serializer.data
                cache.set(cache_key, units_data, timeout=300)
            except Property.DoesNotExist:
                return Response(
                    {"error": "Property not found or you do not have permission"},
                    status=404,
                )

        return Response(units_data)


# Assign tenant to unit (invalidate cache)
class AssignTenantView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    @method_decorator(csrf_exempt)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

    def post(self, request, unit_id, tenant_id):
        logger.info(f"AssignTenantView: Landlord {request.user.id} attempting to assign tenant {tenant_id} to unit {unit_id}")

        try:
            # Validate unit exists and belongs to landlord
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            logger.info(f"Unit found: {unit.unit_code}, available: {unit.is_available}")

            # Validate unit is available
            if not unit.is_available:
                logger.warning(f"Unit {unit_id} is not available for assignment")
                return Response({
                    "error": "Unit is not available for assignment",
                    "status": "failed"
                }, status=400)

            # Validate tenant exists and is a tenant
            tenant = CustomUser.objects.get(id=tenant_id, user_type="tenant")
            logger.info(f"Tenant found: {tenant.full_name} (ID: {tenant.id})")

            # Check if tenant already has a unit assigned
            existing_unit = Unit.objects.filter(tenant=tenant).first()
            if existing_unit:
                logger.warning(f"Tenant {tenant_id} already has unit {existing_unit.id} assigned")
                return Response({
                    "error": f"Tenant already has unit {existing_unit.unit_number} assigned",
                    "status": "failed"
                }, status=400)

            # CHECK IF DEPOSIT IS PAID BEFORE ASSIGNMENT
            from payments.models import Payment
            deposit_paid = Payment.objects.filter(
                tenant=tenant,
                unit=unit,
                payment_type='deposit',
                status='Success',
                amount__gte=unit.deposit
            ).exists()
            
            if not deposit_paid:
                logger.warning(f"Tenant {tenant_id} has not paid deposit for unit {unit_id}")
                return Response({
                    "error": "Tenant must pay deposit before being assigned to unit",
                    "status": "failed"
                }, status=400)

            # If deposit is paid, assign tenant immediately
            unit.tenant = tenant
            unit.is_available = False
            unit.save()

            # Invalidate caches
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{unit.property_obj.id}:units")

            logger.info(f"âœ… Tenant {tenant.full_name} assigned to unit {unit.unit_number}")

            return Response({
                'message': f'Tenant {tenant.full_name} successfully assigned to unit {unit.unit_number}',
                'status': 'success'
            }, status=200)

        except Unit.DoesNotExist:
            logger.error(f"Unit {unit_id} not found or not owned by landlord {request.user.id}")
            return Response({
                "error": "Unit not found or you do not have permission",
                "status": "failed"
            }, status=404)
        except CustomUser.DoesNotExist:
            logger.error(f"Tenant {tenant_id} not found or invalid user type")
            return Response({
                "error": "Tenant not found or invalid user type",
                "status": "failed"
            }, status=404)
        except Exception as e:
            logger.error(f"Unexpected error in AssignTenantView: {str(e)}")
            return Response({
                "error": "An unexpected error occurred",
                "status": "failed"
            }, status=500)


# Password reset
class PasswordResetView(APIView):
    def post(self, request):
        serializer = PasswordResetSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(
                {"message": "Password reset email sent."}, status=status.HTTP_200_OK
            )
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
# Update property
class UpdatePropertyView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def put(self, request, property_id):
        try:
            property = Property.objects.get(id=property_id, landlord=request.user)
            serializer = PropertySerializer(property, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"landlord:{request.user.id}:properties")
                cache.delete(f"property:{property_id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Property.DoesNotExist:
            return Response({"error": "Property not found or you do not have permission"}, status=404)

    def delete(self, request, property_id):
        try:
            property = Property.objects.get(id=property_id, landlord=request.user)
            property.delete()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{property_id}:units")
            return Response({"message": "Property deleted successfully."}, status=200)
        except Property.DoesNotExist:
            return Response({"error": "Property not found or you do not have permission"}, status=404)

# Update unit
class UpdateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def put(self, request, unit_id):
        try:
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            serializer = UnitSerializer(unit, data=request.data, partial=True, context={'request': request})
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"landlord:{request.user.id}:properties")
                cache.delete(f"property:{unit.property_obj.id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Unit.DoesNotExist:
            return Response({"error": "Unit not found or you do not have permission"}, status=404)

    def delete(self, request, unit_id):
        try:
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            property_id = unit.property_obj.id
            unit.delete()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{property_id}:units")
            return Response({"message": "Unit deleted successfully."}, status=200)
        except Unit.DoesNotExist:
            return Response({"error": "Unit not found or you do not have permission"}, status=404)


class TenantUpdateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsTenant]

    def put(self, request):
        try:
            unit = Unit.objects.get(tenant=request.user)
            serializer = UnitNumberSerializer(unit, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"property:{unit.property_obj.id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Unit.DoesNotExist:
            return Response({"error": "No unit assigned to you"}, status=404)

# Update user
class UpdateUserView(APIView):  
    permission_classes = [IsAuthenticated]

    def put(self, request, user_id):
        if request.user.id != user_id:
            return Response({"error": "You do not have permission to update this user."}, status=403)
        try:
            user = CustomUser.objects.get(id=user_id)
            serializer = UserSerializer(user, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"user:{user_id}")
                if user.user_type == "tenant":
                    cache.delete("tenants:list")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except CustomUser.DoesNotExist:
            return Response({"error": "User not found"}, status=404)

    def delete(self, request, user_id):
        if request.user.id != user_id:
            return Response({"error": "You do not have permission to delete this user."}, status=403)
        try:
            user = CustomUser.objects.get(id=user_id)
            user.delete()
            cache.delete(f"user:{user_id}")
            if user.user_type == "tenant":
                cache.delete("tenants:list")
            return Response({"message": "User deleted successfully."}, status=200)
        except CustomUser.DoesNotExist:
            return Response({"error": "User not found"}, status=404)


class AdjustRentView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        landlord = request.user
        adjustment_type = request.data.get('adjustment_type')  # 'percentage' or 'fixed'
        value = request.data.get('value')  # decimal, positive for increase, negative for decrease
        unit_type_id = request.data.get('unit_type_id')  # optional, if provided, adjust only units of this type

        logger.info(f"AdjustRentView POST: Landlord {landlord.id} adjusting rent, adjustment_type={adjustment_type}, value={value}, unit_type_id={unit_type_id}")

        if adjustment_type not in ['percentage', 'fixed']:
            return Response({"error": "adjustment_type must be 'percentage' or 'fixed'"}, status=400)

        try:
            value = Decimal(value)
        except (ValueError, TypeError):
            return Response({"error": "value must be a valid number"}, status=400)

        # Filter units
        units = Unit.objects.filter(property_obj__landlord=landlord)
        if unit_type_id:
            try:
                unit_type = UnitType.objects.get(id=unit_type_id, landlord=landlord)
                units = units.filter(unit_type=unit_type)
            except UnitType.DoesNotExist:
                return Response({"error": "UnitType not found or not owned by you"}, status=404)

        updated_count = 0
        for unit in units:
            old_rent = unit.rent
            if adjustment_type == 'percentage':
                new_rent = old_rent * (Decimal(1) + value / Decimal(100))
            else:  # fixed
                new_rent = old_rent + value
            # Ensure rent doesn't go negative
            new_rent = max(Decimal(0), new_rent)
            unit.rent = new_rent
            unit.save()  # This will update rent_remaining
            updated_count += 1

        logger.info(f"AdjustRentView POST: Rent adjusted for {updated_count} units by landlord {landlord.id}")

        # Invalidate caches
        cache.delete(f"landlord:{landlord.id}:properties")
        # Also invalidate rent_summary cache
        from payments.views import RentSummaryView
        cache.delete(f"rent_summary:{landlord.id}")

        return Response({"message": f"Rent adjusted for {updated_count} units successfully"})

    def put(self, request):
        landlord = request.user
        new_rent = request.data.get('new_rent')
        unit_type_id = request.data.get('unit_type_id')  # optional

        logger.info(f"AdjustRentView PUT: Landlord {landlord.id} setting new rent, new_rent={new_rent}, unit_type_id={unit_type_id}")

        if new_rent is None:
            return Response({"error": "new_rent is required"}, status=400)

        try:
            new_rent = Decimal(new_rent)
        except (ValueError, TypeError):
            return Response({"error": "new_rent must be a valid number"}, status=400)

        units = Unit.objects.filter(property_obj__landlord=landlord)
        if unit_type_id:
            try:
                unit_type = UnitType.objects.get(id=unit_type_id, landlord=landlord)
                units = units.filter(unit_type=unit_type)
            except UnitType.DoesNotExist:
                return Response({"error": "UnitType not found or not owned by you"}, status=404)

        updated_count = 0
        for unit in units:
            unit.rent = new_rent
            unit.save()
            updated_count += 1

        logger.info(f"AdjustRentView PUT: Rent set to {new_rent} for {updated_count} units by landlord {landlord.id}")

        # Invalidate caches
        cache.delete(f"landlord:{landlord.id}:properties")
        from payments.views import RentSummaryView
        cache.delete(f"rent_summary:{landlord.id}")

        return Response({"message": f"Rent set to {new_rent} for {updated_count} units successfully"})

# View to check subscription status (landlord only)
class SubscriptionStatusView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord]

    def get(self, request):
        user = request.user
        try:
            subscription = Subscription.objects.get(user=user)
            data = {
                "plan": subscription.plan,
                "is_active": subscription.is_active(),
                "expiry_date": subscription.expiry_date,
                "status": "Subscribed" if subscription.is_active() else "Inactive"
            }
        except Subscription.DoesNotExist:
            data = {"status": "No subscription found"}
        return Response(data)

# View to update landlord's Mpesa till number (landlord only)
class UpdateTillNumberView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def patch(self, request):
        user = request.user
        till_number = request.data.get('mpesa_till_number')
        if not till_number:
            return Response({"error": "mpesa_till_number is required"}, status=400)

        user.mpesa_till_number = till_number
        user.save()
        return Response({"message": "Till number updated successfully", "mpesa_till_number": till_number})

    def put(self, request):
        return self.patch(request)


# Endpoint to get or update the currently authenticated user
class MeView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        serializer = UserSerializer(request.user)
        return Response(serializer.data)

    def patch(self, request):
        serializer = UserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            # invalidate cache for this user
            cache.delete(f"user:{request.user.id}")
            return Response(serializer.data)
        return Response(serializer.errors, status=400)

    def put(self, request):
        return self.patch(request)


# View to update tenant reminder preferences
class UpdateReminderPreferencesView(APIView):
    permission_classes = [IsAuthenticated, IsTenant]

    def patch(self, request):
        serializer = ReminderPreferencesSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)


# Password reset confirm view
class PasswordResetConfirmView(APIView):
    def post(self, request):
        serializer = PasswordResetConfirmSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "Password has been reset successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


# View to list available units for landlords to share with tenants
class LandlordAvailableUnitsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        units = Unit.objects.filter(property_obj__landlord=request.user, is_available=True)
        serializer = AvailableUnitsSerializer(units, many=True)
        return Response(serializer.data)


# New endpoint to log requests and return a welcome message
class WelcomeView(APIView):
    def get(self, request):
        logger.info(f"Request received: {request.method} {request.path}")
        return Response({"message": "Welcome to the Makau Rentals API!"})
"""
Django settings for app project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
from datetime import timedelta
from decouple import config
import os
# For scheduling automatic sending messages to tenants every month
from celery.schedules import crontab

import os

# Auto create superuser on startup
DJANGO_SUPERUSER_USERNAME = os.environ.get('DJANGO_SUPERUSER_USERNAME')
DJANGO_SUPERUSER_EMAIL = os.environ.get('DJANGO_SUPERUSER_EMAIL')
DJANGO_SUPERUSER_PASSWORD = os.environ.get('DJANGO_SUPERUSER_PASSWORD')
DJANGO_SUPERUSER_FULL_NAME = os.environ.get('DJANGO_SUPERUSER_FULL_NAME', 'GEORGE MWANGI')

CELERY_BEAT_SCHEDULE = {
    # Tenants get notified daily at 9 AM
    "daily-rent-due-check": {
        "task": "app.tasks.notify_due_rent_task",
        "schedule": crontab(hour=9, minute=0),
    },
    # Landlords get a daily summary at 9:30 AM
    "daily-landlord-summary": {
        "task": "app.tasks.landlord_summary_task",
        "schedule": crontab(hour=9, minute=30),
    },
    # Deadline reminders at 10 AM
    "daily-deadline-reminders": {
        "task": "app.tasks.deadline_reminder_task",
        "schedule": crontab(hour=10, minute=0),
    },
}


# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Ensure logs directory exists
logs_dir = BASE_DIR / 'logs'
logs_dir.mkdir(parents=True, exist_ok=True)


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = config('DEBUG', default=False, cast=bool)

ALLOWED_HOSTS = ['*']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    #dependencies
    'rest_framework',
    'rest_framework_simplejwt',
    "django_crontab",
    'corsheaders',
    #local apps
    'accounts',
    'communication',
    'payments',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'app.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# for CORS handling 
# TODO: Update CORS settings for production use
CORS_ALLOW_ALL_ORIGINS = True

WSGI_APPLICATION = 'app.wsgi.application'

AUTH_USER_MODEL = 'accounts.CustomUser'

#Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# Commented out for testing - PostgreSQL configuration
DATABASES = {
     'default': {
         'ENGINE': 'django.db.backends.postgresql',
         'NAME': config('POSTGRES_DB'),
         'USER': config('POSTGRES_USER'),
         'PASSWORD': config('POSTGRES_PASSWORD'),
         'HOST': config('DB_HOST'),
         'PORT': '5432',
    }
 }

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
}
# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')  # or your preferred path
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'


# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
}

# Cache Configuration - Using LocMem for simplicity, no external Redis needed
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.locmem.LocMemCache",
    }
}

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO',
    },
    'loggers': {
        'accounts.views': {
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# Email Configuration
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
# EMAIL_HOST = 'smtp.gmail.com'
# EMAIL_PORT = 587
# EMAIL_USE_TLS = True
# TODO: Use environment variables or Django decouple to manage sensitive info
# TODO: Creaete a dedicated email for the application
# EMAIL_HOST_USER = config('EMAIL_HOST_USER')
# EMAIL_HOST_PASSWORD = config('EMAIL_HOST_PASSWORD')

# Mpesa Configuration
# TODO: Update these settings with your actual Mpesa credentials
MPESA_ENV = "sandbox"  # or "production"
MPESA_CONSUMER_KEY = config('MPESA_CONSUMER_KEY', default='')
MPESA_CONSUMER_SECRET = config('MPESA_CONSUMER_SECRET', default='')
MPESA_SHORTCODE = config('MPESA_SHORTCODE', default='')
MPESA_PASSKEY = config('MPESA_PASSKEY', default='')
MPESA_INITIATOR_NAME = config('MPESA_INITIATOR_NAME', default='')  # For B2C payments
MPESA_SECURITY_CREDENTIAL = config('MPESA_SECURITY_CREDENTIAL', default='')  # For B2C payments
MPESA_CALLBACK_URL = config('MPESA_CALLBACK_URL', default='')
# Provide explicit callback URLs expected by payment views. If not set, fall back to MPESA_CALLBACK_URL
MPESA_RENT_CALLBACK_URL = config('MPESA_RENT_CALLBACK_URL', default=MPESA_CALLBACK_URL)
MPESA_SUBSCRIPTION_CALLBACK_URL = config('MPESA_SUBSCRIPTION_CALLBACK_URL', default=MPESA_CALLBACK_URL)
MPESA_DEPOSIT_CALLBACK_URL = config('MPESA_DEPOSIT_CALLBACK_URL', default=MPESA_CALLBACK_URL)
# B2C callback URLs
MPESA_B2C_RESULT_URL = config('MPESA_B2C_RESULT_URL', default=MPESA_CALLBACK_URL)
MPESA_B2C_TIMEOUT_URL = config('MPESA_B2C_TIMEOUT_URL', default=MPESA_CALLBACK_URL)

# Logging Configuration - Enhanced for payment callbacks
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'logs', 'payments.log'),
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'accounts.views': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        'payments.views': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}
# Celery configuration
REDIS_URL = config('REDIS_URL', default='redis://redis:6379/0')
CELERY_BROKER_URL = REDIS_URL
CELERY_RESULT_BACKEND = REDIS_URL


# TODO: Run celery using the following commands -> celery -A your_project worker -l info
# celery -A your_project beat -l info


# Frontend URL for password reset links
FRONTEND_URL = config('FRONTEND_URL', default='http://localhost:3000')

# Optional: S3 storage for uploaded id_document files via django-storages
# To enable, set USE_S3=True and provide the AWS_* env vars. Install: pip install django-storages[boto3]
USE_S3 = config('USE_S3', default=False, cast=bool)
if USE_S3:
    INSTALLED_APPS.append('storages')
    AWS_ACCESS_KEY_ID = config('AWS_ACCESS_KEY_ID')
    AWS_SECRET_ACCESS_KEY = config('AWS_SECRET_ACCESS_KEY')
    AWS_STORAGE_BUCKET_NAME = config('AWS_STORAGE_BUCKET_NAME')
    AWS_S3_REGION_NAME = config('AWS_S3_REGION_NAME', default=None)
    AWS_S3_CUSTOM_DOMAIN = f"{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com"
    AWS_DEFAULT_ACL = None

    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
    MEDIA_URL = f"https://{AWS_S3_CUSTOM_DOMAIN}/media/"
else:
    MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
    MEDIA_URL = '/media/'

from rest_framework import serializers
from .models import Report
from accounts.models import CustomUser, Unit, Property

class ReportSerializer(serializers.ModelSerializer):
    tenant = serializers.PrimaryKeyRelatedField(read_only=True, default=serializers.CurrentUserDefault())
    unit = serializers.PrimaryKeyRelatedField(queryset=Unit.objects.all())

    class Meta:
        model = Report
        fields = [
            'id',
            'tenant',
            'unit',
            'issue_category',
            'priority_level',
            'issue_title',
            'description',
            'created_at',
            'status',
        ]
        read_only_fields = ['id', 'tenant', 'created_at', 'status']

    def validate_unit(self, value):
        # Ensure the unit belongs to the tenant submitting the report
        user = self.context['request'].user
        if value.tenant != user:
            raise serializers.ValidationError("This unit is not assigned to the current tenant.")
        return value

    def create(self, validated_data):
        validated_data['tenant'] = self.context['request'].user
        return super().create(validated_data)

class UpdateReportStatusSerializer(serializers.ModelSerializer):
    class Meta:
        model = Report
        fields = ['status']
        read_only_fields = []

class SendEmailSerializer(serializers.Serializer):
    subject = serializers.CharField(max_length=255)
    message = serializers.CharField()
    tenants = serializers.ListField(
        child=serializers.PrimaryKeyRelatedField(queryset=CustomUser.objects.filter(user_type='tenant')),
        required=False,
        allow_empty=True
    )
    send_to_all = serializers.BooleanField(default=False)

    def validate(self, data):
        if not data.get('send_to_all') and not data.get('tenants'):
            raise serializers.ValidationError("Either provide a list of tenants or set send_to_all to True.")
        if data.get('send_to_all') and data.get('tenants'):
            raise serializers.ValidationError("Cannot specify tenants when send_to_all is True.")
        return data

    def validate_tenants(self, value):
        # Ensure all tenants belong to the landlord's properties
        request = self.context.get('request')
        if request and request.user.user_type == 'landlord':
            landlord_properties = Property.objects.filter(landlord=request.user)
            tenant_units = Unit.objects.filter(property_obj__in=landlord_properties, tenant__in=value)
            valid_tenants = set(tenant_units.values_list('tenant', flat=True))
            if set(t.id for t in value) != valid_tenants:
                raise serializers.ValidationError("Some tenants do not belong to your properties.")
        return value
# services/messaging.py
from django.conf import settings
from django.core.mail import send_mail


def send_bulk_emails(tenants):
    """
    Send rent reminder emails to a list of tenants.
    Each tenant receives a personalized message with their outstanding balance.
    """
    for tenant in tenants:
        subject = "Rent Payment Reminder"
        message = (
            f"Hello {tenant.full_name},\n\n"
            f"This is a reminder to pay your rent.\n"
            f"Outstanding balance: KES {tenant.unit.rent_remaining}."
        )
        try:
            send_mail(subject, message, settings.EMAIL_HOST_USER, [tenant.email])
        except Exception as e:
            print(f"Email failed for {tenant.email}: {e}")





def send_deadline_reminder_emails(tenants):
    """
    Send rent deadline reminder emails to a list of tenants.
    Each email includes the payment deadline date, outstanding balance, and login link.
    """
    for tenant in tenants:
        unit = tenant.unit
        subject = "Rent Payment Deadline Reminder"
        login_link = f"{settings.FRONTEND_URL}/login"
        message = (
            f"Hello {tenant.full_name},\n\n"
            f"This is a reminder that your rent payment is due on {unit.rent_due_date}.\n"
            f"Outstanding balance: KES {unit.rent_remaining}.\n\n"
            f"Please log in to your account to make the payment: {login_link}\n\n"
            "Thank you,\n"
            "Makau Rentals Team"
        )
        try:
            send_mail(subject, message, settings.EMAIL_HOST_USER, [tenant.email])
        except Exception as e:
            print(f"Email failed for {tenant.email}: {e}")


def send_deadline_reminders():
    """
    Send reminders to tenants based on their custom reminder preferences.
    """
    from datetime import timedelta
    from django.utils import timezone
    from accounts.models import CustomUser

    today = timezone.now().date()
    tenants_to_remind = []

    # Get all tenants with units and outstanding rent
    tenants = CustomUser.objects.filter(
        user_type="tenant",
        unit__isnull=False,
        unit__rent_remaining__gt=0
    ).select_related('unit')

    for tenant in tenants:
        unit = tenant.unit
        if tenant.reminder_mode == 'days_before':
            reminder_date = unit.rent_due_date - timedelta(days=tenant.reminder_value)
            if reminder_date == today:
                tenants_to_remind.append(tenant)
        elif tenant.reminder_mode == 'fixed_day':
            if today.day == tenant.reminder_value:
                # Optionally, check if due date is within a reasonable period, e.g., next 30 days
                if unit.rent_due_date and unit.rent_due_date >= today and (unit.rent_due_date - today).days <= 30:
                    tenants_to_remind.append(tenant)

    if tenants_to_remind:
        send_deadline_reminder_emails(tenants_to_remind)

# TODO:
# - This module handles sending bulk emails to tenants for rent reminders.
# - It uses Django's send_mail for email notifications.
# - The send_deadline_reminders() function is scheduled via Celery Beat to run automatically.

def send_report_email(report):
    """
    Send an email to the landlord when a new report is created.
    """
    landlord = report.unit.property_obj.landlord
    subject = f"New Issue Report: {report.issue_title}"
    issue_url = f"{settings.FRONTEND_URL}/reports/{report.id}"
    message = (
        f"Hello {landlord.full_name},\n\n"
        f"A new issue report has been submitted by tenant {report.tenant.full_name}.\n\n"
        f"Unit Number: {report.unit.unit_number}\n"
        f"Issue Category: {report.issue_category}\n"
        f"Priority Level: {report.priority_level}\n"
        f"Issue Title: {report.issue_title}\n"
        f"Description:\n{report.description}\n\n"
        f"To resolve the issue, please visit: {issue_url}\n\n"
        "Best regards,\n"
        "Makau Rentals System"
    )
    try:
        send_mail(subject, message, settings.EMAIL_HOST_USER, [landlord.email])
    except Exception as e:
        print(f"Failed to send report email: {e}")


def send_landlord_email(subject, message, tenants):
    """
    Send a custom email from landlord to a list of tenants.
    """
    recipient_emails = [tenant.email for tenant in tenants]
    try:
        send_mail(subject, message, settings.EMAIL_HOST_USER, recipient_emails)
    except Exception as e:
        print(f"Failed to send landlord email: {e}")
from django.urls import path
from .views import (
    CreateReportView,
    OpenReportsView,
    UrgentReportsView,
    InProgressReportsView,
    ResolvedReportsView,
    UpdateReportStatusView,
    SendEmailView,
)

urlpatterns = [
    # Create a new report (POST)
    path('reports/create/', CreateReportView.as_view(), name='create-report'),  # Added /create/

    # List open reports for the authenticated user (GET)
    path('reports/open/', OpenReportsView.as_view(), name='open-reports'),

    # List urgent reports for the authenticated user (GET)
    path('reports/urgent/', UrgentReportsView.as_view(), name='urgent-reports'),

    # List in-progress reports for the authenticated user (GET)
    path('reports/in-progress/', InProgressReportsView.as_view(), name='in-progress-reports'),

    # List resolved reports for the authenticated user (GET)
    path('reports/resolved/', ResolvedReportsView.as_view(), name='resolved-reports'),

    # Update the status of a specific report (PATCH/PUT)
    path('reports/<int:pk>/update-status/', UpdateReportStatusView.as_view(), name='update-report-status'),

    # Send email to tenants (POST)
    path('reports/send-email/', SendEmailView.as_view(), name='send-email'),  # Added /reports/ prefix
]

from django.db import models
from accounts.models import CustomUser, Unit

class Report(models.Model):
    ISSUE_CATEGORIES = [
        ('electrical', 'Electrical'),
        ('plumbing', 'Plumbing'),
        ('noise', 'Noise'),
        ('safety/violence', 'Safety/Violence'),
        ('wifi', 'WiFi'),
        ('maintenance', 'Maintenance'),
    ]

    PRIORITY_LEVELS = [
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('urgent', 'Urgent'),
    ]

    STATUS_CHOICES = [
        ('open', 'Open'),
        ('in_progress', 'In Progress'),
        ('resolved', 'Resolved'),
        ('closed', 'Closed'),
    ]

    tenant = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='reports')
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name='reports')
    issue_category = models.CharField(max_length=20, choices=ISSUE_CATEGORIES)
    priority_level = models.CharField(max_length=10, choices=PRIORITY_LEVELS)
    issue_title = models.CharField(max_length=255)
    description = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    status = models.CharField(max_length=15, choices=STATUS_CHOICES, default='open')

    def __str__(self):
        return f"Report by {self.tenant.full_name} - {self.issue_title}"
from rest_framework import permissions
from django.core.cache import cache
from accounts.models import CustomUser, Subscription

class IsTenantWithUnit(permissions.BasePermission):
    """
    Allows access only to tenants who have at least one assigned unit.
    """
    def has_permission(self, request, view):
        if not request.user.is_authenticated or request.user.user_type != 'tenant':
            return False
        
        # Check cache first
        cache_key = f"tenant_has_unit:{request.user.id}"
        has_unit = cache.get(cache_key)
        
        if has_unit is None:
            # Check if tenant has any units assigned (OneToOneField so use hasattr)
            has_unit = hasattr(request.user, 'unit') and request.user.unit is not None
            cache.set(cache_key, has_unit, timeout=300)  # Cache for 5 minutes
        
        return has_unit

class IsLandlordWithActiveSubscription(permissions.BasePermission):
    """
    Allows access only to landlords with active subscriptions.
    """
    def has_permission(self, request, view):
        if not request.user.is_authenticated or request.user.user_type != 'landlord':
            return False
        
        # Use cache to avoid repeated database queries
        cache_key = f"subscription_status:{request.user.id}"
        has_active_sub = cache.get(cache_key)
        
        if has_active_sub is None:
            try:
                subscription = Subscription.objects.get(user=request.user)
                has_active_sub = subscription.is_active()
            except Subscription.DoesNotExist:
                has_active_sub = False
            cache.set(cache_key, has_active_sub, timeout=300)  # Cache for 5 minutes
        
        return has_active_sub
import requests
from django.conf import settings
from requests.auth import HTTPBasicAuth
import logging
import base64
import datetime

logger = logging.getLogger(__name__)

def generate_access_token():
    """
    Generate M-Pesa access token with error handling.
    Returns token string or raises ValueError on failure.
    """
    if not settings.MPESA_CONSUMER_KEY or not settings.MPESA_CONSUMER_SECRET:
        raise ValueError("MPESA_CONSUMER_KEY and MPESA_CONSUMER_SECRET must be set in settings.")

    # Use sandbox or production URL based on env
    base_url = "https://sandbox.safaricom.co.ke" if settings.MPESA_ENV == "sandbox" else "https://api.safaricom.co.ke"
    url = f"{base_url}/oauth/v1/generate?grant_type=client_credentials"

    try:
        response = requests.get(
            url,
            auth=HTTPBasicAuth(settings.MPESA_CONSUMER_KEY, settings.MPESA_CONSUMER_SECRET),
            timeout=10  # Avoid hanging
        )
        response.raise_for_status()  # Raise on HTTP errors (e.g., 401 Unauthorized)

        data = response.json()
        token = data.get("access_token")
        if not token:
            raise ValueError(f"No access_token in response: {data}")

        logger.info("M-Pesa access token generated successfully.")
        return token

    except requests.exceptions.RequestException as e:
        logger.error(f"Failed to generate M-Pesa token: {e}")
        raise ValueError(f"Token generation failed: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected error generating token: {e}")
        raise ValueError(f"Token generation error: {str(e)}")

def initiate_b2c_payment(amount, recipient, payment_id, remarks="Rent disbursement"):
    """
    Initiate B2C payment to disburse funds to landlord.
    - amount: Amount to disburse (KES)
    - recipient: Landlord's phone number (254XXXXXXXXX format) or till number
    - payment_id: Reference for the payment
    - remarks: Description of the transaction
    Returns response dict or raises ValueError on failure.
    """
    if not settings.MPESA_CONSUMER_KEY or not settings.MPESA_CONSUMER_SECRET:
        raise ValueError("MPESA_CONSUMER_KEY and MPESA_CONSUMER_SECRET must be set in settings.")

    # Generate access token
    access_token = generate_access_token()

    # Use sandbox or production URL based on env
    base_url = "https://sandbox.safaricom.co.ke" if settings.MPESA_ENV == "sandbox" else "https://api.safaricom.co.ke"
    url = f"{base_url}/mpesa/b2c/v1/paymentrequest"

    timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
    password = base64.b64encode(
        (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode("utf-8")
    ).decode("utf-8")

    payload = {
        "InitiatorName": settings.MPESA_INITIATOR_NAME,  # Need to add to settings
        "SecurityCredential": settings.MPESA_SECURITY_CREDENTIAL,  # Need to add to settings
        "CommandID": "BusinessPayment",
        "Amount": str(amount),
        "PartyA": settings.MPESA_SHORTCODE,
        "PartyB": recipient,  # Can be phone number or till number
        "Remarks": remarks,
        "QueueTimeOutURL": settings.MPESA_B2C_TIMEOUT_URL,  # Need to add to settings
        "ResultURL": settings.MPESA_B2C_RESULT_URL,  # Need to add to settings
        "Occasion": f"Payment {payment_id}"
    }

    headers = {"Authorization": f"Bearer {access_token}"}

    try:
        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response.raise_for_status()
        data = response.json()
        logger.info(f"B2C payment initiated: {data}")
        return data
    except requests.exceptions.RequestException as e:
        logger.error(f"B2C payment failed: {e}")
        raise ValueError(f"B2C payment error: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected B2C error: {e}")
        raise ValueError(f"B2C error: {str(e)}")
from django.db import models
from accounts.models import CustomUser, Unit, Subscription
from datetime import timedelta

class Payment(models.Model):
    PAYMENT_TYPES = [
        ('rent', 'Rent'),
        ('deposit', 'Deposit'),
    ]
    tenant = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        limit_choices_to={'user_type': 'tenant'},
        related_name='payments',
        null=True,
        blank=True
    )
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name='payments', null=True, blank=True)
    unit_type = models.ForeignKey('accounts.UnitType', on_delete=models.CASCADE, related_name='payments', null=True, blank=True)
    payment_type = models.CharField(max_length=10, choices=PAYMENT_TYPES, default='rent')
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    mpesa_receipt = models.CharField(max_length=50, blank=True, null=True)
    transaction_date = models.DateTimeField(auto_now_add=True)
    status = models.CharField(
        max_length=20,
        choices=[("Pending", "Pending"), ("Success", "Success"), ("Failed", "Failed")],
        default="Pending"
    )

    def __str__(self):
        unit_str = f"Unit {self.unit.unit_number}" if self.unit else "Deposit"
        return f"{self.tenant.email} - {unit_str} - KES {self.amount} ({self.status})"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)


class SubscriptionPayment(models.Model):
    user = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        null=True,
        blank=True
    )
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    mpesa_receipt_number = models.CharField(
        max_length=50,
        blank=True,  # Allow empty strings
        null=True,
        default=""
    )
    transaction_date = models.DateTimeField(auto_now_add=True)
    subscription_type = models.CharField(max_length=20, choices=Subscription.PLAN_CHOICES)
    status = models.CharField(
        max_length=20,
        choices=[("Pending", "Pending"), ("Success", "Success"), ("Failed", "Failed")],
        default="Pending"
    )

    class Meta:
        # Remove or modify the unique constraint to allow empty strings
        constraints = [
            models.UniqueConstraint(
                fields=['mpesa_receipt_number'],
                name='unique_mpesa_receipt',
                condition=~models.Q(mpesa_receipt_number='')  # Only enforce uniqueness for non-empty values
            )
        ]

    def __str__(self):
        return f"Subscription Payment {self.id} - {self.subscription_type}"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)

    def _get_plan_duration(self):
        durations = {
            "free": timedelta(days=60),
            "starter": timedelta(days=30),
            "basic": timedelta(days=30),
            "professional": timedelta(days=30),
            # "onetime" will be treated as lifetime (None) by the subscription logic
        }
        return durations.get(self.subscription_type, timedelta(days=30))
from rest_framework import serializers
from .models import Payment, SubscriptionPayment


class PaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Payment
        fields = '__all__'
        read_only_fields = ['transaction_date', 'status']


class SubscriptionPaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubscriptionPayment
        fields = '__all__'
        read_only_fields = ['transaction_date']
import base64
import datetime
import json
import requests
import csv
import time
from decimal import Decimal, InvalidOperation
from django.http import HttpResponse
from datetime import timedelta
from django.conf import settings
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import logging
from django.utils import timezone
from django.core.cache import cache
from django.shortcuts import get_object_or_404
from accounts.models import CustomUser, Subscription, Property, Unit, UnitType
# Removed require_subscription import as it's no longer used
from accounts.serializers import UnitTypeSerializer
from .models import Payment, SubscriptionPayment
from .generate_token import generate_access_token, initiate_b2c_payment
from rest_framework import generics, permissions
from .serializers import PaymentSerializer, SubscriptionPaymentSerializer
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.utils.decorators import method_decorator
from accounts.permissions import IsLandlord, HasActiveSubscription
# ------------------------------
# STK PUSH INITIATION (Tenant Rent Payment) - UPDATED
# ------------------------------
@csrf_exempt
def stk_push(request, unit_id):
    """
    Initiates an M-Pesa STK Push for a tenant's rent payment.
    """
    logger = logging.getLogger(__name__)

    # Check authentication first
    if not request.user.is_authenticated:
        return JsonResponse({"error": "Authentication required"}, status=401)

    if request.user.user_type != 'tenant':
        return JsonResponse({"error": "Only tenants can make rent payments"}, status=403)

    try:
        if request.method != 'POST':
            return JsonResponse({"error": "POST method required."}, status=405)

        # Parse JSON body
        try:
            body = json.loads(request.body.decode('utf-8'))
        except json.JSONDecodeError:
            return JsonResponse({"error": "Invalid JSON body."}, status=400)

        # Get amount from JSON data
        amount_str = body.get('amount')
        if not amount_str:
            return JsonResponse({"error": "Amount is required."}, status=400)

        try:
            amount = Decimal(amount_str)
        except InvalidOperation:
            return JsonResponse({"error": "Invalid amount format."}, status=400)
        
        # Rate limiting: Check if user has made too many requests
        rate_limit_key = f"stk_push_rate_limit:{request.user.id}"
        recent_requests = cache.get(rate_limit_key, 0)
        if recent_requests >= 5:  # Max 5 requests per minute
            return JsonResponse({"error": "Too many requests. Please try again later."}, status=429)
        
        # Update rate limit counter
        cache.set(rate_limit_key, recent_requests + 1, timeout=60)
        
        # REQUIRE tenant to be assigned to unit for rent payments
        try:
            unit = Unit.objects.get(id=unit_id, tenant=request.user)
        except Unit.DoesNotExist:
            return JsonResponse({"error": "Unit not found or you are not assigned to this unit. Please pay deposit first."}, status=404)
        
        # Validate amount
        if amount <= 0:
            return JsonResponse({"error": "Amount must be positive."}, status=400)
        
        # Allow any amount that's at least the rent (for testing)
        if amount < unit.rent:
            return JsonResponse({"error": f"Amount must be at least the monthly rent ({unit.rent})."}, status=400)
        
        # More generous maximum for testing
        max_amount = unit.rent * 24  # Allow up to 2 years rent for testing
        if amount > max_amount:
            return JsonResponse({"error": f"Amount cannot exceed two years' rent ({max_amount})."}, status=400)
        
        # Check for duplicate pending payment
        duplicate_key = f"pending_payment:{request.user.id}:{unit_id}"
        if cache.get(duplicate_key):
            return JsonResponse({"error": "A payment request is already pending for this unit."}, status=400)
        
        # Create a pending payment record
        payment = Payment.objects.create(
            tenant=request.user,
            unit=unit,
            amount=amount,
            status="Pending"
        )
        
        # Mark payment as pending in Redis (5-minute expiry)
        cache.set(duplicate_key, payment.id, timeout=300)
        
        # Check if tenant has paid deposit for this unit (REQUIRED)
        deposit_paid = Payment.objects.filter(
            tenant=request.user,
            unit=unit,
            payment_type='deposit',
            status='Success',
            amount__gte=unit.deposit
        ).exists()
        if not deposit_paid:
            return JsonResponse({"error": "You must pay the deposit for this unit before making rent payments."}, status=400)

        # Rest of the function remains the same...
        try:
            # Generate access token (with Redis caching and retry)
            access_token_cache_key = "mpesa_access_token"
            access_token = cache.get(access_token_cache_key)
            if not access_token:
                try:
                    access_token = generate_access_token()
                except Exception as e:
                    logger.error(f"Access token generation failed, retrying: {str(e)}")
                    # Retry once after a short delay
                    import time
                    time.sleep(1)
                    access_token = generate_access_token()
            # Cache access token for 55 minutes (MPESA tokens expire in 1 hour)
            cache.set(access_token_cache_key, access_token, timeout=3300)
        except Exception as e:
            logger.error(f"Access token generation failed after retry: {str(e)}")
            return JsonResponse({"error": "Payment service temporarily unavailable. Please try again later."}, status=503)
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        password = base64.b64encode(
            (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode("utf-8")
        ).decode("utf-8")
        
        # Always use central shortcode for rent payments
        business_shortcode = settings.MPESA_SHORTCODE
        
        # Build payload for Safaricom API
        payload = {
            "BusinessShortCode": business_shortcode,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": str(int(amount)),  # Ensure whole number for M-Pesa
            "PartyA": request.user.phone_number,
            "PartyB": business_shortcode,
            "PhoneNumber": request.user.phone_number,
            "CallBackURL": settings.MPESA_RENT_CALLBACK_URL,
            "AccountReference": str(payment.id),
            "TransactionDesc": f"Rent for Unit {unit.unit_number}"
        }
        
        headers = {"Authorization": f"Bearer {access_token}"}
        
        try:
            response = requests.post(
                "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest",
                json=payload,
                headers=headers,
                timeout=30
            )
            response.raise_for_status()
            response_data = response.json()
        except requests.exceptions.RequestException as e:
            # Don't fail the payment - mark it as pending for manual processing
            logger.error(f"M-Pesa API request failed: {str(e)}")
            return JsonResponse({
                "message": "Payment initiation received. Please check your phone to complete payment.",
                "payment_id": payment.id
            })
        except json.JSONDecodeError as e:
            logger.error(f"Invalid response from M-Pesa API: {str(e)}")
            return JsonResponse({
                "message": "Payment initiation received. Please check your phone to complete payment.",
                "payment_id": payment.id
            })
        
        if response_data.get("ResponseCode") == "0":
            # Return success immediately without waiting
            return JsonResponse({
                "message": "Payment initiated successfully. Please check your phone to complete payment.",
                "checkout_request_id": response_data.get("CheckoutRequestID"),
                "payment_id": payment.id
            })
        else:
            # M-Pesa returned an error but we don't fail the payment
            error_msg = response_data.get("ResponseDescription", "Unknown error")
            logger.error(f"M-Pesa STK push error: {error_msg}")
            return JsonResponse({
                "message": "Payment initiation received. Please check your phone to complete payment.",
                "payment_id": payment.id,
                "note": "If payment doesn't appear on your phone, please try again in a few minutes."
            })
            
    except Exception as e:
        logger.error(f"Unexpected error in stk_push: {str(e)}")
        return JsonResponse({"error": "Payment service temporarily unavailable. Please try again later."}, status=503)
# ------------------------------
# STK PUSH INITIATION (Landlord Subscription Payment) - UPDATED
# ------------------------------
@csrf_exempt
def stk_push_subscription(request):
    """
    Initiates an M-Pesa STK Push for a landlord's subscription payment.
    - Uses minimal amounts for testing (50 KSH)
    - Better error handling
    """
    try:
        # Get subscription plan from request
        plan = None
        phone_number = None
        
        try:
            if request.method == 'POST':
                try:
                    body = json.loads(request.body.decode('utf-8') or '{}')
                except Exception:
                    body = {}
                plan = body.get('plan') or request.GET.get('plan')
                phone_number = body.get('phone_number')
            else:
                plan = request.GET.get('plan')
        except Exception:
            plan = request.GET.get('plan')
        
        if not plan:
            return JsonResponse({"error": "Plan parameter is required."}, status=400)
        if not phone_number:
            return JsonResponse({"error": "Phone number is required."}, status=400)
        
        # Map plan to amount - MINIMAL AMOUNTS FOR TESTING
        plan_amounts = {
            "starter": 50,      # Only 50 KSH for testing
            "basic": 100,       # Only 100 KSH for testing  
            "professional": 200, # Only 200 KSH for testing
            "onetime": 500,     # Only 500 KSH for testing
        }
        
        if plan not in plan_amounts:
            return JsonResponse({"error": "Invalid plan."}, status=400)
        
        amount = plan_amounts[plan]
        
        # Rate limiting
        rate_limit_key = f"stk_push_subscription_rate_limit:{phone_number}"
        recent_requests = cache.get(rate_limit_key, 0)
        if recent_requests >= 3:
            return JsonResponse({"error": "Too many requests. Please try again later."}, status=429)
        
        cache.set(rate_limit_key, recent_requests + 1, timeout=60)
        
        # Check for duplicate pending subscription payment
        duplicate_key = f"pending_subscription_payment:{phone_number}:{plan}"
        if cache.get(duplicate_key):
            return JsonResponse({"error": "A subscription payment request is already pending."}, status=400)
        
        # Determine user
        user = None
        if request.user.is_authenticated and request.user.user_type == 'landlord':
            user = request.user
        
        # Create a pending subscription payment record
        subscription_payment = SubscriptionPayment.objects.create(
            user=user,
            amount=amount,
            mpesa_receipt_number="",
            subscription_type=plan,
            status="Pending"
        )
        
        # Mark payment as pending in Redis (5-minute expiry)
        cache.set(duplicate_key, subscription_payment.id, timeout=300)
        
        try:
            # Generate access token
            access_token_cache_key = "mpesa_access_token"
            access_token = cache.get(access_token_cache_key)
            if not access_token:
                access_token = generate_access_token()
            cache.set(access_token_cache_key, access_token, timeout=3300)
        except Exception as e:
            print(f"Access token generation warning: {str(e)}")
            try:
                access_token = generate_access_token()
            except Exception as token_error:
                return JsonResponse({"error": "Subscription service temporarily unavailable. Please try again later."}, status=503)
        
        timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        password = base64.b64encode(
            (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode("utf-8")
        ).decode("utf-8")
        
        # Build payload for Safaricom API
        party_phone = phone_number
        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": str(amount),
            "PartyA": party_phone,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": party_phone,
            "CallBackURL": settings.MPESA_SUBSCRIPTION_CALLBACK_URL,
            "AccountReference": str(subscription_payment.id),
            "TransactionDesc": f"Subscription payment for {plan} plan"
        }
        
        headers = {"Authorization": f"Bearer {access_token}"}
        
        try:
            response = requests.post(
                "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest",
                json=payload,
                headers=headers,
                timeout=30
            )
            response.raise_for_status()
            response_data = response.json()
        except requests.exceptions.RequestException as e:
            print(f"M-Pesa subscription API request failed: {str(e)}")
            return JsonResponse({
                "message": "Subscription payment initiation received.",
                "payment_id": subscription_payment.id
            })
        
        if response_data.get("ResponseCode") == "0":
            return JsonResponse({
                "message": "Subscription payment initiated successfully.",
                "checkout_request_id": response_data.get("CheckoutRequestID"),
                "payment_id": subscription_payment.id
            })
        else:
            error_msg = response_data.get("ResponseDescription", "Unknown error")
            print(f"M-Pesa subscription STK push error: {error_msg}")
            return JsonResponse({
                "message": "Subscription payment initiation received.",
                "payment_id": subscription_payment.id
            })
            
    except Exception as e:
        print(f"Unexpected error in stk_push_subscription: {str(e)}")
        return JsonResponse({"error": "Subscription service temporarily unavailable. Please try again later."}, status=503)
# ------------------------------
# RENT PAYMENT CALLBACK
# ------------------------------
# In payments/views.py - FIX THE MPESA RENT CALLBACK
@csrf_exempt
def mpesa_rent_callback(request):
    """
    Handles M-Pesa callback for rent payments.
    - Updates Payment status
    - Updates Unit rent balances
    - Initiates B2C disbursement to landlord
    - Invalidates relevant caches
    """
    logger = logging.getLogger(__name__)
    logger.info("ðŸ”„ Rent callback received")

    try:
        data = json.loads(request.body.decode("utf-8"))
        logger.info(f"ðŸ“¥ Rent callback data: {json.dumps(data, indent=2)}")

        body = data.get("Body", {}).get("stkCallback", {})
        result_code = body.get("ResultCode")
        logger.info(f"ðŸ” Rent callback result code: {result_code}")

        if result_code == 0:  # âœ… Transaction successful
            metadata_items = body.get("CallbackMetadata", {}).get("Item", [])
            logger.info(f"ðŸ“‹ Rent callback metadata items: {len(metadata_items)}")
            metadata = {item["Name"]: item.get("Value") for item in metadata_items}
            logger.info(f"ðŸ”§ Raw metadata: {metadata}")

            # Convert amount to Decimal for consistency
            amount_str = metadata.get("Amount")
            amount = None
            if amount_str:
                try:
                    amount = Decimal(amount_str)
                    logger.info(f"ðŸ’° Rent callback amount: {amount} (Decimal)")
                except (ValueError, TypeError) as e:
                    logger.error(f"âŒ Invalid amount format: {amount_str}, error: {e}")

            receipt = metadata.get("MpesaReceiptNumber")
            payment_id = metadata.get("AccountReference")
            phone = str(metadata.get("PhoneNumber")) if metadata.get("PhoneNumber") else None

            logger.info(f"ðŸ’° Rent callback metadata: amount={amount}, receipt={receipt}, payment_id={payment_id}, phone={phone}")

            if payment_id:
                logger.info(f"ðŸ” Looking for payment with ID: {payment_id}")
                try:
                    payment = Payment.objects.get(id=payment_id, status="Pending")
                    logger.info(f"âœ… Found pending rent payment: {payment.id} for tenant {payment.tenant.email}")

                    payment.status = "Success"
                    payment.mpesa_receipt = receipt
                    payment.save()
                    logger.info(f"âœ… Payment {payment.id} status updated to Success")

                    # Update unit balances - FIXED: Use Decimal amount
                    unit = payment.unit
                    unit.rent_paid += amount  # Now both are Decimal
                    unit.rent_remaining = max(unit.rent - unit.rent_paid, Decimal('0'))
                    unit.save()
                    logger.info(f"âœ… Unit {unit.unit_number} balances updated: paid={unit.rent_paid}, remaining={unit.rent_remaining}")

                    # Invalidate relevant caches
                    cache.delete_many([
                        f"pending_payment:{payment.tenant.id}:{unit.id}",
                        f"payments:tenant:{payment.tenant.id}",
                        f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                        f"rent_summary:{unit.property_obj.landlord.id}",
                        f"unit:{unit.id}:details"
                    ])
                    logger.info(f"ðŸ—‘ï¸ Cache invalidated for payment {payment.id}")
                    logger.info(f"âœ… Rent payment successful: {receipt} for payment {payment_id}")

                    # Initiate B2C disbursement to landlord
                    landlord = unit.property_obj.landlord
                    recipient = landlord.mpesa_till_number or landlord.phone_number
                    logger.info(f"ðŸ¦ Initiating B2C disbursement to landlord {landlord.email}, recipient: {recipient}")
                    if recipient:
                        try:
                            b2c_response = initiate_b2c_payment(
                                amount=amount,
                                recipient=recipient,
                                payment_id=payment_id,
                                remarks=f"Rent payment disbursement for Unit {unit.unit_number}"
                            )
                            logger.info(f"âœ… B2C disbursement initiated for payment {payment_id}: {b2c_response}")
                        except ValueError as e:
                            logger.error(f"âŒ B2C disbursement failed for payment {payment_id}: {str(e)}")
                    else:
                        logger.error(f"âŒ No recipient (till number or phone) for landlord {landlord.id}")

                except Payment.DoesNotExist:
                    logger.error(f"âŒ Payment with id {payment_id} not found or already processed")
                except Exception as e:
                    logger.error(f"âŒ Error updating payment {payment_id}: {e}")
            else:
                logger.warning("âš ï¸ No payment_id in rent callback, cannot process payment")
        else:
            # âŒ Transaction failed - UPDATE PAYMENT STATUS TO FAILED
            error_msg = body.get("ResultDesc", "Unknown error")
            logger.error(f"âŒ Rent transaction failed: {error_msg} (ResultCode: {result_code})")
            # Try to find and update the payment to Failed
            try:
                payment_id = body.get("AccountReference")
                if payment_id:
                    payment = Payment.objects.get(id=payment_id, status="Pending")
                    payment.status = "Failed"
                    payment.save()
                    logger.info(f"âœ… Rent payment {payment_id} marked as Failed")
                    # Invalidate caches
                    cache.delete_many([
                        f"pending_payment:{payment.tenant.id}:{payment.unit.id}",
                        f"payments:tenant:{payment.tenant.id}",
                        f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                    ])
                    logger.info(f"ðŸ—‘ï¸ Cache invalidated for failed payment {payment_id}")
            except Payment.DoesNotExist:
                logger.error(f"Payment with id {payment_id} not found for failure update")
            except Exception as e:
                logger.error(f"Error updating failed payment: {e}")

    except json.JSONDecodeError as e:
        logger.error(f"âŒ Invalid JSON in rent callback: {e}")
    except Exception as e:
        logger.error("âŒ Unexpected error processing rent callback:", exc_info=True)

    # CRITICAL: Always respond with success to Safaricom to acknowledge callback receipt
    logger.info("âœ… Responding with success to M-Pesa rent callback")
    return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})
# ------------------------------
# SUBSCRIPTION PAYMENT CALLBACK
# ------------------------------
@csrf_exempt
def mpesa_subscription_callback(request):
    """
    Handles M-Pesa callback for subscription payments.
    - Finds user by phone number
    - Creates/updates subscription payment
    - Updates user subscription
    - Handles duplicate receipts gracefully
    """
    logger = logging.getLogger(__name__)
    logger.info("ðŸ”„ Subscription callback received")

    try:
        data = json.loads(request.body.decode("utf-8"))
        logger.info(f"ðŸ“¥ Subscription callback data: {json.dumps(data, indent=2)}")

        body = data.get("Body", {}).get("stkCallback", {})
        result_code = body.get("ResultCode")
        logger.info(f"ðŸ” Subscription callback result code: {result_code}")

        if result_code == 0:  # âœ… Transaction successful
            metadata_items = body.get("CallbackMetadata", {}).get("Item", [])
            logger.info(f"ðŸ“‹ Subscription callback metadata items: {len(metadata_items)}")
            metadata = {item["Name"]: item.get("Value") for item in metadata_items}
            logger.info(f"ðŸ”§ Raw metadata: {metadata}")

            # Convert amount to Decimal for consistency
            amount_str = metadata.get("Amount")
            amount = None
            if amount_str:
                try:
                    amount = Decimal(amount_str)
                    logger.info(f"ðŸ’° Subscription callback amount: {amount} (Decimal)")
                except (ValueError, TypeError) as e:
                    logger.error(f"âŒ Invalid amount format: {amount_str}, error: {e}")

            receipt = metadata.get("MpesaReceiptNumber")
            account_reference = metadata.get("AccountReference")
            phone = str(metadata.get("PhoneNumber")) if metadata.get("PhoneNumber") else None

            logger.info(f"ðŸ’° Subscription callback metadata: amount={amount}, receipt={receipt}, account_reference={account_reference}, phone={phone}")

            # Helper function to find user by phone with multiple formats
            def find_user_by_phone(phone_str):
                if not phone_str:
                    return None

                phone_variants = [phone_str]

                # Generate all possible phone number formats
                if phone_str.startswith('+254'):
                    phone_variants.extend([
                        phone_str[4:],           # 722714334
                        '0' + phone_str[4:],     # 0722714334
                        phone_str[1:],           # 254722714334
                    ])
                elif phone_str.startswith('254'):
                    phone_variants.extend([
                        '+' + phone_str,         # +254722714334
                        '0' + phone_str[3:],     # 0722714334
                        phone_str[3:],           # 722714334
                    ])
                elif phone_str.startswith('0'):
                    phone_variants.extend([
                        '+254' + phone_str[1:],  # +254722714334
                        '254' + phone_str[1:],   # 254722714334
                        phone_str[1:],           # 722714334
                    ])
                else:
                    # Assume it's local without 0, add variants
                    phone_variants.extend([
                        '+254' + phone_str,      # +254722714334
                        '254' + phone_str,       # 254722714334
                        '0' + phone_str,         # 0722714334
                    ])

                # Remove duplicates
                phone_variants = list(set(phone_variants))
                logger.info(f"ðŸ” Searching for user with phone variants: {phone_variants}")
                return CustomUser.objects.filter(
                    user_type='landlord',
                    phone_number__in=phone_variants
                ).first()

            # Find user by phone number
            user = find_user_by_phone(phone)
            if not user:
                logger.error(f"âŒ No landlord found with phone number: {phone}")
                # Still acknowledge callback but log error
            else:
                logger.info(f"âœ… Found user: {user.email} for phone: {phone}")

                # Determine subscription type from amount
                subscription_type = None
                if amount == Decimal('50'):
                    subscription_type = 'starter'
                elif amount == Decimal('100'):
                    subscription_type = 'basic'
                elif amount == Decimal('200'):
                    subscription_type = 'professional'
                elif amount == Decimal('500'):
                    subscription_type = 'onetime'
                else:
                    logger.warning(f"âš ï¸ Unknown subscription amount: {amount}, cannot determine plan")

                if subscription_type:
                    # Handle duplicate receipts gracefully
                    try:
                        subscription_payment, created = SubscriptionPayment.objects.get_or_create(
                            mpesa_receipt_number=receipt,
                            defaults={
                                'user': user,
                                'amount': amount,
                                'subscription_type': subscription_type,
                                'status': 'Success',
                            }
                        )

                        if created:
                            logger.info(f"âœ… Created new subscription payment: {subscription_payment.id}")
                        else:
                            # Update status if it was pending
                            if subscription_payment.status == 'Pending':
                                subscription_payment.status = 'Success'
                                subscription_payment.save()
                            logger.warning(f"âš ï¸ Subscription payment with receipt {receipt} already exists, skipping duplicate")

                        # Update or create subscription
                        subscription, sub_created = Subscription.objects.get_or_create(
                            user=user,
                            defaults={
                                'plan': subscription_type,
                                'expiry_date': timezone.now() + timedelta(days=30) if subscription_type != 'onetime' else None
                            }
                        )

                        if not sub_created:
                            # Update existing subscription
                            subscription.plan = subscription_type
                            if subscription_type == 'onetime':
                                subscription.expiry_date = None  # Lifetime
                            else:
                                subscription.expiry_date = timezone.now() + timedelta(days=30)
                            subscription.save()
                            logger.info(f"âœ… Updated subscription for user {user.email} to {subscription_type}")
                        else:
                            logger.info(f"âœ… Created new subscription for user {user.email}: {subscription_type}")

                        # Invalidate relevant caches
                        cache.delete_many([
                            f"subscription_payments:{user.id}",
                            f"rent_summary:{user.id}",
                        ])
                        logger.info(f"ðŸ—‘ï¸ Cache invalidated for subscription payment")

                    except Exception as e:
                        logger.error(f"âŒ Error processing subscription payment: {e}")
                else:
                    logger.error(f"âŒ Could not determine subscription type for amount: {amount}")
        else:
            # Transaction failed
            error_msg = body.get("ResultDesc", "Unknown error")
            logger.error(f"âŒ Subscription transaction failed: {error_msg} (ResultCode: {result_code})")

    except json.JSONDecodeError as e:
        logger.error(f"âŒ Invalid JSON in subscription callback: {e}")
    except Exception as e:
        logger.error("âŒ Unexpected error processing subscription callback:", exc_info=True)

    # CRITICAL: Always respond with success to Safaricom to acknowledge callback receipt
    logger.info("âœ… Responding with success to M-Pesa subscription callback")
    return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})
# ------------------------------
# RENT PAYMENTS (DRF Views) - CACHED
# ------------------------------
class PaymentListCreateView(generics.ListCreateAPIView):
    """
    GET:
    - Tenants: only see their own rent payments (cached)
    - Landlords: see all rent payments for units in their properties (cached)
    POST:
    - Only tenants can create a new rent payment
    """
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]
    def get_queryset(self):
       user = self.request.user
       cache_key = f"payments:{user.user_type}:{user.id}"
       # Try to get cached data
       cached_data = cache.get(cache_key)
       if cached_data:
           # Return a queryset-like object (we'll handle this in the serializer)
           return Payment.objects.none()  # Serializer will use cached data
       # If not cached, fetch from database
       if user.user_type == "tenant":
           queryset = Payment.objects.filter(tenant=user).order_by('-transaction_date')
       elif user.user_type == "landlord":
           queryset = Payment.objects.filter(
               unit__property_obj__landlord=user).order_by('-transaction_date')
       else:
           queryset = Payment.objects.none()
       # Cache the results for 5 minutes
       if queryset.exists():
           cache.set(cache_key, PaymentSerializer(queryset, many=True).data, timeout=300)
       return queryset
    def list(self, request, *args, **kwargs):
       # Custom list method to handle cached data
       user = self.request.user
       cache_key = f"payments:{user.user_type}:{user.id}"
       cached_data = cache.get(cache_key)
       if cached_data:
           return Response(cached_data)
       return super().list(request, *args, **kwargs)
    def perform_create(self, serializer):
       if self.request.user.user_type == "tenant":
           payment = serializer.save(tenant=self.request.user)
           # Invalidate cache after creation
           cache.delete(f"payments:tenant:{self.request.user.id}")
           cache.delete(f"payments:landlord:{payment.unit.property_obj.landlord.id}")
       else:
           raise PermissionError("Only tenants can create rent payments.")
class PaymentDetailView(generics.RetrieveAPIView):
    """
    GET:
    - Tenants: can only view their own payment details (cached)
    - Landlords: can view payment details for units in their properties (cached)
    """
    serializer_class = PaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == "tenant":
            return Payment.objects.filter(tenant=user)
        elif user.user_type == "landlord":
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()

    def retrieve(self, request, *args, **kwargs):
        payment_id = kwargs.get('pk')
        cache_key = f"payment:{payment_id}:details"
        cached_data = cache.get(cache_key)
        if cached_data:
            return Response(cached_data)
        response = super().retrieve(request, *args, **kwargs)
        cache.set(cache_key, response.data, timeout=300)
        return response

# ------------------------------
# SUBSCRIPTION PAYMENTS (DRF Views) - CACHED
# ------------------------------
class SubscriptionPaymentListCreateView(generics.ListCreateAPIView):
    """
    GET:
    - Landlords: only see their own subscription payments (cached)
    - Tenants: no access
    POST:
    - Only landlords can create subscription payments
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == "landlord":
            return SubscriptionPayment.objects.filter(user=user).order_by('-transaction_date')
        return SubscriptionPayment.objects.none()

    def list(self, request, *args, **kwargs):
        user = self.request.user
        if user.user_type != "landlord":
            return Response({"error": "Only landlords can view subscription payments."}, status=403)
        cache_key = f"subscription_payments:{user.id}"
        cached_data = cache.get(cache_key)
        if cached_data:
            return Response(cached_data)
        response = super().list(request, *args, **kwargs)
        cache.set(cache_key, response.data, timeout=300)
        return response

    def perform_create(self, serializer):
        if self.request.user.user_type == "landlord":
            serializer.save(user=self.request.user)
            # Invalidate cache after creation
            cache.delete(f"subscription_payments:{self.request.user.id}")
        else:
            raise PermissionError("Only landlords can make subscription payments.")
class SubscriptionPaymentDetailView(generics.RetrieveAPIView):
    """
    GET:
    - Landlords: can only view their own subscription payment details (cached)
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == "landlord":
            return SubscriptionPayment.objects.filter(user=user)
        return SubscriptionPayment.objects.none()

    def retrieve(self, request, *args, **kwargs):
        payment_id = kwargs.get('pk')
        cache_key = f"subscription_payment:{payment_id}:details"
        cached_data = cache.get(cache_key)
        if cached_data:
            return Response(cached_data)
        response = super().retrieve(request, *args, **kwargs)
        cache.set(cache_key, response.data, timeout=300)
        return response

class RentSummaryView(APIView):
    """
    Provides a financial summary for landlords (cached):
    - Total rent collected across all their properties
    - Total outstanding rent
    - Per-unit breakdown (unit number, tenant, paid, remaining)
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, *args, **kwargs):
        user = request.user
        if user.user_type != "landlord":
            return Response({"error": "Only landlords can view rent summaries."}, status=403)
        # Check cache first
        cache_key = f"rent_summary:{user.id}"
        cached_summary = cache.get(cache_key)
        if cached_summary:
            return Response(cached_summary)
        # Get all units owned by this landlord
        units = Unit.objects.filter(property_obj__landlord=user)
        total_collected = 0
        total_outstanding = 0
        unit_breakdown = []
        for unit in units:
            collected = float(unit.rent_paid)
            outstanding = float(unit.rent_remaining)
            total_collected += collected
            total_outstanding += outstanding
            unit_breakdown.append({
                "unit_number": unit.unit_number,
                "tenant": unit.tenant.email if unit.tenant else None,
                "rent": float(unit.rent),
                "rent_paid": collected,
                "rent_remaining": outstanding,
                "is_available": unit.is_available,
            })
        summary = {
            "landlord": user.email,
            "total_collected": total_collected,
            "total_outstanding": total_outstanding,
            "units": unit_breakdown,
            "last_updated": timezone.now().isoformat(),
        }
        # Cache for 10 minutes
        cache.set(cache_key, summary, timeout=600)
        return Response(summary)
# ------------------------------
# GENERATE RENT PAYMENTS CSV REPORT
# ------------------------------
class LandLordCSVView(APIView):
    """
    Generate CSV report for landlord with Redis caching for frequent requests
    """
    permission_classes = [IsAuthenticated, HasActiveSubscription]

    def get(self, request, property_id):
        cache_key = f"landlord_csv:{property_id}:{request.user.id}"
        cached_response = cache.get(cache_key)
        if cached_response:
            response = HttpResponse(cached_response, content_type='text/csv')
            response['Content-Disposition'] = 'attachment; filename="landlord_data.csv"'
            return response
        property = get_object_or_404(Property, pk=property_id)
        # Verify the property belongs to the logged-in landlord
        if property.landlord != request.user:
            return HttpResponse("Unauthorized", status=403)
        units = property.unit_list.all()
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="landlord_data.csv"'
        writer = csv.writer(response)
        writer.writerow(['Tenant', 'Unit Number', 'Floor', 'Bedrooms', 'Bathrooms', 'Rent',
                         'Rent Paid', 'Rent Remaining', 'Rent Due Date', 'Deposit', 'Is Available'])
        for unit in units:
            writer.writerow([
                unit.tenant.email if unit.tenant else 'Vacant',
                unit.unit_number,
                unit.floor,
                unit.bedrooms,
                unit.bathrooms,
                unit.rent,
                unit.rent_paid,
                unit.rent_remaining,  # Fixed: was unit.balance
                unit.rent_due_date,
                unit.deposit,
                unit.is_available
            ])
        # Cache the CSV content for 5 minutes (for frequent downloads)
        cache.set(cache_key, response.content, timeout=300)
        return response
class TenantCSVView(APIView):
    """
    Generate CSV report for tenant with Redis caching
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, unit_id):
        cache_key = f"tenant_csv:{unit_id}:{request.user.id}"
        cached_response = cache.get(cache_key)
        if cached_response:
            response = HttpResponse(cached_response, content_type='text/csv')
            response['Content-Disposition'] = 'attachment; filename="tenant_data.csv"'
            return response
        unit = get_object_or_404(Unit, pk=unit_id)
        # Verify the unit belongs to the logged-in tenant
        if unit.tenant != request.user:
            return HttpResponse("Unauthorized", status=403)
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="tenant_data.csv"'
        writer = csv.writer(response)
        writer.writerow(['Property', 'Unit Number', 'Floor', 'Bedrooms', 'Bathrooms',
                         'Rent', 'Rent Paid', 'Rent Remaining', 'Rent Due Date', 'Deposit'])
        writer.writerow([
            unit.property_obj.name,
            unit.unit_number,
            unit.floor,
            unit.bedrooms,
            unit.bathrooms,
            unit.rent,
            unit.rent_paid,
            unit.rent_remaining,  # Fixed: was unit.balance
            unit.rent_due_date,
            unit.deposit
        ])
        # Cache the CSV content for 5 minutes
        cache.set(cache_key, response.content, timeout=300)
        return response
# ------------------------------
# UNIT TYPES LIST (For Tenants to Choose Room Types)
# ------------------------------
class UnitTypeListView(APIView):
    def get(self, request):
        landlord_code = request.query_params.get('landlord_code')
        if landlord_code:
            try:
                landlord = CustomUser.objects.get(
                    landlord_code=landlord_code, user_type='landlord')
                unit_types = UnitType.objects.filter(landlord=landlord)
            except CustomUser.DoesNotExist:
                return Response({'error': 'Invalid landlord code'}, status=400)
        else:
            unit_types = UnitType.objects.all()
        serializer = UnitTypeSerializer(unit_types, many=True)
        return Response(serializer.data)
# ------------------------------
# INITIATE DEPOSIT PAYMENT
# ------------------------------
class InitiateDepositPaymentView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        unit_id = request.data.get('unit_id')
        if not unit_id:
            return Response({'error': 'unit_id is required'}, status=400)

        try:
            # Allow deposit payment for units that are available OR not assigned to any tenant
            unit = Unit.objects.get(id=unit_id)
            if not unit.is_available and unit.tenant is not None:
                return Response({'error': 'Unit is already occupied by another tenant'}, status=400)
        except Unit.DoesNotExist:
            return Response({'error': 'Unit not found'}, status=400)

        amount = unit.deposit

        # Validate amount
        if amount is None or amount <= 0:
            return Response({"error": "Deposit amount is not set or invalid."}, status=400)

        # Allow decimal amounts for deposits (M-Pesa can handle decimals)
        try:
            amount = Decimal(str(amount))
        except (ValueError, TypeError):
            return Response({"error": "Invalid deposit amount format."}, status=400)
        
        # Rate limiting
        rate_limit_key = f"deposit_stk_push_rate_limit:{request.user.id}"
        recent_requests = cache.get(rate_limit_key, 0)
        if recent_requests >= 5:
            return Response({"error": "Too many requests. Please try again later."}, status=429)
        
        cache.set(rate_limit_key, recent_requests + 1, timeout=60)
        
        # Check for duplicate pending payment
        duplicate_key = f"pending_deposit_payment:{request.user.id}:{unit_id}"
        if cache.get(duplicate_key):
            return Response({"error": "A deposit payment request is already pending for this unit."}, status=400)
        
        # Create a pending payment record
        payment = Payment.objects.create(
            tenant=request.user,
            unit=unit,
            payment_type='deposit',
            amount=amount,
            status="Pending"
        )
        
        # Mark payment as pending in Redis (5-minute expiry)
        cache.set(duplicate_key, payment.id, timeout=300)
        
        # For testing, mark as success immediately without M-Pesa
        payment.status = "Success"
        payment.mpesa_receipt = f"TEST{payment.id}"
        payment.transaction_date = timezone.now()
        payment.save()

        # Assign tenant to unit
        unit = payment.unit
        if unit.is_available or not unit.tenant:
            unit.tenant = payment.tenant
            unit.is_available = False
            unit.save()

        # Invalidate caches
        cache.delete_many([
            f"pending_deposit_payment:{payment.tenant.id}:{unit.id}",
            f"payments:tenant:{payment.tenant.id}",
            f"payments:landlord:{unit.property_obj.landlord.id}",
            f"rent_summary:{unit.property_obj.landlord.id}",
            f"unit:{unit.id}:details",
            f"property:{unit.property_obj.id}:units"
        ])

        return Response({
            "message": "Deposit payment completed successfully for testing.",
            "payment_id": payment.id
        })
# ------------------------------
# TRIGGER DEPOSIT CALLBACK (FOR TESTING)
# ------------------------------
class TriggerDepositCallbackView(APIView):
    """
    Manual endpoint to trigger deposit callback for testing.
    Accepts payment_id as query parameter.
    """
    permission_classes = [IsAuthenticated]  # Allow authenticated users for testing

    def post(self, request):
        from django.http import HttpRequest
        import json
        import logging

        logger = logging.getLogger(__name__)

        payment_id = request.query_params.get('payment_id')
        if not payment_id:
            return Response({"error": "payment_id query parameter required"}, status=400)

        try:
            payment = Payment.objects.get(id=payment_id, payment_type='deposit')
        except Payment.DoesNotExist:
            return Response({"error": f"Deposit payment with id {payment_id} not found"}, status=404)

        # Create mock callback data
        mock_callback_data = {
            "Body": {
                "stkCallback": {
                    "MerchantRequestID": "mock-request-id",
                    "CheckoutRequestID": "mock-checkout-id",
                    "ResultCode": 0,
                    "ResultDesc": "The service request is processed successfully.",
                    "CallbackMetadata": {
                        "Item": [
                            {"Name": "Amount", "Value": str(payment.amount)},
                            {"Name": "MpesaReceiptNumber", "Value": f"TEST{payment_id}"},
                            {"Name": "TransactionDate", "Value": "20231201120000"},
                            {"Name": "PhoneNumber", "Value": payment.tenant.phone_number},
                            {"Name": "AccountReference", "Value": str(payment.id)}
                        ]
                    }
                }
            }
        }

        # Simulate the callback by calling the actual callback function
        mock_request = HttpRequest()
        mock_request.method = 'POST'
        mock_request._body = json.dumps(mock_callback_data).encode('utf-8')

        logger.info(f"ðŸ”§ Manually triggering deposit callback for payment {payment_id}")
        response = mpesa_deposit_callback(mock_request)

        return Response({
            "message": f"Deposit callback triggered for payment {payment_id}",
            "mock_data": mock_callback_data,
            "callback_response": response.content.decode('utf-8')
        })

# ------------------------------
# B2C PAYMENT CALLBACK
# ------------------------------
@csrf_exempt
def mpesa_b2c_callback(request):
    """
    Handles M-Pesa callback for B2C disbursements.
    - Logs the result of the disbursement
    - Could update payment records if needed
    """
    try:
        data = json.loads(request.body.decode("utf-8"))
        result = data.get("Result", {})
        result_code = result.get("ResultCode")
        result_desc = result.get("ResultDesc")
        if result_code == 0:  # âœ… Disbursement successful
            print(f"âœ… B2C disbursement successful: {result_desc}")
        else:
            print(f"âŒ B2C disbursement failed: {result_desc}")
    except Exception as e:
        print("Error processing B2C callback:", e)
    # Always respond with success to Safaricom
    return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

# ------------------------------
# DEPOSIT PAYMENT CALLBACK
# ------------------------------
@csrf_exempt
def mpesa_deposit_callback(request):
    """
    Handles M-Pesa callback for deposit payments.
    âœ… Automatically confirms deposits and assigns tenant to unit
    âœ… No timeout restriction (safe for delayed callbacks)
    âœ… Always acknowledges Safaricom callback with success
    """
    import logging
    from decimal import Decimal
    from django.utils import timezone
    import json

    logger = logging.getLogger(__name__)
    logger.info("ðŸ”„ Deposit callback received")

    try:
        # --- Parse callback data ---
        data = json.loads(request.body.decode("utf-8"))
        logger.info(f"ðŸ“¥ Deposit callback payload: {json.dumps(data, indent=2)}")

        body = data.get("Body", {}).get("stkCallback", {})
        result_code = body.get("ResultCode")
        logger.info(f"ðŸ” Deposit callback result code: {result_code}")

        if result_code == 0:  # âœ… Transaction successful
            metadata_items = body.get("CallbackMetadata", {}).get("Item", [])
            metadata = {item["Name"]: item.get("Value") for item in metadata_items}
            logger.info(f"ðŸ”§ Parsed metadata: {metadata}")

            # Extract values
            amount_str = metadata.get("Amount")
            receipt = metadata.get("MpesaReceiptNumber")
            payment_id = metadata.get("AccountReference")
            phone = str(metadata.get("PhoneNumber")) if metadata.get("PhoneNumber") else None

            # Convert amount safely
            try:
                amount = Decimal(amount_str)
            except Exception:
                amount = Decimal('0')
            logger.info(f"ðŸ’° Amount={amount}, Receipt={receipt}, PaymentID={payment_id}, Phone={phone}")

            # --- Update the payment record ---
            if not payment_id:
                logger.error("âŒ Missing AccountReference (payment_id) in callback.")
                return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

            try:
                payment = Payment.objects.get(id=payment_id, payment_type="deposit")
            except Payment.DoesNotExist:
                logger.error(f"âŒ Payment with id {payment_id} not found.")
                return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

            # Update payment status
            payment.status = "Success"
            payment.mpesa_receipt = receipt
            payment.transaction_date = timezone.now()
            payment.save()
            logger.info(f"âœ… Payment {payment.id} marked as Success")

            # --- Assign tenant automatically ---
            unit = payment.unit
            if unit.is_available or not unit.tenant:
                unit.tenant = payment.tenant
                unit.is_available = False
                unit.save()
                logger.info(f"ðŸ  Tenant {payment.tenant.email} assigned to unit {unit.unit_number}")
            else:
                logger.warning(f"âš ï¸ Unit {unit.unit_number} already occupied. Skipping assignment.")

            # --- Invalidate caches ---
            cache.delete_many([
                f"pending_deposit_payment:{payment.tenant.id}:{unit.id}",
                f"payments:tenant:{payment.tenant.id}",
                f"payments:landlord:{unit.property_obj.landlord.id}",
                f"rent_summary:{unit.property_obj.landlord.id}",
                f"unit:{unit.id}:details",
                f"property:{unit.property_obj.id}:units"
            ])
            logger.info(f"ðŸ—‘ï¸ Cache cleared for payment {payment.id}")

        else:
            # âŒ Transaction failed
            error_msg = body.get("ResultDesc", "Unknown error")
            payment_id = body.get("AccountReference")
            logger.error(f"âŒ Deposit transaction failed: {error_msg} (Payment ID: {payment_id})")

            if payment_id:
                try:
                    payment = Payment.objects.get(id=payment_id, payment_type="deposit")
                    payment.status = "Failed"
                    payment.save()
                    cache.delete_many([
                        f"pending_deposit_payment:{payment.tenant.id}:{payment.unit.id}",
                        f"payments:tenant:{payment.tenant.id}",
                        f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                    ])
                    logger.info(f"âœ… Marked payment {payment_id} as Failed")
                except Payment.DoesNotExist:
                    logger.error(f"Payment {payment_id} not found for failure update")

    except json.JSONDecodeError as e:
        logger.error(f"âŒ Invalid JSON in deposit callback: {e}")
    except Exception as e:
        logger.exception("âŒ Unexpected error in deposit callback")

    # --- Always respond success to Safaricom ---
    logger.info("âœ… Acknowledging M-Pesa callback with success")
    return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

# ------------------------------
# DEPOSIT PAYMENT STATUS VIEW
# ------------------------------
class DepositPaymentStatusView(APIView):
    """
    Allows tenants to check the status of their deposit payment.
    Includes automatic timeout detection (10 minutes).
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, payment_id):
        try:
            payment = Payment.objects.get(
                id=payment_id,
                tenant=request.user,
                payment_type='deposit'
            )
        except Payment.DoesNotExist:
            return Response({"error": "Deposit payment not found"}, status=404)

        # Check for timeout (10 minutes)
        if payment.status == "Pending":
            time_elapsed = timezone.now() - payment.transaction_date
            if time_elapsed.total_seconds() > 600:  # 10 minutes
                payment.status = "Failed"
                payment.save()
                logger.warning(f"Payment {payment.id} timed out after 10 minutes")

                # Invalidate caches
                cache.delete_many([
                    f"pending_deposit_payment:{payment.tenant.id}:{payment.unit.id}",
                    f"payments:tenant:{payment.tenant.id}",
                    f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                ])

        return Response({
            "payment_id": payment.id,
            "status": payment.status,
            "amount": payment.amount,
            "unit_number": payment.unit.unit_number,
            "transaction_date": payment.transaction_date,
            "mpesa_receipt": payment.mpesa_receipt
        })

# ------------------------------
# CLEANUP PENDING PAYMENTS VIEW
# ------------------------------
class CleanupPendingPaymentsView(APIView):
    """
    Admin endpoint to cleanup pending payments older than 10 minutes.
    Marks them as Failed and invalidates relevant caches.
    """
    permission_classes = [IsAuthenticated]  # TODO: Add admin permission

    def post(self, request):
        # Add logger import at the top of the function
        logger = logging.getLogger(__name__)

        # Find all pending payments older than 10 minutes
        cutoff_time = timezone.now() - timedelta(minutes=10)
        pending_payments = Payment.objects.filter(
            status="Pending",
            transaction_date__lt=cutoff_time
        )

        cleaned_count = 0
        for payment in pending_payments:
            payment.status = "Failed"
            payment.save()
            cleaned_count += 1

            # Invalidate relevant caches
            if payment.payment_type == 'deposit':
                cache.delete_many([
                    f"pending_deposit_payment:{payment.tenant.id}:{payment.unit.id}",
                    f"payments:tenant:{payment.tenant.id}",
                    f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                ])
            else:  # rent payment
                cache.delete_many([
                    f"pending_payment:{payment.tenant.id}:{payment.unit.id}",
                    f"payments:tenant:{payment.tenant.id}",
                    f"payments:landlord:{payment.unit.property_obj.landlord.id}",
                ])

        logger.info(f"Cleaned up {cleaned_count} pending payments older than 10 minutes")

        return Response({
            "message": f"Cleaned up {cleaned_count} pending payments",
            "cutoff_time": cutoff_time.isoformat()
        })

# ------------------------------
# SIMULATE DEPOSIT CALLBACK VIEW
# ------------------------------
class SimulateDepositCallbackView(APIView):
    """
    Endpoint to simulate deposit callback for testing purposes.
    Accepts payment_id as query parameter and simulates success/failure.
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        payment_id = request.query_params.get('payment_id')
        if not payment_id:
            return Response({"error": "payment_id query parameter required"}, status=400)

        try:
            payment = Payment.objects.get(id=payment_id, payment_type='deposit')
        except Payment.DoesNotExist:
            return Response({"error": f"Deposit payment with id {payment_id} not found"}, status=404)

        # Check if callback is within timeout (10 minutes)
        time_elapsed = timezone.now() - payment.transaction_date
        if time_elapsed.total_seconds() > 600:  # 10 minutes
            return Response({"error": "Payment has timed out (10 minutes)"}, status=400)

        # Simulate successful callback
        mock_callback_data = {
            "Body": {
                "stkCallback": {
                    "MerchantRequestID": "mock-request-id",
                    "CheckoutRequestID": "mock-checkout-id",
                    "ResultCode": 0,
                    "ResultDesc": "The service request is processed successfully.",
                    "CallbackMetadata": {
                        "Item": [
                            {"Name": "Amount", "Value": str(payment.amount)},
                            {"Name": "MpesaReceiptNumber", "Value": f"SIM{payment_id}"},
                            {"Name": "TransactionDate", "Value": timezone.now().strftime("%Y%m%d%H%M%S")},
                            {"Name": "PhoneNumber", "Value": payment.tenant.phone_number},
                            {"Name": "AccountReference", "Value": str(payment.id)}
                        ]
                    }
                }
            }
        }

        # Create mock request to call the actual callback function
        from django.http import HttpRequest
        mock_request = HttpRequest()
        mock_request.method = 'POST'
        mock_request._body = json.dumps(mock_callback_data).encode('utf-8')

        logger.info(f"ðŸ”§ Simulating deposit callback for payment {payment_id}")
        response = mpesa_deposit_callback(mock_request)

        return Response({
            "message": f"Deposit callback simulated for payment {payment_id}",
            "mock_data": mock_callback_data,
            "callback_response": response.content.decode('utf-8')
        })
from django.urls import path
from .views import (
    # STK Push + Callbacks
    stk_push,
    stk_push_subscription,
    mpesa_rent_callback,
    mpesa_subscription_callback,
    mpesa_b2c_callback,
    mpesa_deposit_callback,

    # DRF views
    PaymentListCreateView,
    PaymentDetailView,
    SubscriptionPaymentListCreateView,
    SubscriptionPaymentDetailView,
    RentSummaryView,
    UnitTypeListView,
    InitiateDepositPaymentView,
    TriggerDepositCallbackView,
    DepositPaymentStatusView,
    CleanupPendingPaymentsView,
    SimulateDepositCallbackView,

    # CSV reports
    LandLordCSVView as landlord_csv,
    TenantCSVView as tenant_csv,
)
from django.views.decorators.csrf import csrf_exempt

urlpatterns = [
    # ------------------------------
    # M-PESA STK PUSH + CALLBACKS
    # ------------------------------
    path("stk-push/<int:unit_id>/", stk_push, name="stk-push"),
    path("stk-push-subscription/", stk_push_subscription, name="stk-push-subscription"),
    path("callback/rent/", mpesa_rent_callback, name="mpesa-rent-callback"),
    path("callback/subscription/", mpesa_subscription_callback, name="mpesa-subscription-callback"),
    path("callback/b2c/", mpesa_b2c_callback, name="mpesa-b2c-callback"),
    path("callback/deposit/", mpesa_deposit_callback, name="mpesa-deposit-callback"),

    # ------------------------------
    # MANUAL CALLBACK TRIGGER (FOR TESTING)
    # ------------------------------
    path("trigger-deposit-callback/", TriggerDepositCallbackView.as_view(), name="trigger-deposit-callback"),

    # ------------------------------
    # RENT PAYMENTS (DRF)
    # ------------------------------
    path("rent-payments/", PaymentListCreateView.as_view(), name="rent-payment-list-create"),
    path("rent-payments/<int:pk>/", PaymentDetailView.as_view(), name="rent-payment-detail"),

    # ------------------------------
    # SUBSCRIPTION PAYMENTS (DRF)
    # ------------------------------
    path("subscription-payments/", SubscriptionPaymentListCreateView.as_view(), name="subscription-payment-list-create"),
    path("subscription-payments/<int:pk>/", SubscriptionPaymentDetailView.as_view(), name="subscription-payment-detail"),
    path("rent-payments/summary/", RentSummaryView.as_view(), name="rent-summary"),

    # ------------------------------
    # UNIT TYPES
    # ------------------------------
    path("unit-types/", UnitTypeListView.as_view(), name="unit-types"),

    # ------------------------------
    # INITIATE DEPOSIT PAYMENT
    # ------------------------------
    path("initiate-deposit/", InitiateDepositPaymentView.as_view(), name="initiate-deposit"),
    path('deposit-status/<int:payment_id>/', DepositPaymentStatusView.as_view(), name='deposit-status'),
    # ------------------------------
    # CSV REPORTS
    # ------------------------------
    path("landlord-csv/<int:property_id>/", landlord_csv.as_view(), name="landlord-csv"),
    path("tenant-csv/<int:unit_id>/", tenant_csv.as_view(), name="tenant-csv"),

    # ------------------------------
    # CLEANUP AND SIMULATION ENDPOINTS
    # ------------------------------
    path("cleanup-pending-payments/", CleanupPendingPaymentsView.as_view(), name="cleanup-pending-payments"),
    path("simulate-deposit-callback/", SimulateDepositCallbackView.as_view(), name="simulate-deposit-callback"),
]
