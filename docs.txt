//Accounts app
from django.db import models
from django.contrib.auth.models import AbstractBaseUser, BaseUserManager, PermissionsMixin
from django.utils import timezone
from datetime import timedelta
from django.core.exceptions import ValidationError
import uuid


class CustomUserManager(BaseUserManager):
    # ensure the email is normalized and user_type is provided
    def create_user(self, email, full_name, user_type, password=None, **extra_fields):
        if not email:
            raise ValueError("The Email field must be set")
        if not user_type:
            raise ValueError("User type must be set (landlord or tenant)")

        email = self.normalize_email(email)
        user = self.model(
            email=email,
            full_name=full_name,
            user_type=user_type,
            **extra_fields
        )
        user.set_password(password)
        user.save(using=self._db)

        # Auto-assign free trial for landlords
        if user_type == "landlord":
            Subscription.objects.create(
                user=user,
                plan="free",
                expiry_date=timezone.now() + timedelta(days=60)
            )
            # generate a public landlord_code
            if not getattr(user, 'landlord_code', None):
                user.landlord_code = f"L-{uuid.uuid4().hex[:10].upper()}"
                user.save(update_fields=['landlord_code'])

        return user

    def create_superuser(self, email, full_name, password=None, **extra_fields):
        extra_fields.setdefault("is_staff", True)
        extra_fields.setdefault("is_superuser", True)
        # set default user_type if not provided
        user_type = extra_fields.pop("user_type", "landlord")

        if extra_fields.get("is_staff") is not True:
            raise ValueError("Superuser must have is_staff=True.")
        if extra_fields.get("is_superuser") is not True:
            raise ValueError("Superuser must have is_superuser=True.")

        return self.create_user(
            email=email,
            full_name=full_name,
            user_type=user_type,
            password=password,
            **extra_fields
        )


class CustomUser(AbstractBaseUser,PermissionsMixin):
    email = models.EmailField(unique=True)
    full_name = models.CharField(max_length=120, default='')
    # Government ID number (National ID or Passport)
    government_id = models.CharField(max_length=20, blank=True, null=True, help_text="Government ID number (e.g., National ID or Passport)")
    # ID or passport image for verification
    id_document = models.ImageField(upload_to='id_documents/', null=True, blank=True)
    # Human-facing landlord code used externally (different from DB id)
    landlord_code = models.CharField(max_length=50, unique=True, null=True, blank=True)
    date_joined = models.DateTimeField(auto_now_add=True)
    type = [('landlord', 'Landlord'), ('tenant', 'Tenant')]
    user_type = models.CharField(max_length=10, choices=type)
    is_active = models.BooleanField(default=True)
    is_staff = models.BooleanField(default=False)
    is_superuser = models.BooleanField(default=False)
    mpesa_till_number = models.CharField(max_length=20, blank=True, null=True, help_text="M-Pesa till number for direct payments (landlords only)")
    phone_number = models.CharField(max_length=30, blank=True, null=True, help_text="User phone number in international format")
    emergency_contact = models.CharField(max_length=30, blank=True, null=True, help_text="Emergency contact phone number")
    reminder_mode = models.CharField(
        max_length=20,
        choices=[('days_before', 'Days Before Due Date'), ('fixed_day', 'Fixed Day of Month')],
        default='days_before',
        help_text="How the tenant wants to receive rent reminders"
    )
    reminder_value = models.IntegerField(
        default=10,
        help_text="For 'days_before': days before due date; For 'fixed_day': day of the month (1-31)"
    )

    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['full_name']
    objects = CustomUserManager()

    # Check if user has an active subscription
    def has_active_subscription(self):
        if hasattr(self, "subscription"):
            return self.subscription.is_active()
        return False

    def __str__(self):
        return f"{self.full_name} ({self.email})"


class Subscription(models.Model):
    PLAN_CHOICES = [
        ("free", "Free (60-day trial)"),
        ("starter", "Starter (up to 10 units)"),
        ("basic", "Basic (10-50 units)"),
        ("professional", "Professional (50-100 units)"),
        ("onetime", "One-time (Unlimited properties)"),
    ]

    user = models.OneToOneField(CustomUser, on_delete=models.CASCADE, related_name="subscription")
    plan = models.CharField(max_length=20, choices=PLAN_CHOICES, default="free")
    start_date = models.DateTimeField(auto_now_add=True)
    expiry_date = models.DateTimeField(null=True, blank=True)

    def save(self, *args, **kwargs):
        # Set expiry dates based on plan
        if not self.expiry_date:
            if self.plan == "free":
                self.expiry_date = timezone.now() + timedelta(days=60)
            elif self.plan == "starter":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            elif self.plan == "basic":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            elif self.plan == "professional":
                # monthly subscription
                self.expiry_date = timezone.now() + timedelta(days=30)
            # "onetime" could remain None for lifetime access
        
        super().save(*args, **kwargs)

    # Check if subscription is still valid
    def is_active(self):
        return self.expiry_date is None or self.expiry_date > timezone.now()

    def __str__(self):
        return f"{self.user.email} - {self.plan}"


class Property(models.Model):
    landlord = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    name = models.CharField(max_length=255)
    city = models.CharField(max_length=100)
    state = models.CharField(max_length=100)
    unit_count = models.IntegerField()   # integer count of units for this property

    def __str__(self):
        return f"{self.name}, {self.city}"

    def __str__(self):
        return f"{self.name}, {self.city}"

# TODO: Ensure that the landlord can only have a certain amount of units linked to property unit count
class UnitType(models.Model):
    landlord = models.ForeignKey(CustomUser, on_delete=models.CASCADE, related_name='unit_types')
    name = models.CharField(max_length=50)
    deposit = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    number_of_units = models.IntegerField(default=0, help_text="Number of units of this type to create automatically")

    def __str__(self):
        return f"{self.landlord.email} - {self.name}"


class Unit(models.Model):
    property_obj = models.ForeignKey(
        Property,
        on_delete=models.CASCADE,
        related_name="unit_list",
        db_column="property_id"
    )
    # system-generated unit code (unique per unit)
    unit_code = models.CharField(max_length=30, unique=True, default='')
    unit_number = models.CharField(max_length=10)
    floor = models.IntegerField(null=True, blank=True)
    bedrooms = models.IntegerField(default=0)
    bathrooms = models.IntegerField(default=0)

    unit_type = models.ForeignKey(UnitType, on_delete=models.SET_NULL, null=True, blank=True)

    rent = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    tenant = models.OneToOneField(CustomUser, on_delete=models.SET_NULL, null=True, blank=True)

    rent_paid = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent_remaining = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    rent_due_date = models.DateField(null=True, blank=True)

    deposit = models.DecimalField(max_digits=10, decimal_places=2, default=0)
    is_available = models.BooleanField(default=True)

    assigned_date = models.DateTimeField(null=True, blank=True)
    left_date = models.DateTimeField(null=True, blank=True)

    @property
    def balance(self):
        return self.rent_remaining - self.rent_paid

    def clean(self):
        current_units = self.__class__.objects.filter(property_obj=self.property_obj).count()
        if self.property_obj.unit_count is not None and current_units >= self.property_obj.unit_count:
            raise ValidationError("The number of units for this property has reached the limit.")

    def save(self, *args, **kwargs):
        # Calculate rent_remaining as rent - rent_paid
        self.rent_remaining = self.rent - self.rent_paid

        if self.pk:  # existing unit
            old_unit = Unit.objects.get(pk=self.pk)
            if old_unit.tenant != self.tenant:
                if self.tenant and not self.assigned_date:
                    self.assigned_date = timezone.now()
                elif not self.tenant and old_unit.tenant:
                    self.left_date = timezone.now()
        else:  # new unit
            if self.tenant:
                self.assigned_date = timezone.now()
        super().save(*args, **kwargs)


    def __str__(self):
        return f"{self.property_obj.name} - Unit {self.unit_number}"



# REMINDER: payments is shown in the Unit model as rent_paid and rent_remaining
# TODO: Protect the subscription features using a decorator or middleware to ensure only subscribed users can access them
# TODO: Ensure payments for subscription and rent are two different things
from rest_framework import permissions
from django.core.cache import cache
from .models import CustomUser, Subscription
# REMOVE the problematic Payment import - it causes circular dependency

class IsLandlord(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.user_type == 'landlord'

class IsTenant(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.user_type == 'tenant'

class IsSuperuser(permissions.BasePermission):
    def has_permission(self, request, view):
        return request.user.is_authenticated and request.user.is_superuser

class HasActiveSubscription(permissions.BasePermission):
    def has_permission(self, request, view):
        if not request.user.is_authenticated or request.user.user_type != 'landlord':
            return False
        
        # Use cache to avoid repeated database queries
        cache_key = f"subscription_status:{request.user.id}"
        has_active_sub = cache.get(cache_key)
        
        if has_active_sub is None:
            try:
                subscription = Subscription.objects.get(user=request.user)
                has_active_sub = subscription.is_active()
            except Subscription.DoesNotExist:
                has_active_sub = False
            cache.set(cache_key, has_active_sub, timeout=300)  # Cache for 5 minutes
        
        return has_active_sub

# Remove the problematic IsTenantWithActivePayment permission if it exists
# as it causes circular imports with Payment model

class CanAccessReport(permissions.BasePermission):
    def has_object_permission(self, request, view, obj):
        if not request.user.is_authenticated:
            return False
        if request.user.user_type == 'tenant':
            return obj.tenant == request.user
        elif request.user.user_type == 'landlord':
            return obj.unit.property_obj.landlord == request.user
        return False
from .models import CustomUser, Property, Unit, UnitType
from rest_framework import serializers

from django.contrib.auth.tokens import default_token_generator
from django.utils.http import urlsafe_base64_encode
from django.utils.encoding import force_bytes
from django.core.mail import send_mail

# Overide the token to use email instead of username for JWT authentication
# accounts/serializers.py
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework import serializers
from django.contrib.auth import authenticate
from .models import CustomUser

class MyTokenObtainPairSerializer(TokenObtainPairSerializer):
    username_field = "email"

    user_type = serializers.CharField(write_only=True)

    def validate(self, attrs):
        email = attrs.get("email")
        password = attrs.get("password")
        user_type = attrs.get("user_type")

        if email and password and user_type:
            user = authenticate(self.context['request'], email=email, password=password)
            if not user:
                raise serializers.ValidationError("Invalid email or password")
            if user.user_type not in ['tenant', 'landlord']:
                raise serializers.ValidationError("Invalid user type")
            if user.user_type != user_type:
                raise serializers.ValidationError("User type does not match")
            if not user.is_active:
                raise serializers.ValidationError("User account is disabled")
        else:
            raise serializers.ValidationError("Must include 'email', 'password', and 'user_type'")

        data = super().validate(attrs)
        data['user_type'] = user_type
        return data



class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = [
            'id',
            'email',
            'full_name',
            'government_id',
            'id_document',
            'landlord_code',
            'date_joined',
            'user_type',
            'is_active',
            'is_staff',
            'is_superuser',
            'mpesa_till_number',
            'phone_number',
            'emergency_contact',
            'reminder_mode',
            'reminder_value',
            'password'
        ]
        read_only_fields = ['id', 'date_joined', 'is_active', 'is_staff', 'is_superuser', 'landlord_code']
        extra_kwargs = {
            'password': {'write_only': True}
        }

    def create(self, validated_data):
        # Always use the manager to ensure password is hashed
        # adapt to new signature: email, full_name, user_type, password
        email = validated_data.pop('email')
        full_name = validated_data.pop('full_name')
        user_type = validated_data.pop('user_type')
        password = validated_data.pop('password', None)
        user = CustomUser.objects.create_user(email=email, full_name=full_name, user_type=user_type, password=password, **validated_data)
        return user

    def update(self, instance, validated_data):
        for attr, value in validated_data.items():
            if attr == 'password':
                instance.set_password(value)
            else:
                setattr(instance, attr, value)
        instance.save()
        return instance

    def validate_phone_number(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid phone number in international format, e.g. +2547XXXXXXXX")
        return value

    def validate_emergency_contact(self, value):
        if not value:
            return value
        import re
        if not re.match(r"^\+?[0-9]{7,15}$", value):
            raise serializers.ValidationError("Enter a valid emergency contact phone number in international format")
        return value

        
class PropertySerializer(serializers.ModelSerializer):
    class Meta:
        model = Property
        fields = ['id', 'landlord', 'name', 'city', 'state', 'unit_count']
        read_only_fields = ['id', 'landlord']
    def create(self, validated_data):
        property = Property.objects.create(**validated_data)
        return property
    
class UnitTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = UnitType
        fields = ['id', 'landlord', 'name', 'deposit', 'rent']
        read_only_fields = ['id', 'landlord']


class UnitSerializer(serializers.ModelSerializer):
    property = serializers.IntegerField(write_only=True, required=False)  # Alias for property_obj

    class Meta:
        model = Unit
        fields = ['id', 'property_obj', 'unit_code', 'unit_number', 'floor', 'bedrooms', 'bathrooms', 'unit_type', 'rent', 'tenant', 'rent_paid', 'rent_remaining', 'deposit', 'is_available', 'property']
        read_only_fields = ['id', 'rent_remaining', 'unit_code']
        extra_kwargs = {
            'unit_number': {'required': False},
            'property_obj': {'required': False},
        }

    def validate(self, attrs):
        user = self.context['request'].user
        # Handle property alias
        if 'property' in attrs:
            try:
                prop = Property.objects.get(id=attrs.pop('property'))
                if prop.landlord != user:
                    raise serializers.ValidationError("Property not owned by you.")
                attrs['property_obj'] = prop
            except Property.DoesNotExist:
                raise serializers.ValidationError("Property not found.")
        # Validate property_obj ownership if set directly
        if 'property_obj' in attrs:
            if attrs['property_obj'].landlord != user:
                raise serializers.ValidationError("Property not owned by you.")
        # Validate unit_type ownership
        if 'unit_type' in attrs and attrs['unit_type']:
            if attrs['unit_type'].landlord != user:
                raise serializers.ValidationError("UnitType not owned by you.")
        return super().validate(attrs)

    def create(self, validated_data):
        # Auto-generate unit_number if not provided
        if not validated_data.get('unit_number'):
            prop = validated_data.get('property_obj')
            if prop:
                existing_units = Unit.objects.filter(property_obj=prop)
                last_unit = existing_units.order_by('-unit_number').first()
                if last_unit and last_unit.unit_number.isdigit():
                    next_num = int(last_unit.unit_number) + 1
                else:
                    next_num = 1
                validated_data['unit_number'] = str(next_num)
        # Auto-generate unit_code if not provided
        if not validated_data.get('unit_code'):
            prop = validated_data.get('property_obj')
            if prop and getattr(prop, 'id', None):
                existing_count = Unit.objects.filter(property_obj=prop).count()
                validated_data['unit_code'] = f"U-{prop.id}-{existing_count+1}"
            else:
                # fallback unique code
                import uuid
                validated_data['unit_code'] = f"U-{uuid.uuid4().hex[:10].upper()}"
        # Set rent and deposit from unit_type if not provided
        unit_type = validated_data.get('unit_type')
        if unit_type:
            if not validated_data.get('rent'):
                validated_data['rent'] = unit_type.rent
            if not validated_data.get('deposit'):
                validated_data['deposit'] = unit_type.deposit
        # Enforce landlord has at least one UnitType defined before creating units
        prop = validated_data.get('property_obj')
        if prop and prop.landlord:
            landlord = prop.landlord
            if not UnitType.objects.filter(landlord=landlord).exists():
                raise serializers.ValidationError("Landlord must create at least one UnitType before creating Units.")

        unit = Unit.objects.create(**validated_data)
        return unit


class UnitNumberSerializer(serializers.ModelSerializer):
    class Meta:
        model = Unit
        fields = ['unit_number']

# TODO: Ensure landlords create properties and units upon sign up this will be done in the frontend
# TODO: Ensure Tenants pay the deposit to book a unit and choose their property upon sign up
# TODO: Ensure Tenants and Landlords can reset their passwords and get email notifications for important actions 


# For reset password functionality
class PasswordResetSerializer(serializers.Serializer):
    email = serializers.EmailField()

    def validate_email(self, value):
        if not CustomUser.objects.filter(email=value).exists():
            raise serializers.ValidationError("User with this email does not exist.")
        return value

    def save(self):
        from django.conf import settings
        email = self.validated_data['email']
        user = CustomUser.objects.get(email=email)
        uid = urlsafe_base64_encode(force_bytes(user.pk))
        token = default_token_generator.make_token(user)
        # Use the configurable frontend URL from settings
        reset_link = f"{settings.FRONTEND_URL}/reset-password/{uid}/{token}/"

        send_mail(
            subject="Password Reset Request",
            message=f"Click the link to reset your password: {reset_link}",
            from_email=None,
            recipient_list=[email],
        )


class PasswordResetConfirmSerializer(serializers.Serializer):
    uid = serializers.CharField()
    token = serializers.CharField()
    new_password = serializers.CharField(write_only=True, min_length=8)

    def validate(self, attrs):
        from django.contrib.auth.tokens import default_token_generator
        from django.utils.http import urlsafe_base64_decode
        from django.contrib.auth.password_validation import validate_password
        try:
            uid = urlsafe_base64_decode(attrs['uid']).decode()
            user = CustomUser.objects.get(pk=uid)
        except (TypeError, ValueError, OverflowError, CustomUser.DoesNotExist):
            raise serializers.ValidationError("Invalid UID")

        if not default_token_generator.check_token(user, attrs['token']):
            raise serializers.ValidationError("Invalid or expired token")

        validate_password(attrs['new_password'], user)
        attrs['user'] = user
        return attrs

    def save(self):
        user = self.validated_data['user']
        new_password = self.validated_data['new_password']
        user.set_password(new_password)
        user.save()
        return user


class ReminderPreferencesSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ['reminder_mode', 'reminder_value']


class AvailableUnitsSerializer(serializers.ModelSerializer):
    landlord_id = serializers.CharField(source='property_obj.landlord.landlord_code', read_only=True)
    property_id = serializers.IntegerField(source='property_obj.id', read_only=True)
    property_name = serializers.CharField(source='property_obj.name', read_only=True)
    unit_number = serializers.CharField(read_only=True)

    class Meta:
        model = Unit
        fields = ['landlord_id', 'property_id', 'property_name', 'unit_number']
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
from rest_framework.routers import DefaultRouter
from . import views
from django.urls import path
from .views import (UserDetailView, UserListView, UserCreateView, PasswordResetView,
                    CreatePropertyView, LandlordPropertiesView, CreateUnitView,
                    UpdatePropertyView,UpdateUnitView,UpdateUserView, SubscriptionStatusView,
                    UpdateTillNumberView, MyTokenObtainPairView, AdminLandlordSubscriptionStatusView,
                    MeView, PasswordResetConfirmView, UnitTypeListCreateView, UnitTypeDetailView,
                    LandlordDashboardStatsView, TenantUpdateUnitView, AdjustRentView,
                    PropertyUnitsView, AssignTenantView, UpdateReminderPreferencesView,
                    LandlordAvailableUnitsView, WelcomeView, LandlordsListView,
                    PendingApplicationsView, EvictedTenantsView,TenantRegistrationStepView,
                    LandlordRegistrationStepView,CompleteTenantRegistrationView,CompleteLandlordRegistrationView,
)

router = DefaultRouter()
# Remove or comment these out if you're not using ViewSets
# router.register('properties', views.PropertyViewSet, basename='property')
# router.register('units', views.UnitViewSet, basename='unit')
# router.register('users', views.UserViewSet, basename='user')

urlpatterns = [
    # Authentication endpoints
    path("signup/", UserCreateView.as_view(), name="signup"),
    path('token/', MyTokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),

    # User endpoints
    path("users/<int:user_id>/", UserDetailView.as_view(), name="user-detail"),
    path("users/", UserListView.as_view(), name="user-list"),
    path('users/<int:user_id>/update/', UpdateUserView.as_view(), name='user-update'),
    path('me/', MeView.as_view(), name='me'),

    # Password reset
    path('password-reset/', PasswordResetView.as_view(), name='password-reset'),
    path('password-reset-confirm/', PasswordResetConfirmView.as_view(), name='password-reset-confirm'),

    # Property endpoints - FIXED URL NAMES
    path('properties/create/', CreatePropertyView.as_view(), name='property-create'),  # Changed from 'create-property'
    path('properties/', LandlordPropertiesView.as_view(), name='property-list'),  # Changed from 'landlord-properties'
    path('properties/<int:property_id>/update/', UpdatePropertyView.as_view(), name='property-update'),
    path('properties/<int:property_id>/units/', PropertyUnitsView.as_view(), name='property-units'),

    # Unit endpoints - FIXED URL NAMES
    path('units/create/', CreateUnitView.as_view(), name='unit-create'),  # Changed from 'create-unit'
    path('units/<int:unit_id>/update/', UpdateUnitView.as_view(), name='unit-update'),
    path('units/tenant/update/', TenantUpdateUnitView.as_view(), name='tenant-unit-update'),
    path('units/<int:unit_id>/assign/<int:tenant_id>/', AssignTenantView.as_view(), name='assign-tenant'),  # Changed from 'assign-tenant-to-unit'

    # UnitType endpoints
    path('unit-types/', UnitTypeListCreateView.as_view(), name='unit-types'),  # Changed from 'unittype-list-create'
    path('unit-types/<int:pk>/', UnitTypeDetailView.as_view(), name='unit-type-detail'),  # Changed from 'unittype-detail'

    # Subscription endpoints
    path('subscription-status/', SubscriptionStatusView.as_view(), name='subscription-status'),
    path('update-till-number/', UpdateTillNumberView.as_view(), name='update-till-number'),
    path('admin/landlord-subscriptions/', AdminLandlordSubscriptionStatusView.as_view(), name='admin-landlord-subscriptions'),
    path('dashboard-stats/', LandlordDashboardStatsView.as_view(), name='dashboard-stats'),
    path('adjust-rent/', AdjustRentView.as_view(), name='adjust-rent'),

    # Other endpoints
    path('update-reminder-preferences/', UpdateReminderPreferencesView.as_view(), name='update-reminder-preferences'),
    path('available-units/', LandlordAvailableUnitsView.as_view(), name='available-units'),  # Changed from 'landlord-available-units'
    path('welcome/', WelcomeView.as_view(), name='welcome'),

    # New endpoints for contexts
    path('tenants/', UserListView.as_view(), name='tenants-list'),
    path('landlords/', LandlordsListView.as_view(), name='landlords-list'),
    path('pending-applications/', PendingApplicationsView.as_view(), name='pending-applications'),
    path('evicted-tenants/', EvictedTenantsView.as_view(), name='evicted-tenants'),

    path('auth/tenant/step/<int:step>/', TenantRegistrationStepView.as_view(), name='tenant-registration-step'),
    path('auth/landlord/step/<int:step>/', LandlordRegistrationStepView.as_view(), name='landlord-registration-step'),
    path('auth/tenant/complete/', CompleteTenantRegistrationView.as_view(), name='complete-tenant-registration'),
    path('auth/landlord/complete/', CompleteLandlordRegistrationView.as_view(), name='complete-landlord-registration'),
]
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status
from accounts.serializers import (
    PropertySerializer,
    UnitSerializer,
    UnitNumberSerializer,
    UserSerializer,
    PasswordResetSerializer,
    PasswordResetConfirmSerializer,
    ReminderPreferencesSerializer,
    AvailableUnitsSerializer,
)
from rest_framework.permissions import IsAuthenticated
from django.core.cache import cache
from .models import Property, Unit, CustomUser, Subscription, UnitType
from payments.models import Payment
from .permissions import IsLandlord, IsTenant, IsSuperuser, HasActiveSubscription
from communication.models import Report
from communication.serializers import ReportSerializer
from django.core.exceptions import ValidationError

import logging

import uuid

logger = logging.getLogger(__name__)

from django.http import HttpResponse
from django.contrib.auth.decorators import login_required
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.db.models import Count, Sum, Q
from django.utils import timezone
from datetime import timedelta
from decimal import Decimal

# accounts/views.py
from rest_framework_simplejwt.views import TokenObtainPairView
from .serializers import MyTokenObtainPairSerializer
from .serializers import UnitTypeSerializer

class MyTokenObtainPairView(TokenObtainPairView):
    serializer_class = MyTokenObtainPairSerializer


class UnitTypeListCreateView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        unit_types = request.user.unit_types.all()
        serializer = UnitTypeSerializer(unit_types, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = UnitTypeSerializer(data=request.data)
        if serializer.is_valid():
            unit_type = serializer.save(landlord=request.user)

            # Automatically create units based on the unit_count
            unit_count = int(request.data.get('unit_count', 1))
            property_id = request.data.get('property_id')
            
            if property_id and unit_count > 0:
                try:
                    property_obj = Property.objects.get(id=property_id, landlord=request.user)
                    self.create_units_for_unit_type(property_obj, unit_type, unit_count)
                except Property.DoesNotExist:
                    return Response({"error": "Property not found or you do not have permission"}, status=404)
            
            return Response(serializer.data, status=201)
        return Response(serializer.errors, status=400)
    
    def create_units_for_unit_type(self, property_obj, unit_type, unit_count):
        """Create multiple units for a given unit type"""
        # Get existing units to determine next unit number
        existing_units = Unit.objects.filter(property_obj=property_obj)
        last_unit = existing_units.order_by('-unit_number').first()

        if last_unit and last_unit.unit_number.isdigit():
            start_number = int(last_unit.unit_number) + 1
        else:
            start_number = 1

        units_created = []
        for i in range(unit_count):
            unit_number = start_number + i
            unit_code = f"U-{property_obj.id}-{unit_type.name.replace(' ', '-')}-{unit_number}"

            unit = Unit.objects.create(
                property_obj=property_obj,
                unit_code=unit_code,
                unit_number=str(unit_number),
                unit_type=unit_type,
                is_available=True,
                rent=unit_type.rent,
                deposit=unit_type.deposit,
            )
            units_created.append(unit)

        # Invalidate caches after creating units
        cache.delete(f"landlord:{unit_type.landlord.id}:properties")
        cache.delete(f"property:{property_obj.id}:units")

        return units_created


class LandlordDashboardStatsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        landlord = request.user

        # Total active tenants: tenants assigned to units of this landlord and active
        total_active_tenants = CustomUser.objects.filter(
            user_type='tenant',
            is_active=True,
            unit__property_obj__landlord=landlord
        ).distinct().count()

        # Total units available
        total_units_available = Unit.objects.filter(
            property_obj__landlord=landlord,
            is_available=True
        ).count()

        # Total units occupied
        total_units_occupied = Unit.objects.filter(
            property_obj__landlord=landlord,
            is_available=False
        ).count()

        # Monthly revenue: sum of successful rent payments in the current month for this landlord
        now = timezone.now()
        start_of_month = now.replace(day=1, hour=0, minute=0, second=0, microsecond=0)
        monthly_revenue_agg = Payment.objects.filter(
            unit__property_obj__landlord=landlord,
            payment_type='rent',
            status='Success',
            transaction_date__gte=start_of_month,
            transaction_date__lte=now
        ).aggregate(total=Sum('amount'))
        monthly_revenue = monthly_revenue_agg['total'] or 0

        data = {
            "total_active_tenants": total_active_tenants,
            "total_units_available": total_units_available,
            "total_units_occupied": total_units_occupied,
            "monthly_revenue": float(monthly_revenue),
        }

        return Response(data)


class UnitTypeDetailView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get_object(self, pk, user):
        return UnitType.objects.get(id=pk, landlord=user)

    def get(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            serializer = UnitTypeSerializer(ut)
            return Response(serializer.data)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)

    def put(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            serializer = UnitTypeSerializer(ut, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)

    def delete(self, request, pk):
        try:
            ut = self.get_object(pk, request.user)
            ut.delete()
            return Response({"message": "UnitType deleted"}, status=200)
        except UnitType.DoesNotExist:
            return Response({"error": "UnitType not found"}, status=404)


# Lists a single user (cached)
# View to get user details
class UserDetailView(APIView):
    permission_classes = [IsAuthenticated, HasActiveSubscription]

    def get(self, request, user_id):
        cache_key = f"user:{user_id}"
        user_data = cache.get(cache_key)

        if not user_data:
            try:
                user = CustomUser.objects.get(id=user_id)
                serializer = UserSerializer(user)
                user_data = serializer.data
                cache.set(cache_key, user_data, timeout=300)  # cache for 5 minutes
            except CustomUser.DoesNotExist:
                return Response({"error": "User not found"}, status=404)

        return Response(user_data)


# New admin view to list landlords and their subscription statuses (superuser only)
class AdminLandlordSubscriptionStatusView(APIView):
    permission_classes = [IsAuthenticated, IsSuperuser]

    def get(self, request):
        landlords = CustomUser.objects.filter(user_type='landlord')
        data = []
        for landlord in landlords:
            subscription = getattr(landlord, 'subscription', None)
            status = 'Subscribed' if subscription and subscription.is_active() else 'Inactive or None'
            data.append({
                'landlord_id': landlord.id,
                'email': landlord.email,
                'name': landlord.full_name,
                'subscription_plan': subscription.plan if subscription else 'None',
                'subscription_status': status,
                'expiry_date': subscription.expiry_date if subscription else None,
            })
        return Response(data)


# Lists all tenants (cached)
# View to list all tenants (landlord only)
class UserListView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        cache_key = f"tenants:list:{request.user.id}"
        tenants_data = cache.get(cache_key)

        if not tenants_data:
            tenants = CustomUser.objects.filter(
                user_type="tenant",
                is_active=True,
                unit__property_obj__landlord=request.user
            ).distinct()
            serializer = UserSerializer(tenants, many=True)
            tenants_data = serializer.data
            cache.set(cache_key, tenants_data, timeout=300)

        return Response(tenants_data)


# Create a new user (invalidate cache)
# View to create a new user Landlord or Tenant
class UserCreateView(APIView):
    def post(self, request):
        print("Signup request received:", request.data)  # Debug logging
        
        serializer = UserSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            print(f"User created successfully: {user.email}, ID: {user.id}")  # Debug logging

            # Landlord onboarding: optionally auto-create properties and units if provided
            if user.user_type == 'landlord':
                # Expect optional 'properties' array in request.data, each item: {name, city, state, unit_count, vacant_units}
                properties = request.data.get('properties')
                from .models import Property, Unit, UnitType
                import uuid

                if properties and isinstance(properties, list):
                    for prop in properties:
                        name = prop.get('name') or f"Property-{uuid.uuid4().hex[:6].upper()}"
                        city = prop.get('city', '')
                        state = prop.get('state', '')
                        unit_count = int(prop.get('unit_count', 0))
                        p = Property.objects.create(landlord=user, name=name, city=city, state=state, unit_count=unit_count)

                        # Create at least one unit if unit_count > 0
                        for i in range(1, unit_count + 1):
                            unit_number = str(i)
                            unit_code = f"U-{p.id}-{i}"
                            # Determine vacancy status based on optional vacant_units or default all vacant
                            vacant_units = int(prop.get('vacant_units', unit_count))
                            is_available = i <= vacant_units

                            # Optionally link to a unit_type if provided via name
                            unit_type_obj = None
                            unit_type_name = prop.get('unit_type')
                            if unit_type_name:
                                unit_type_obj, _ = UnitType.objects.get_or_create(landlord=user, name=unit_type_name)

                            Unit.objects.create(
                                property_obj=p,
                                unit_code=unit_code,
                                unit_number=unit_number,
                                unit_type=unit_type_obj,
                                is_available=is_available,
                                rent=unit_type_obj.rent if unit_type_obj else 0,
                                deposit=unit_type_obj.deposit if unit_type_obj else 0,
                            )

            # Tenant created: attempt to assign unit if landlord_code and unit_code provided
            if user.user_type == "tenant":
                cache.delete("tenants:list")
                landlord_code = request.data.get('landlord_code')
                unit_code = request.data.get('unit_code')
                if landlord_code and unit_code:
                    try:
                        landlord = CustomUser.objects.get(landlord_code=landlord_code, user_type='landlord')
                        unit = Unit.objects.get(unit_code=unit_code, property_obj__landlord=landlord)
                        # Check for deposit payments
                        from payments.models import Payment
                        deposit_payments = Payment.objects.filter(
                            tenant=user,
                            unit=unit,
                            payment_type='deposit',
                            status='Success',
                            amount__gte=unit.deposit
                        )
                        if deposit_payments.exists():
                            unit.tenant = user
                            unit.is_available = False
                            unit.save()
                        else:
                            # leave unassigned; frontend should request deposit
                            pass
                    except CustomUser.DoesNotExist:
                        # landlord not found; ignore
                        pass
                    except Unit.DoesNotExist:
                        pass

            return Response(serializer.data, status=201)
        else:
            print("Serializer errors:", serializer.errors)  # Debug logging
            return Response(serializer.errors, status=400)


# Create a new property (invalidate landlord cache)
# View to create a new property (landlord only)
PLAN_LIMITS = {
    "free": 2,         # trial landlords can only create 2 properties
    "starter": 3,      # starter (up to 10 units) -> small number of properties
    "basic": 10,       # basic (10-50 units)
    "professional": 25,# professional (50-100 units)
    "onetime": None,   # unlimited
}

class CreatePropertyView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        logger.info(f"CreatePropertyView: User {request.user.id} attempting to create property")
        user = request.user

        # Fetch subscription
        try:
            subscription = Subscription.objects.get(user=user)
            logger.info(f"Subscription found: {subscription.plan}")
        except Subscription.DoesNotExist:
            logger.error(f"No subscription found for user {user.id}")
            return Response({"error": "No active subscription found."}, status=403)

        plan = subscription.plan.lower()

        # Check if subscription is active
        if not subscription.is_active():
            logger.warning(f"Subscription expired for user {user.id}")
            return Response({"error": "Your subscription has expired. Please renew or upgrade."}, status=403)

        # Get plan limit
        max_properties = PLAN_LIMITS.get(plan)
        if max_properties is None and plan != "onetime":
            return Response({"error": f"Unknown plan type: {plan}"}, status=400)

        # Count current properties
        current_count = Property.objects.filter(landlord=user).count()
        logger.info(f"Current properties count: {current_count}, max: {max_properties}")
        if plan != "onetime" and current_count >= max_properties:
            return Response({
                "error": f"Your current plan ({plan}) allows a maximum of {max_properties} properties. Upgrade to add more."
            }, status=403)

        # Proceed with creation
        serializer = PropertySerializer(data=request.data)
        if serializer.is_valid():
            logger.info(f"Serializer valid, saving property for user {user.id}")
            property = serializer.save(landlord=user)
            try:
                cache.delete(f"landlord:{user.id}:properties")  # clear cache if you're caching landlord properties
                logger.info(f"Cache cleared for user {user.id}")
            except Exception as e:
                logger.warning(f"Cache delete failed: {e}")
            logger.info(f"Property created successfully: {property.id}")
            return Response(serializer.data, status=201)

        logger.error(f"Serializer errors: {serializer.errors}")
        return Response(serializer.errors, status=400)

# List landlord properties (cached)
class LandlordPropertiesView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        cache_key = f"landlord:{request.user.id}:properties"
        properties_data = cache.get(cache_key)

        if not properties_data:
            properties = Property.objects.filter(landlord=request.user)
            serializer = PropertySerializer(properties, many=True)
            properties_data = serializer.data
            cache.set(cache_key, properties_data, timeout=300)

        return Response(properties_data)


# Create a new unit (invalidate landlord cache)
class CreateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        serializer = UnitSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            unit = serializer.save()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{unit.property_obj.id}:units")
            return Response(serializer.data, status=201)
        return Response(serializer.errors, status=400)


# List units of a property (cached)
class PropertyUnitsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request, property_id):
        cache_key = f"property:{property_id}:units"
        units_data = cache.get(cache_key)

        if not units_data:
            try:
                property = Property.objects.get(id=property_id, landlord=request.user)
                units = Unit.objects.filter(property_obj=property)
                serializer = UnitSerializer(units, many=True)
                units_data = serializer.data
                cache.set(cache_key, units_data, timeout=300)
            except Property.DoesNotExist:
                return Response(
                    {"error": "Property not found or you do not have permission"},
                    status=404,
                )

        return Response(units_data)


# Assign tenant to unit (invalidate cache)
class AssignTenantView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    @method_decorator(csrf_exempt)
    def dispatch(self, *args, **kwargs):
        return super().dispatch(*args, **kwargs)

    def post(self, request, unit_id, tenant_id):
        logger.info(f"AssignTenantView: Landlord {request.user.id} attempting to assign tenant {tenant_id} to unit {unit_id}")

        try:
            # Validate unit exists and belongs to landlord
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            logger.info(f"Unit found: {unit.unit_code}, available: {unit.is_available}")

            # Validate unit is available
            if not unit.is_available:
                logger.warning(f"Unit {unit_id} is not available for assignment")
                return Response({
                    "error": "Unit is not available for assignment",
                    "status": "failed"
                }, status=400)

            # Validate tenant exists and is a tenant
            tenant = CustomUser.objects.get(id=tenant_id, user_type="tenant")
            logger.info(f"Tenant found: {tenant.full_name} (ID: {tenant.id})")

            # Check if tenant already has a unit assigned
            existing_unit = Unit.objects.filter(tenant=tenant).first()
            if existing_unit:
                logger.warning(f"Tenant {tenant_id} already has unit {existing_unit.id} assigned")
                return Response({
                    "error": f"Tenant already has unit {existing_unit.unit_number} assigned",
                    "status": "failed"
                }, status=400)

            # CHECK IF DEPOSIT IS PAID BEFORE ASSIGNMENT
            from payments.models import Payment
            deposit_paid = Payment.objects.filter(
                tenant=tenant,
                unit=unit,
                payment_type='deposit',
                status='Success',
                amount__gte=unit.deposit
            ).exists()
            
            if not deposit_paid:
                logger.warning(f"Tenant {tenant_id} has not paid deposit for unit {unit_id}")
                return Response({
                    "error": "Tenant must pay deposit before being assigned to unit",
                    "status": "failed"
                }, status=400)

            # If deposit is paid, assign tenant immediately
            unit.tenant = tenant
            unit.is_available = False
            unit.save()

            # Invalidate caches
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{unit.property_obj.id}:units")

            logger.info(f"✅ Tenant {tenant.full_name} assigned to unit {unit.unit_number}")

            return Response({
                'message': f'Tenant {tenant.full_name} successfully assigned to unit {unit.unit_number}',
                'status': 'success'
            }, status=200)

        except Unit.DoesNotExist:
            logger.error(f"Unit {unit_id} not found or not owned by landlord {request.user.id}")
            return Response({
                "error": "Unit not found or you do not have permission",
                "status": "failed"
            }, status=404)
        except CustomUser.DoesNotExist:
            logger.error(f"Tenant {tenant_id} not found or invalid user type")
            return Response({
                "error": "Tenant not found or invalid user type",
                "status": "failed"
            }, status=404)
        except Exception as e:
            logger.error(f"Unexpected error in AssignTenantView: {str(e)}")
            return Response({
                "error": "An unexpected error occurred",
                "status": "failed"
            }, status=500)


# Password reset
class PasswordResetView(APIView):
    def post(self, request):
        serializer = PasswordResetSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(
                {"message": "Password reset email sent."}, status=status.HTTP_200_OK
            )
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
# Update property
class UpdatePropertyView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def put(self, request, property_id):
        try:
            property = Property.objects.get(id=property_id, landlord=request.user)
            serializer = PropertySerializer(property, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"landlord:{request.user.id}:properties")
                cache.delete(f"property:{property_id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Property.DoesNotExist:
            return Response({"error": "Property not found or you do not have permission"}, status=404)

    def delete(self, request, property_id):
        try:
            property = Property.objects.get(id=property_id, landlord=request.user)
            property.delete()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{property_id}:units")
            return Response({"message": "Property deleted successfully."}, status=200)
        except Property.DoesNotExist:
            return Response({"error": "Property not found or you do not have permission"}, status=404)

# Update unit
class UpdateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def put(self, request, unit_id):
        try:
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            serializer = UnitSerializer(unit, data=request.data, partial=True, context={'request': request})
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"landlord:{request.user.id}:properties")
                cache.delete(f"property:{unit.property_obj.id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Unit.DoesNotExist:
            return Response({"error": "Unit not found or you do not have permission"}, status=404)

    def delete(self, request, unit_id):
        try:
            unit = Unit.objects.get(id=unit_id, property_obj__landlord=request.user)
            property_id = unit.property_obj.id
            unit.delete()
            cache.delete(f"landlord:{request.user.id}:properties")
            cache.delete(f"property:{property_id}:units")
            return Response({"message": "Unit deleted successfully."}, status=200)
        except Unit.DoesNotExist:
            return Response({"error": "Unit not found or you do not have permission"}, status=404)


class TenantUpdateUnitView(APIView):
    permission_classes = [IsAuthenticated, IsTenant]

    def put(self, request):
        try:
            unit = Unit.objects.get(tenant=request.user)
            serializer = UnitNumberSerializer(unit, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"property:{unit.property_obj.id}:units")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except Unit.DoesNotExist:
            return Response({"error": "No unit assigned to you"}, status=404)

# Update user
class UpdateUserView(APIView):  
    permission_classes = [IsAuthenticated]

    def put(self, request, user_id):
        if request.user.id != user_id:
            return Response({"error": "You do not have permission to update this user."}, status=403)
        try:
            user = CustomUser.objects.get(id=user_id)
            serializer = UserSerializer(user, data=request.data, partial=True)
            if serializer.is_valid():
                serializer.save()
                cache.delete(f"user:{user_id}")
                if user.user_type == "tenant":
                    cache.delete("tenants:list")
                return Response(serializer.data)
            return Response(serializer.errors, status=400)
        except CustomUser.DoesNotExist:
            return Response({"error": "User not found"}, status=404)

    def delete(self, request, user_id):
        if request.user.id != user_id:
            return Response({"error": "You do not have permission to delete this user."}, status=403)
        try:
            user = CustomUser.objects.get(id=user_id)
            user.delete()
            cache.delete(f"user:{user_id}")
            if user.user_type == "tenant":
                cache.delete("tenants:list")
            return Response({"message": "User deleted successfully."}, status=200)
        except CustomUser.DoesNotExist:
            return Response({"error": "User not found"}, status=404)


class AdjustRentView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def post(self, request):
        landlord = request.user
        adjustment_type = request.data.get('adjustment_type')  # 'percentage' or 'fixed'
        value = request.data.get('value')  # decimal, positive for increase, negative for decrease
        unit_type_id = request.data.get('unit_type_id')  # optional, if provided, adjust only units of this type

        logger.info(f"AdjustRentView POST: Landlord {landlord.id} adjusting rent, adjustment_type={adjustment_type}, value={value}, unit_type_id={unit_type_id}")

        if adjustment_type not in ['percentage', 'fixed']:
            return Response({"error": "adjustment_type must be 'percentage' or 'fixed'"}, status=400)

        try:
            value = Decimal(value)
        except (ValueError, TypeError):
            return Response({"error": "value must be a valid number"}, status=400)

        # Filter units
        units = Unit.objects.filter(property_obj__landlord=landlord)
        if unit_type_id:
            try:
                unit_type = UnitType.objects.get(id=unit_type_id, landlord=landlord)
                units = units.filter(unit_type=unit_type)
            except UnitType.DoesNotExist:
                return Response({"error": "UnitType not found or not owned by you"}, status=404)

        updated_count = 0
        for unit in units:
            old_rent = unit.rent
            if adjustment_type == 'percentage':
                new_rent = old_rent * (Decimal(1) + value / Decimal(100))
            else:  # fixed
                new_rent = old_rent + value
            # Ensure rent doesn't go negative
            new_rent = max(Decimal(0), new_rent)
            unit.rent = new_rent
            unit.save()  # This will update rent_remaining
            updated_count += 1

        logger.info(f"AdjustRentView POST: Rent adjusted for {updated_count} units by landlord {landlord.id}")

        # Invalidate caches
        cache.delete(f"landlord:{landlord.id}:properties")
        # Also invalidate rent_summary cache
        from payments.views import RentSummaryView
        cache.delete(f"rent_summary:{landlord.id}")

        return Response({"message": f"Rent adjusted for {updated_count} units successfully"})

    def put(self, request):
        landlord = request.user
        new_rent = request.data.get('new_rent')
        unit_type_id = request.data.get('unit_type_id')  # optional

        logger.info(f"AdjustRentView PUT: Landlord {landlord.id} setting new rent, new_rent={new_rent}, unit_type_id={unit_type_id}")

        if new_rent is None:
            return Response({"error": "new_rent is required"}, status=400)

        try:
            new_rent = Decimal(new_rent)
        except (ValueError, TypeError):
            return Response({"error": "new_rent must be a valid number"}, status=400)

        units = Unit.objects.filter(property_obj__landlord=landlord)
        if unit_type_id:
            try:
                unit_type = UnitType.objects.get(id=unit_type_id, landlord=landlord)
                units = units.filter(unit_type=unit_type)
            except UnitType.DoesNotExist:
                return Response({"error": "UnitType not found or not owned by you"}, status=404)

        updated_count = 0
        for unit in units:
            unit.rent = new_rent
            unit.save()
            updated_count += 1

        logger.info(f"AdjustRentView PUT: Rent set to {new_rent} for {updated_count} units by landlord {landlord.id}")

        # Invalidate caches
        cache.delete(f"landlord:{landlord.id}:properties")
        from payments.views import RentSummaryView
        cache.delete(f"rent_summary:{landlord.id}")

        return Response({"message": f"Rent set to {new_rent} for {updated_count} units successfully"})

# View to check subscription status (landlord only)
class SubscriptionStatusView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord]

    def get(self, request):
        user = request.user
        try:
            subscription = Subscription.objects.get(user=user)
            data = {
                "plan": subscription.plan,
                "is_active": subscription.is_active(),
                "expiry_date": subscription.expiry_date,
                "status": "Subscribed" if subscription.is_active() else "Inactive"
            }
        except Subscription.DoesNotExist:
            data = {"status": "No subscription found"}
        return Response(data)

# View to update landlord's Mpesa till number (landlord only)
class UpdateTillNumberView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def patch(self, request):
        user = request.user
        till_number = request.data.get('mpesa_till_number')
        if not till_number:
            return Response({"error": "mpesa_till_number is required"}, status=400)

        user.mpesa_till_number = till_number
        user.save()
        return Response({"message": "Till number updated successfully", "mpesa_till_number": till_number})

    def put(self, request):
        return self.patch(request)


# Endpoint to get or update the currently authenticated user
class MeView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        serializer = UserSerializer(request.user)
        return Response(serializer.data)

    def patch(self, request):
        serializer = UserSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            # invalidate cache for this user
            cache.delete(f"user:{request.user.id}")
            return Response(serializer.data)
        return Response(serializer.errors, status=400)

    def put(self, request):
        return self.patch(request)


# View to update tenant reminder preferences
class UpdateReminderPreferencesView(APIView):
    permission_classes = [IsAuthenticated, IsTenant]

    def patch(self, request):
        serializer = ReminderPreferencesSerializer(request.user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=400)


# Password reset confirm view
class PasswordResetConfirmView(APIView):
    def post(self, request):
        serializer = PasswordResetConfirmSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "Password has been reset successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


# View to list available units for landlords to share with tenants
class LandlordAvailableUnitsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        units = Unit.objects.filter(property_obj__landlord=request.user, is_available=True)
        serializer = AvailableUnitsSerializer(units, many=True)
        return Response(serializer.data)


# New endpoint to log requests and return a welcome message
class WelcomeView(APIView):
    def get(self, request):
        logger.info(f"Request received: {request.method} {request.path}")
        return Response({"message": "Welcome to the Makau Rentals API!"})


class LandlordsListView(APIView):
    permission_classes = [IsAuthenticated, IsSuperuser]

    def get(self, request):
        landlords = CustomUser.objects.filter(user_type='landlord')
        data = []
        for landlord in landlords:
            subscription = getattr(landlord, 'subscription', None)
            status = 'Subscribed' if subscription and subscription.is_active() else 'Inactive or None'
            data.append({
                'id': landlord.id,
                'email': landlord.email,
                'name': landlord.full_name,
                'subscription_plan': subscription.plan if subscription else 'None',
                'subscription_status': status,
                'expiry_date': subscription.expiry_date if subscription else None,
            })
        return Response(data)


class PendingApplicationsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        # For now, return tenants without assigned units (pending applications)
        tenants = CustomUser.objects.filter(
            user_type="tenant",
            is_active=True,
            unit__isnull=True
        )
        serializer = UserSerializer(tenants, many=True)
        return Response(serializer.data)


class EvictedTenantsView(APIView):
    permission_classes = [IsAuthenticated, IsLandlord, HasActiveSubscription]

    def get(self, request):
        # For now, return inactive tenants that were previously assigned to landlord's units
        evicted_tenants = CustomUser.objects.filter(
            user_type="tenant",
            is_active=False,
            unit__property_obj__landlord=request.user
        ).distinct()
        serializer = UserSerializer(evicted_tenants, many=True)
        return Response(serializer.data)
    
# views.py - Add these views


class TenantRegistrationStepView(APIView):
    def post(self, request, step):
        data = request.data
        session_id = data.get('session_id') or str(uuid.uuid4())
        
        # Store step data in cache (or database)
        cache_key = f"tenant_registration_{session_id}_step_{step}"
        cache.set(cache_key, data, timeout=3600)  # 1 hour expiry
        
        return Response({
            'session_id': session_id,
            'step': step,
            'status': 'saved',
            'message': f'Step {step} data saved successfully'
        })

class LandlordRegistrationStepView(APIView):
    def post(self, request, step):
        data = request.data
        session_id = data.get('session_id') or str(uuid.uuid4())
        
        # Store step data in cache
        cache_key = f"landlord_registration_{session_id}_step_{step}"
        cache.set(cache_key, data, timeout=3600)
        
        return Response({
            'session_id': session_id,
            'step': step,
            'status': 'saved',
            'message': f'Step {step} data saved successfully'
        })

class CompleteTenantRegistrationView(APIView):
    def post(self, request):
        data = request.data
        session_id = data.get('session_id')
        
        # Retrieve all step data from cache
        all_data = {}
        for step in range(2, 7):  # Steps 2-6
            cache_key = f"tenant_registration_{session_id}_step_{step}"
            step_data = cache.get(cache_key)
            if step_data:
                all_data.update(step_data)
        
        # Merge with final data
        all_data.update(data)
        
        # Create the user (your existing user creation logic)
        try:
            user = CustomUser.objects.create_user(
                email=all_data['email'],
                full_name=all_data['full_name'],
                user_type='tenant',
                password=all_data['password'],
                phone_number=all_data['phone_number'],
                government_id=all_data['government_id'],
                emergency_contact=all_data['emergency_contact']
            )
            
            # Clean up cache
            for step in range(2, 7):
                cache_key = f"tenant_registration_{session_id}_step_{step}"
                cache.delete(cache_key)
            
            return Response({
                'status': 'success',
                'user_id': user.id,
                'message': 'Tenant registration completed successfully'
            })
            
        except Exception as e:
            return Response({
                'status': 'error',
                'message': str(e)
            }, status=400)

class CompleteLandlordRegistrationView(APIView):
    def post(self, request):
        """
        Complete landlord registration after all steps are done
        """
        try:
            data = request.data
            session_id = data.get('session_id')
            
            if not session_id:
                return Response({
                    'status': 'error',
                    'message': 'Session ID is required'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Retrieve all step data from cache
            all_data = {}
            for step in range(2, 5):  # Steps 2-4 for landlord
                cache_key = f"landlord_registration_{session_id}_step_{step}"
                step_data = cache.get(cache_key)
                if step_data:
                    # Remove step field if present
                    step_data.pop('step', None)
                    all_data.update(step_data)

            # Merge with final data from current request
            all_data.update(data)
            
            # Validate required fields
            required_fields = ['full_name', 'email', 'phone_number', 'national_id', 
                             'mpesa_till_number', 'address', 'password']
            
            missing_fields = [field for field in required_fields if not all_data.get(field)]
            if missing_fields:
                return Response({
                    'status': 'error',
                    'message': f'Missing required fields: {", ".join(missing_fields)}'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Check if email already exists
            if CustomUser.objects.filter(email=all_data['email']).exists():
                return Response({
                    'status': 'error',
                    'message': 'Email already exists'
                }, status=status.HTTP_400_BAD_REQUEST)

            # Create the landlord user
            try:
                landlord = CustomUser.objects.create_user(
                    email=all_data['email'],
                    full_name=all_data['full_name'],
                    user_type='landlord',
                    password=all_data['password'],
                    phone_number=all_data['phone_number'],
                    government_id=all_data['national_id'],
                    mpesa_till_number=all_data['mpesa_till_number'],
                    address=all_data.get('address', ''),
                    website=all_data.get('website', '')
                )

                # Create properties and units if provided
                properties_data = all_data.get('properties', [])
                created_properties = []
                
                for property_data in properties_data:
                    try:
                        # Create property
                        property_obj = Property.objects.create(
                            landlord=landlord,
                            name=property_data.get('name', ''),
                            city='Nairobi',  # You might want to extract this from address
                            state='Nairobi',
                            unit_count=len(property_data.get('units', []))
                        )
                        
                        # Create units for this property
                        units_data = property_data.get('units', [])
                        created_units = []
                        
                        for unit_data in units_data:
                            # Create unit type if it doesn't exist
                            unit_type, created = UnitType.objects.get_or_create(
                                landlord=landlord,
                                name=unit_data.get('room_type', 'studio'),
                                defaults={
                                    'deposit': Decimal('0.00'),
                                    'rent': Decimal(unit_data.get('rent', '0')),
                                    'number_of_units': 0
                                }
                            )
                            
                            # Create the unit
                            unit = Unit.objects.create(
                                property_obj=property_obj,
                                unit_number=unit_data.get('unit_number', ''),
                                bedrooms=self.get_bedroom_count(unit_data.get('room_type', 'studio')),
                                bathrooms=1,  # Default
                                unit_type=unit_type,
                                rent=Decimal(unit_data.get('rent', '0')),
                                deposit=Decimal(unit_data.get('rent', '0')),  # Deposit = 1 month rent
                                is_available=True
                            )
                            created_units.append(unit.id)
                        
                        created_properties.append({
                            'id': property_obj.id,
                            'name': property_obj.name,
                            'units_count': len(created_units)
                        })
                        
                    except Exception as prop_error:
                        logger.error(f"Error creating property: {str(prop_error)}")
                        continue

                # Create subscription for landlord (free trial)
                subscription = Subscription.objects.create(
                    user=landlord,
                    plan="free",
                    expiry_date=timezone.now() + timedelta(days=60)
                )

                # Clean up cache
                for step in range(2, 5):
                    cache_key = f"landlord_registration_{session_id}_step_{step}"
                    cache.delete(cache_key)

                # Prepare response data
                response_data = {
                    'status': 'success',
                    'user_id': landlord.id,
                    'landlord_code': landlord.landlord_code,
                    'email': landlord.email,
                    'full_name': landlord.full_name,
                    'properties_created': created_properties,
                    'subscription': {
                        'plan': subscription.plan,
                        'expiry_date': subscription.expiry_date
                    },
                    'message': 'Landlord registration completed successfully'
                }

                # Send welcome email (you can implement this)
                self.send_welcome_email(landlord)

                return Response(response_data, status=status.HTTP_201_CREATED)
                
            except ValidationError as e:
                return Response({
                    'status': 'error',
                    'message': str(e)
                }, status=status.HTTP_400_BAD_REQUEST)
                
            except Exception as e:
                logger.error(f"Error creating landlord user: {str(e)}")
                return Response({
                    'status': 'error',
                    'message': 'Failed to create landlord account'
                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        except Exception as e:
            logger.error(f"Unexpected error in landlord registration: {str(e)}")
            return Response({
                'status': 'error',
                'message': 'Internal server error'
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

    def get_bedroom_count(self, room_type):
        """
        Map room type string to bedroom count
        """
        room_type_mapping = {
            'studio': 0,
            '1-bedroom': 1,
            '2-bedroom': 2,
            '3-bedroom': 3
        }
        return room_type_mapping.get(room_type, 0)

    def send_welcome_email(self, landlord):
        """
        Send welcome email to landlord
        """
        try:
            subject = "Welcome to TenantHub - Your Landlord Account is Ready!"
            message = f"""
            Hello {landlord.full_name},

            Welcome to TenantHub! Your landlord account has been successfully created.

            Account Details:
            - Landlord Code: {landlord.landlord_code}
            - Email: {landlord.email}
            - M-Pesa Till: {landlord.mpesa_till_number}

            Your 60-day free trial has been activated. You can now:
            - Manage your properties
            - Add units and set rents
            - Receive rent payments via M-Pesa
            - Track tenant payments

            Login to your dashboard to get started.

            Best regards,
            TenantHub Team
            """

            # For now, just log the email. Integrate with your email service later.
            logger.info(f"Welcome email prepared for {landlord.email}: {subject}")
            
            # Uncomment to actually send email when you have email setup:
            # send_mail(
            #     subject=subject,
            #     message=message,
            #     from_email=settings.DEFAULT_FROM_EMAIL,
            #     recipient_list=[landlord.email],
            #     fail_silently=False,
            # )
            
        except Exception as e:
            logger.error(f"Failed to send welcome email: {str(e)}")
//Payments app
from django.db import models
from accounts.models import CustomUser, Unit, Subscription
from datetime import timedelta
from django.core.exceptions import ValidationError
import uuid

# Add validation and better field definitions
class Payment(models.Model):
    PAYMENT_TYPES = [
        ('rent', 'Rent'),
        ('deposit', 'Deposit'),
        ('maintenance', 'Maintenance'),
        ('other', 'Other'),
    ]
    
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('completed', 'Completed'),
        ('failed', 'Failed'),
        ('cancelled', 'Cancelled'),
    ]

    # Make tenant and unit required for rent payments
    tenant = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        limit_choices_to={'user_type': 'tenant'},
        related_name='payments'
    )
    unit = models.ForeignKey(Unit, on_delete=models.CASCADE, related_name='payments')
    
    # Add more fields for better tracking
    reference_number = models.CharField(max_length=50, unique=True, blank=True)
    description = models.TextField(blank=True)
    payment_method = models.CharField(max_length=20, default='mpesa', choices=[
        ('mpesa', 'M-Pesa'),
        ('cash', 'Cash'),
        ('bank', 'Bank Transfer'),
    ])
    
    # Add created and updated timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def clean(self):
        if self.payment_type == 'rent' and not self.unit:
            raise ValidationError("Rent payments must be associated with a unit")
            
    def save(self, *args, **kwargs):
        # Generate reference number if not set
        if not self.reference_number:
            self.reference_number = f"PAY-{uuid.uuid4().hex[:12].upper()}"
        super().save(*args, **kwargs)


class SubscriptionPayment(models.Model):
    user = models.ForeignKey(
        CustomUser,
        on_delete=models.CASCADE,
        null=True,
        blank=True
    )
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    mpesa_receipt_number = models.CharField(
        max_length=50,
        blank=True,  # Allow empty strings
        null=True,
        default=""
    )
    transaction_date = models.DateTimeField(auto_now_add=True)
    subscription_type = models.CharField(max_length=20, choices=Subscription.PLAN_CHOICES)
    status = models.CharField(
        max_length=20,
        choices=[("Pending", "Pending"), ("Success", "Success"), ("Failed", "Failed")],
        default="Pending"
    )

    class Meta:
        # Simple unique constraint for non-empty receipt numbers
        constraints = [
            models.UniqueConstraint(
                fields=['mpesa_receipt_number'],
                name='unique_mpesa_receipt',
                condition=~models.Q(mpesa_receipt_number='')
            )
        ]

    def __str__(self):
        return f"Subscription Payment {self.id} - {self.subscription_type}"

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)

    def _get_plan_duration(self):
        durations = {
            "free": timedelta(days=60),
            "starter": timedelta(days=30),
            "basic": timedelta(days=30),
            "professional": timedelta(days=30),
            # "onetime" will be treated as lifetime (None) by the subscription logic
        }
        return durations.get(self.subscription_type, timedelta(days=30))
import requests
from django.conf import settings
from requests.auth import HTTPBasicAuth
import logging
import datetime
import base64
logger = logging.getLogger(__name__)

def generate_access_token():
    """
    Generate M-Pesa access token with proper error handling
    """
    try:
        # Use sandbox or production URL
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials"
        else:
            url = "https://api.safaricom.co.ke/oauth/v1/generate?grant_type=client_credentials"

        response = requests.get(
            url,
            auth=HTTPBasicAuth(settings.MPESA_CONSUMER_KEY, settings.MPESA_CONSUMER_SECRET),
            timeout=30
        )

        if response.status_code == 200:
            data = response.json()
            return data.get('access_token')
        else:
            logger.error(f"M-Pesa token generation failed: {response.status_code} - {response.text}")
            return None

    except Exception as e:
        logger.error(f"M-Pesa token generation error: {str(e)}")
        return None

def initiate_b2c_payment(amount, recipient, payment_id, remarks="Rent disbursement"):
    """
    Initiate B2C payment to disburse funds to landlord.
    - amount: Amount to disburse (KES)
    - recipient: Landlord's phone number (254XXXXXXXXX format) or till number
    - payment_id: Reference for the payment
    - remarks: Description of the transaction
    Returns response dict or raises ValueError on failure.
    """
    if not settings.MPESA_CONSUMER_KEY or not settings.MPESA_CONSUMER_SECRET:
        raise ValueError("MPESA_CONSUMER_KEY and MPESA_CONSUMER_SECRET must be set in settings.")

    # Generate access token
    access_token = generate_access_token()

    # Use sandbox or production URL based on env
    base_url = "https://sandbox.safaricom.co.ke" if settings.MPESA_ENV == "sandbox" else "https://api.safaricom.co.ke"
    url = f"{base_url}/mpesa/b2c/v1/paymentrequest"

    timestamp = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
    password = base64.b64encode(
        (settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp).encode("utf-8")
    ).decode("utf-8")

    payload = {
        "InitiatorName": settings.MPESA_INITIATOR_NAME,  # Need to add to settings
        "SecurityCredential": settings.MPESA_SECURITY_CREDENTIAL,  # Need to add to settings
        "CommandID": "BusinessPayment",
        "Amount": str(amount),
        "PartyA": settings.MPESA_SHORTCODE,
        "PartyB": recipient,  # Can be phone number or till number
        "Remarks": remarks,
        "QueueTimeOutURL": settings.MPESA_B2C_TIMEOUT_URL,  # Need to add to settings
        "ResultURL": settings.MPESA_B2C_RESULT_URL,  # Need to add to settings
        "Occasion": f"Payment {payment_id}"
    }

    headers = {"Authorization": f"Bearer {access_token}"}

    try:
        response = requests.post(url, json=payload, headers=headers, timeout=30)
        response.raise_for_status()
        data = response.json()
        logger.info(f"B2C payment initiated: {data}")
        return data
    except requests.exceptions.RequestException as e:
        logger.error(f"B2C payment failed: {e}")
        raise ValueError(f"B2C payment error: {str(e)}")
    except Exception as e:
        logger.error(f"Unexpected B2C error: {e}")
        raise ValueError(f"B2C error: {str(e)}")
from rest_framework import serializers
from .models import Payment, SubscriptionPayment


class PaymentSerializer(serializers.ModelSerializer):
    date = serializers.DateTimeField(source='transaction_date', read_only=True)
    phone = serializers.CharField(source='tenant.phone_number', read_only=True)
    tenant_name = serializers.CharField(source='tenant.full_name', read_only=True)

    class Meta:
        model = Payment
        fields = ['id', 'tenant', 'tenant_name', 'unit', 'payment_type', 'amount', 'mpesa_receipt', 'date', 'phone', 'status']
        read_only_fields = ['transaction_date', 'status']


class SubscriptionPaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = SubscriptionPayment
        fields = '__all__'
        read_only_fields = ['transaction_date']
from django.urls import path
from .views import (
    # STK Push + Callbacks
    stk_push,
    stk_push_subscription,
    mpesa_rent_callback,
    mpesa_subscription_callback,
    mpesa_b2c_callback,
    mpesa_deposit_callback,

    # DRF views
    PaymentListCreateView,
    PaymentDetailView,
    SubscriptionPaymentListCreateView,
    SubscriptionPaymentDetailView,
    RentSummaryView,
    UnitTypeListView,
    InitiateDepositPaymentView,
    DepositPaymentStatusView,
    CleanupPendingPaymentsView,
    TestMpesaView,

    # CSV reports
    LandLordCSVView as landlord_csv,
    TenantCSVView as tenant_csv,
)
from django.views.decorators.csrf import csrf_exempt

urlpatterns = [
    # ------------------------------
    # M-PESA STK PUSH + CALLBACKS
    # ------------------------------
    path("stk-push/<int:unit_id>/", stk_push, name="stk-push"),
    path("stk-push-subscription/", stk_push_subscription, name="stk-push-subscription"),
    path("callback/rent/", mpesa_rent_callback, name="mpesa-rent-callback"),
    path("callback/subscription/", mpesa_subscription_callback, name="mpesa-subscription-callback"),
    path("callback/b2c/", mpesa_b2c_callback, name="mpesa-b2c-callback"),
    path("callback/deposit/", mpesa_deposit_callback, name="mpesa-deposit-callback"),

    # ------------------------------
    # RENT PAYMENTS (DRF)
    # ------------------------------
    path("rent-payments/", PaymentListCreateView.as_view(), name="rent-payment-list-create"),
    path("rent-payments/<int:pk>/", PaymentDetailView.as_view(), name="rent-payment-detail"),

    # ------------------------------
    # SUBSCRIPTION PAYMENTS (DRF)
    # ------------------------------
    path("subscription-payments/", SubscriptionPaymentListCreateView.as_view(), name="subscription-payment-list-create"),
    path("subscription-payments/<int:pk>/", SubscriptionPaymentDetailView.as_view(), name="subscription-payment-detail"),
    path("rent-payments/summary/", RentSummaryView.as_view(), name="rent-summary"),

    # ------------------------------
    # UNIT TYPES
    # ------------------------------
    path("unit-types/", UnitTypeListView.as_view(), name="unit-types"),

    # ------------------------------
    # INITIATE DEPOSIT PAYMENT
    # ------------------------------
    path("initiate-deposit/", InitiateDepositPaymentView.as_view(), name="initiate-deposit"),
    path('deposit-status/<int:payment_id>/', DepositPaymentStatusView.as_view(), name='deposit-status'),
    # ------------------------------
    # CSV REPORTS
    # ------------------------------
    path("landlord-csv/<int:property_id>/", landlord_csv.as_view(), name="landlord-csv"),
    path("tenant-csv/<int:unit_id>/", tenant_csv.as_view(), name="tenant-csv"),

    # ------------------------------
    # CLEANUP AND SIMULATION ENDPOINTS
    # ------------------------------
    path("cleanup-pending-payments/", CleanupPendingPaymentsView.as_view(), name="cleanup-pending-payments"),
    # ------------------------------
    # TEST ENDPOINTS
    # ------------------------------
    path("test-mpesa/", TestMpesaView.as_view(), name="test-mpesa"),
]
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework import status, generics
from rest_framework.decorators import api_view, permission_classes
from django.conf import settings
from django.shortcuts import get_object_or_404
from django.core.cache import cache
from django.utils import timezone
from django.db.models import Sum, Q
from django.http import HttpResponse
import json
import requests
from decimal import Decimal
from datetime import datetime, timedelta
import csv
import io

from accounts.models import CustomUser, Unit, UnitType, Property, Subscription
from .models import Payment, SubscriptionPayment
from .generate_token import generate_access_token
from .serializers import PaymentSerializer, SubscriptionPaymentSerializer


# ------------------------------
# M-PESA STK PUSH FUNCTIONS
# ------------------------------

@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def stk_push(request, unit_id):
    """
    Initiate STK push for rent payment
    """
    try:
        unit = get_object_or_404(Unit, id=unit_id)
        tenant = request.user

        # Validate tenant owns the unit
        if unit.tenant != tenant:
            return Response({"error": "You don't have permission to pay for this unit"}, status=status.HTTP_403_FORBIDDEN)

        # Check if rent is already paid
        if unit.rent_remaining <= 0:
            return Response({"error": "Rent is already paid for this unit"}, status=status.HTTP_400_BAD_REQUEST)

        amount = unit.rent_remaining
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_RENT_CALLBACK_URL,
            "AccountReference": f"Rent-{unit.unit_code}",
            "TransactionDesc": f"Rent payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Make STK push request
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="rent"
            )

            # Cache checkout request ID for callback
            cache.set(f"stk_{response_data['CheckoutRequestID']}", {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount)
            }, timeout=300)  # 5 minutes

            return Response({
                "success": True,
                "message": "STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            return Response({
                "error": "Failed to initiate STK push",
                "details": response_data
            }, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@csrf_exempt
@api_view(['POST'])
@permission_classes([IsAuthenticated])
def stk_push_subscription(request):
    """
    Initiate STK push for subscription payment
    """
    try:
        user = request.user
        plan = request.data.get('plan')
        phone_number = request.data.get('phone_number')

        if not plan or not phone_number:
            return Response({"error": "Plan and phone number are required"}, status=status.HTTP_400_BAD_REQUEST)

        # Validate plan
        plan_amounts = {
            'starter': 1000,
            'basic': 2000,
            'professional': 3000
        }

        if plan not in plan_amounts:
            return Response({"error": "Invalid plan"}, status=status.HTTP_400_BAD_REQUEST)

        amount = plan_amounts[plan]

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
        password = settings.MPESA_SHORTCODE + settings.MPESA_PASSKEY + timestamp

        payload = {
            "BusinessShortCode": settings.MPESA_SHORTCODE,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": amount,
            "PartyA": phone_number,
            "PartyB": settings.MPESA_SHORTCODE,
            "PhoneNumber": phone_number,
            "CallBackURL": settings.MPESA_SUBSCRIPTION_CALLBACK_URL,
            "AccountReference": f"Subscription-{user.id}",
            "TransactionDesc": f"Subscription payment for {plan} plan"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Make STK push request
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending subscription payment record
            subscription_payment = SubscriptionPayment.objects.create(
                user=user,
                amount=Decimal(amount),
                subscription_type=plan,
                status="Pending"
            )

            # Cache checkout request ID for callback
            cache.set(f"stk_sub_{response_data['CheckoutRequestID']}", {
                "subscription_payment_id": subscription_payment.id,
                "user_id": user.id,
                "plan": plan,
                "amount": amount
            }, timeout=300)  # 5 minutes

            return Response({
                "success": True,
                "message": "Subscription STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "subscription_payment_id": subscription_payment.id
            })

        else:
            return Response({
                "error": "Failed to initiate subscription STK push",
                "details": response_data
            }, status=status.HTTP_400_BAD_REQUEST)

    except Exception as e:
        return Response({"error": "Internal server error"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# ------------------------------
# M-PESA CALLBACK FUNCTIONS
# ------------------------------

@csrf_exempt
def mpesa_rent_callback(request):
    """
    Handle M-Pesa rent payment callback
    """
    try:
        callback_data = json.loads(request.body)

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})

        if stk_callback.get("ResultCode") == 0:
            # Successful payment
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])

            mpesa_receipt = None
            amount = None

            for item in callback_metadata:
                if item["Name"] == "MpesaReceiptNumber":
                    mpesa_receipt = item["Value"]
                elif item["Name"] == "Amount":
                    amount = item["Value"]

            checkout_request_id = stk_callback.get("CheckoutRequestID")

            # Get cached payment data
            cached_data = cache.get(f"stk_{checkout_request_id}")
            if cached_data:
                payment = Payment.objects.get(id=cached_data["payment_id"])
                payment.status = "Success"
                payment.mpesa_receipt = mpesa_receipt
                payment.save()

                # Update unit rent_paid
                unit = payment.unit
                unit.rent_paid += Decimal(amount)
                unit.save()

                cache.delete(f"stk_{checkout_request_id}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except Exception as e:
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Error"})


@csrf_exempt
def mpesa_subscription_callback(request):
    """
    Handle M-Pesa subscription payment callback
    """
    try:
        callback_data = json.loads(request.body)

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})

        if stk_callback.get("ResultCode") == 0:
            # Successful payment
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])

            mpesa_receipt = None
            amount = None

            for item in callback_metadata:
                if item["Name"] == "MpesaReceiptNumber":
                    mpesa_receipt = item["Value"]
                elif item["Name"] == "Amount":
                    amount = item["Value"]

            checkout_request_id = stk_callback.get("CheckoutRequestID")

            # Get cached subscription payment data
            cached_data = cache.get(f"stk_sub_{checkout_request_id}")
            if cached_data:
                subscription_payment = SubscriptionPayment.objects.get(id=cached_data["subscription_payment_id"])
                subscription_payment.status = "Success"
                subscription_payment.mpesa_receipt_number = mpesa_receipt
                subscription_payment.save()

                # Update user subscription
                user = subscription_payment.user
                subscription = user.subscription
                subscription.plan = subscription_payment.subscription_type
                subscription.expiry_date = timezone.now() + timedelta(days=30)
                subscription.save()

                cache.delete(f"stk_sub_{checkout_request_id}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except Exception as e:
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Error"})


@csrf_exempt
def mpesa_b2c_callback(request):
    """
    Handle M-Pesa B2C payment callback
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"B2C callback received: {callback_data}")

        result = callback_data.get("Result", {})

        if result.get("ResultCode") == 0:
            # Successful B2C payment
            result_parameters = result.get("ResultParameters", {}).get("ResultParameter", [])

            transaction_receipt = None
            transaction_amount = None
            conversation_id = result.get("ConversationID")

            # Extract relevant parameters
            for param in result_parameters:
                if param["Key"] == "TransactionReceipt":
                    transaction_receipt = param["Value"]
                elif param["Key"] == "TransactionAmount":
                    transaction_amount = param["Value"]

            # Get cached B2C payment data if exists
            cached_data = cache.get(f"b2c_{conversation_id}")
            if cached_data:
                # Update payment status or perform business logic here
                # For example, mark disbursement as successful
                logger.info(f"B2C payment successful: Receipt {transaction_receipt}, Amount {transaction_amount}")
                cache.delete(f"b2c_{conversation_id}")
            else:
                logger.info(f"B2C payment successful (no cached data): Receipt {transaction_receipt}, Amount {transaction_amount}")

        else:
            # Failed B2C payment
            logger.error(f"B2C payment failed: {result.get('ResultDesc')}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except Exception as e:
        logger.error(f"B2C callback error: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Error"})


@csrf_exempt
def mpesa_deposit_callback(request):
    """
    Handle M-Pesa deposit payment callback
    """
    try:
        callback_data = json.loads(request.body)
        logger.info(f"Deposit callback received: {callback_data}")

        stk_callback = callback_data.get("Body", {}).get("stkCallback", {})

        if stk_callback.get("ResultCode") == 0:
            # Successful payment
            callback_metadata = stk_callback.get("CallbackMetadata", {}).get("Item", [])

            mpesa_receipt = None
            amount = None

            for item in callback_metadata:
                if item["Name"] == "MpesaReceiptNumber":
                    mpesa_receipt = item["Value"]
                elif item["Name"] == "Amount":
                    amount = item["Value"]

            checkout_request_id = stk_callback.get("CheckoutRequestID")

            # Get cached deposit payment data
            cached_data = cache.get(f"stk_deposit_{checkout_request_id}")
            if cached_data:
                payment = Payment.objects.get(id=cached_data["payment_id"])
                payment.status = "Success"
                payment.mpesa_receipt = mpesa_receipt
                payment.save()

                # Mark unit as occupied
                unit = payment.unit
                unit.is_available = False
                unit.save()

                cache.delete(f"stk_deposit_{checkout_request_id}")
                logger.info(f"Deposit payment successful: {payment.id}")

        return JsonResponse({"ResultCode": 0, "ResultDesc": "Accepted"})

    except Exception as e:
        logger.error(f"Deposit callback error: {str(e)}")
        return JsonResponse({"ResultCode": 1, "ResultDesc": "Error"})


# ------------------------------
# DRF CLASS-BASED VIEWS
# ------------------------------

class PaymentListCreateView(generics.ListCreateAPIView):
    """
    List and create rent payments
    """
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Payment.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            # Landlords can see payments for their properties
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()

    def perform_create(self, serializer):
        serializer.save(tenant=self.request.user)


class PaymentDetailView(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update, and delete rent payment
    """
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Payment.objects.filter(tenant=user)
        elif user.user_type == 'landlord':
            return Payment.objects.filter(unit__property_obj__landlord=user)
        return Payment.objects.none()


class SubscriptionPaymentListCreateView(generics.ListCreateAPIView):
    """
    List and create subscription payments
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return SubscriptionPayment.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class SubscriptionPaymentDetailView(generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve, update, and delete subscription payment
    """
    serializer_class = SubscriptionPaymentSerializer
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return SubscriptionPayment.objects.filter(user=self.request.user)


class RentSummaryView(APIView):
    """
    Get rent summary for landlord
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        if user.user_type != 'landlord':
            return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)

        # Calculate total collected and outstanding rent
        properties = Property.objects.filter(landlord=user)
        units = Unit.objects.filter(property_obj__in=properties)

        total_collected = Payment.objects.filter(
            unit__in=units,
            status='Success'
        ).aggregate(total=Sum('amount'))['total'] or 0

        total_outstanding = units.aggregate(
            outstanding=Sum('rent_remaining')
        )['outstanding'] or 0

        return Response({
            "total_collected": total_collected,
            "total_outstanding": total_outstanding,
            "properties_count": properties.count(),
            "units_count": units.count()
        })


class UnitTypeListView(generics.ListAPIView):
    """
    List unit types for landlord
    """
    permission_classes = [IsAuthenticated]

    def get_queryset(self):
        return UnitType.objects.filter(landlord=self.request.user)


class InitiateDepositPaymentView(APIView):
    """
    Initiate deposit payment for unit
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        unit_id = request.data.get('unit_id')
        test = request.data.get('test', False)
        unit = get_object_or_404(Unit, id=unit_id)

        if not unit.is_available:
            return Response({"error": "Unit is not available"}, status=status.HTTP_400_BAD_REQUEST)

        tenant = request.user
        amount = unit.deposit
        phone_number = tenant.phone_number

        if not phone_number:
            return Response({"error": "Phone number is required"}, status=status.HTTP_400_BAD_REQUEST)

        # Generate access token
        access_token = generate_access_token()
        if not access_token:
            return Response({"error": "Failed to generate M-Pesa access token"}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

        # Prepare STK push request
        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')

        if test:
            shortcode = 174379
            passkey = 'Safaricom123!!'
            party_a = 600986
            party_b = 600000
            phone = 254708374149
        else:
            shortcode = settings.MPESA_SHORTCODE
            passkey = settings.MPESA_PASSKEY
            party_a = phone_number
            party_b = settings.MPESA_SHORTCODE
            phone = phone_number

        password = shortcode + passkey + timestamp

        payload = {
            "BusinessShortCode": shortcode,
            "Password": password,
            "Timestamp": timestamp,
            "TransactionType": "CustomerPayBillOnline",
            "Amount": int(amount),
            "PartyA": party_a,
            "PartyB": party_b,
            "PhoneNumber": phone,
            "CallBackURL": settings.MPESA_DEPOSIT_CALLBACK_URL,
            "AccountReference": f"Deposit-{unit.unit_code}",
            "TransactionDesc": f"Deposit payment for {unit.unit_number}"
        }

        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

        # Make STK push request
        if settings.MPESA_ENV == "sandbox":
            url = "https://sandbox.safaricom.co.ke/mpesa/stkpush/v1/processrequest"
        else:
            url = "https://api.safaricom.co.ke/mpesa/stkpush/v1/processrequest"

        response = requests.post(url, json=payload, headers=headers)
        response_data = response.json()

        if response.status_code == 200 and response_data.get("ResponseCode") == "0":
            # Create pending deposit payment record
            payment = Payment.objects.create(
                tenant=tenant,
                unit=unit,
                amount=amount,
                status="Pending",
                payment_type="deposit"
            )

            # Cache checkout request ID for callback
            cache.set(f"stk_deposit_{response_data['CheckoutRequestID']}", {
                "payment_id": payment.id,
                "unit_id": unit.id,
                "amount": float(amount)
            }, timeout=300)  # 5 minutes

            return Response({
                "success": True,
                "message": "Deposit STK push initiated successfully",
                "checkout_request_id": response_data["CheckoutRequestID"],
                "payment_id": payment.id
            })

        else:
            return Response({
                "error": "Failed to initiate deposit STK push",
                "details": response_data
            }, status=status.HTTP_400_BAD_REQUEST)



class DepositPaymentStatusView(APIView):
    """
    Check deposit payment status
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, payment_id):
        payment = get_object_or_404(Payment, id=payment_id)

        # Check if user has permission to view this payment
        if request.user.user_type == 'tenant' and payment.tenant != request.user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        if request.user.user_type == 'landlord' and payment.unit.property_obj.landlord != request.user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        return Response({
            "payment_id": payment.id,
            "status": payment.status,
            "amount": payment.amount,
            "mpesa_receipt": payment.mpesa_receipt
        })


class CleanupPendingPaymentsView(APIView):
    """
    Clean up old pending payments
    """
    permission_classes = [IsAuthenticated]

    def post(self, request):
        # Delete pending payments older than 1 hour
        cutoff_time = timezone.now() - timedelta(hours=1)
        deleted_count = Payment.objects.filter(
            status='Pending',
            transaction_date__lt=cutoff_time
        ).delete()

        return Response({"message": f"Cleaned up {deleted_count[0]} pending payments"})


# ------------------------------
# CSV EXPORT VIEWS
# ------------------------------

class LandLordCSVView(APIView):
    """
    Export landlord payment data as CSV
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, property_id):
        user = request.user
        if user.user_type != 'landlord':
            return Response({"error": "Only landlords can access this endpoint"}, status=status.HTTP_403_FORBIDDEN)

        property_obj = get_object_or_404(Property, id=property_id, landlord=user)
        units = Unit.objects.filter(property_obj=property_obj)
        payments = Payment.objects.filter(unit__in=units, status='Success')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="landlord_payments_{property_obj.name}.csv"'

        writer = csv.writer(response)
        writer.writerow(['Unit Number', 'Tenant', 'Amount', 'Date', 'M-Pesa Receipt'])

        for payment in payments:
            writer.writerow([
                payment.unit.unit_number,
                payment.tenant.full_name if payment.tenant else '',
                payment.amount,
                payment.transaction_date.strftime('%Y-%m-%d'),
                payment.mpesa_receipt or ''
            ])

        return response


class TenantCSVView(APIView):
    """
    Export tenant payment data as CSV
    """
    permission_classes = [IsAuthenticated]

    def get(self, request, unit_id):
        user = request.user
        unit = get_object_or_404(Unit, id=unit_id)

        if user.user_type == 'tenant' and unit.tenant != user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        if user.user_type == 'landlord' and unit.property_obj.landlord != user:
            return Response({"error": "Permission denied"}, status=status.HTTP_403_FORBIDDEN)

        payments = Payment.objects.filter(unit=unit, status='Success')

        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="tenant_payments_unit_{unit.unit_number}.csv"'

        writer = csv.writer(response)
        writer.writerow(['Amount', 'Date', 'M-Pesa Receipt', 'Type'])

        for payment in payments:
            writer.writerow([
                payment.amount,
                payment.transaction_date.strftime('%Y-%m-%d'),
                payment.mpesa_receipt or '',
                payment.payment_type
            ])

        return response


class TestMpesaView(APIView):
    """
    Test endpoint for M-Pesa integration
    """
    permission_classes = [IsAuthenticated]

    def get(self, request):
        return Response({
            "message": "M-Pesa test endpoint",
            "mpesa_env": settings.MPESA_ENV,
            "shortcode": settings.MPESA_SHORTCODE
        })

    def post(self, request):
        # Test token generation
        token = generate_access_token()
        if token:
            return Response({
                "success": True,
                "message": "M-Pesa token generated successfully",
                "token_preview": token[:10] + "..."
            })
        else:
            return Response({
                "success": False,
                "message": "Failed to generate M-Pesa token"
            }, status=400)

//Communication app
# services/messaging.py
from django.conf import settings
from django.core.mail import send_mail


def send_bulk_emails(tenants):
    """
    Send rent reminder emails to a list of tenants.
    Each tenant receives a personalized message with their outstanding balance.
    """
    for tenant in tenants:
        subject = "Rent Payment Reminder"
        message = (
            f"Hello {tenant.full_name},\n\n"
            f"This is a reminder to pay your rent.\n"
            f"Outstanding balance: KES {tenant.unit.rent_remaining}."
        )
        try:
            send_mail(subject, message, settings.EMAIL_HOST_USER, [tenant.email])
        except Exception as e:
            print(f"Email failed for {tenant.email}: {e}")





def send_deadline_reminder_emails(tenants):
    """
    Send rent deadline reminder emails to a list of tenants.
    Each email includes the payment deadline date, outstanding balance, and login link.
    """
    for tenant in tenants:
        unit = tenant.unit
        subject = "Rent Payment Deadline Reminder"
        login_link = f"{settings.FRONTEND_URL}/login"
        message = (
            f"Hello {tenant.full_name},\n\n"
            f"This is a reminder that your rent payment is due on {unit.rent_due_date}.\n"
            f"Outstanding balance: KES {unit.rent_remaining}.\n\n"
            f"Please log in to your account to make the payment: {login_link}\n\n"
            "Thank you,\n"
            "Makau Rentals Team"
        )
        try:
            send_mail(subject, message, settings.EMAIL_HOST_USER, [tenant.email])
        except Exception as e:
            print(f"Email failed for {tenant.email}: {e}")


def send_deadline_reminders():
    """
    Send reminders to tenants based on their custom reminder preferences.
    """
    from datetime import timedelta
    from django.utils import timezone
    from accounts.models import CustomUser

    today = timezone.now().date()
    tenants_to_remind = []

    # Get all tenants with units and outstanding rent
    tenants = CustomUser.objects.filter(
        user_type="tenant",
        unit__isnull=False,
        unit__rent_remaining__gt=0
    ).select_related('unit')

    for tenant in tenants:
        unit = tenant.unit
        if tenant.reminder_mode == 'days_before':
            reminder_date = unit.rent_due_date - timedelta(days=tenant.reminder_value)
            if reminder_date == today:
                tenants_to_remind.append(tenant)
        elif tenant.reminder_mode == 'fixed_day':
            if today.day == tenant.reminder_value:
                # Optionally, check if due date is within a reasonable period, e.g., next 30 days
                if unit.rent_due_date and unit.rent_due_date >= today and (unit.rent_due_date - today).days <= 30:
                    tenants_to_remind.append(tenant)

    if tenants_to_remind:
        send_deadline_reminder_emails(tenants_to_remind)

# TODO:
# - This module handles sending bulk emails to tenants for rent reminders.
# - It uses Django's send_mail for email notifications.
# - The send_deadline_reminders() function is scheduled via Celery Beat to run automatically.

def send_report_email(report):
    """
    Send an email to the landlord when a new report is created.
    """
    landlord = report.unit.property_obj.landlord
    subject = f"New Issue Report: {report.issue_title}"
    issue_url = f"{settings.FRONTEND_URL}/reports/{report.id}"
    message = (
        f"Hello {landlord.full_name},\n\n"
        f"A new issue report has been submitted by tenant {report.tenant.full_name}.\n\n"
        f"Unit Number: {report.unit.unit_number}\n"
        f"Issue Category: {report.issue_category}\n"
        f"Priority Level: {report.priority_level}\n"
        f"Issue Title: {report.issue_title}\n"
        f"Description:\n{report.description}\n\n"
        f"To resolve the issue, please visit: {issue_url}\n\n"
        "Best regards,\n"
        "Makau Rentals System"
    )
    try:
        send_mail(subject, message, settings.EMAIL_HOST_USER, [landlord.email])
    except Exception as e:
        print(f"Failed to send report email: {e}")


def send_landlord_email(subject, message, tenants):
    """
    Send a custom email from landlord to a list of tenants.
    """
    recipient_emails = [tenant.email for tenant in tenants]
    try:
        send_mail(subject, message, settings.EMAIL_HOST_USER, recipient_emails)
    except Exception as e:
        print(f"Failed to send landlord email: {e}")
from django.db import models
from accounts.models import CustomUser, Unit
from django.utils import timezone

from django.db import models
from accounts.models import CustomUser, Unit
from django.utils import timezone

class Report(models.Model):
    ISSUE_CATEGORIES = [
        ('electrical', 'Electrical'),
        ('plumbing', 'Plumbing'),
        ('noise', 'Noise'),
        ('safety', 'Safety/Violence'),
        ('wifi', 'WiFi'),
        ('maintenance', 'General Maintenance'),
        ('pest', 'Pest Control'),
        ('security', 'Security'),
        ('cleanliness', 'Cleanliness'),
        ('other', 'Other'),
    ]

    PRIORITY_LEVELS = [
        ('low', 'Low'),
        ('medium', 'Medium'),
        ('high', 'High'),
        ('urgent', 'Urgent'),
    ]

    STATUS_CHOICES = [
        ('open', 'Open'),
        ('in_progress', 'In Progress'),
        ('resolved', 'Resolved'),
        ('closed', 'Closed'),
    ]

    # Basic required fields
    tenant = models.ForeignKey(
        CustomUser, 
        on_delete=models.CASCADE, 
        related_name='reports',
        limit_choices_to={'user_type': 'tenant'}
    )
    unit = models.ForeignKey(
        Unit, 
        on_delete=models.CASCADE, 
        related_name='reports'
    )
    issue_category = models.CharField(max_length=20, choices=ISSUE_CATEGORIES)
    priority_level = models.CharField(max_length=10, choices=PRIORITY_LEVELS, default='medium')
    issue_title = models.CharField(max_length=255)
    description = models.TextField()
    status = models.CharField(max_length=15, choices=STATUS_CHOICES, default='open')

    # Additional fields you added
    reported_date = models.DateTimeField(auto_now_add=True)
    resolved_date = models.DateTimeField(null=True, blank=True)
    assigned_to = models.ForeignKey(
        CustomUser, 
        on_delete=models.SET_NULL, 
        null=True, 
        blank=True,
        limit_choices_to={'user_type': 'landlord'},
        related_name='assigned_reports'
    )
    estimated_cost = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    actual_cost = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    
    # File attachments
    attachment = models.FileField(upload_to='report_attachments/', null=True, blank=True)
    
    class Meta:
        ordering = ['-reported_date']
        verbose_name = 'Maintenance Report'
        verbose_name_plural = 'Maintenance Reports'

    def save(self, *args, **kwargs):
        # Auto-assign priority based on category if not set
        if not self.priority_level or self.priority_level == 'medium':
            urgent_categories = ['safety', 'electrical', 'plumbing', 'security']
            self.priority_level = 'urgent' if self.issue_category in urgent_categories else 'medium'
        
        # Auto-set resolved_date when status changes to resolved
        if self.status == 'resolved' and not self.resolved_date:
            self.resolved_date = timezone.now()
        elif self.status != 'resolved' and self.resolved_date:
            self.resolved_date = None
            
        super().save(*args, **kwargs)

    @property
    def days_open(self):
        """Calculate how many days the report has been open"""
        if self.status == 'resolved' and self.resolved_date:
            return (self.resolved_date - self.reported_date).days
        return (timezone.now() - self.reported_date).days

    @property
    def is_urgent(self):
        """Check if the report is urgent based on priority and days open"""
        return self.priority_level == 'urgent' or self.days_open > 7

    def __str__(self):
        return f"Report #{self.id} - {self.issue_title} ({self.tenant.full_name})"
from rest_framework import permissions
from django.core.cache import cache
from accounts.models import CustomUser, Subscription

class IsTenantWithUnit(permissions.BasePermission):
    """
    Allows access only to tenants who have at least one assigned unit.
    """
    def has_permission(self, request, view):
        if not request.user.is_authenticated or request.user.user_type != 'tenant':
            return False
        
        # Check cache first
        cache_key = f"tenant_has_unit:{request.user.id}"
        has_unit = cache.get(cache_key)
        
        if has_unit is None:
            # Check if tenant has any units assigned (OneToOneField so use hasattr)
            has_unit = hasattr(request.user, 'unit') and request.user.unit is not None
            cache.set(cache_key, has_unit, timeout=300)  # Cache for 5 minutes
        
        return has_unit

class IsLandlordWithActiveSubscription(permissions.BasePermission):
    """
    Allows access only to landlords with active subscriptions.
    """
    def has_permission(self, request, view):
        if not request.user.is_authenticated or request.user.user_type != 'landlord':
            return False
        
        # Use cache to avoid repeated database queries
        cache_key = f"subscription_status:{request.user.id}"
        has_active_sub = cache.get(cache_key)
        
        if has_active_sub is None:
            try:
                subscription = Subscription.objects.get(user=request.user)
                has_active_sub = subscription.is_active()
            except Subscription.DoesNotExist:
                has_active_sub = False
            cache.set(cache_key, has_active_sub, timeout=300)  # Cache for 5 minutes
        
        return has_active_sub
from rest_framework import serializers
from .models import Report
from accounts.models import CustomUser, Unit, Property

class ReportSerializer(serializers.ModelSerializer):
    tenant_name = serializers.CharField(source='tenant.full_name', read_only=True)
    unit_number = serializers.CharField(source='unit.unit_number', read_only=True)
    property_name = serializers.CharField(source='unit.property_obj.name', read_only=True)
    days_open = serializers.IntegerField(read_only=True)
    
    class Meta:
        model = Report
        fields = [
            'id', 'tenant', 'tenant_name', 'unit', 'unit_number', 'property_name',
            'issue_category', 'priority_level', 'issue_title', 'description',
            'status', 'reported_date', 'resolved_date', 'assigned_to',
            'estimated_cost', 'actual_cost', 'attachment', 'days_open'
        ]
        read_only_fields = ['tenant', 'reported_date', 'days_open']

    def validate(self, data):
        # Ensure tenants can only report issues for their own units
        if self.instance and self.instance.tenant != self.context['request'].user:
            raise serializers.ValidationError("You can only modify your own reports")
        return data

class UpdateReportStatusSerializer(serializers.ModelSerializer):
    class Meta:
        model = Report
        fields = ['status']
        read_only_fields = []

class SendEmailSerializer(serializers.Serializer):
    subject = serializers.CharField(max_length=255)
    message = serializers.CharField()
    tenants = serializers.ListField(
        child=serializers.PrimaryKeyRelatedField(queryset=CustomUser.objects.filter(user_type='tenant')),
        required=False,
        allow_empty=True
    )
    send_to_all = serializers.BooleanField(default=False)

    def validate(self, data):
        if not data.get('send_to_all') and not data.get('tenants'):
            raise serializers.ValidationError("Either provide a list of tenants or set send_to_all to True.")
        if data.get('send_to_all') and data.get('tenants'):
            raise serializers.ValidationError("Cannot specify tenants when send_to_all is True.")
        return data

    def validate_tenants(self, value):
        # Ensure all tenants belong to the landlord's properties
        request = self.context.get('request')
        if request and request.user.user_type == 'landlord':
            landlord_properties = Property.objects.filter(landlord=request.user)
            tenant_units = Unit.objects.filter(property_obj__in=landlord_properties, tenant__in=value)
            valid_tenants = set(tenant_units.values_list('tenant', flat=True))
            if set(t.id for t in value) != valid_tenants:
                raise serializers.ValidationError("Some tenants do not belong to your properties.")
        return value
from django.urls import path
from .views import (
    CreateReportView,
    OpenReportsView,
    UrgentReportsView,
    InProgressReportsView,
    ResolvedReportsView,
    UpdateReportStatusView,
    SendEmailView,
)

urlpatterns = [
    # Create a new report (POST)
    path('reports/create/', CreateReportView.as_view(), name='create-report'),  # Added /create/

    # List open reports for the authenticated user (GET)
    path('reports/open/', OpenReportsView.as_view(), name='open-reports'),

    # List urgent reports for the authenticated user (GET)
    path('reports/urgent/', UrgentReportsView.as_view(), name='urgent-reports'),

    # List in-progress reports for the authenticated user (GET)
    path('reports/in-progress/', InProgressReportsView.as_view(), name='in-progress-reports'),

    # List resolved reports for the authenticated user (GET)
    path('reports/resolved/', ResolvedReportsView.as_view(), name='resolved-reports'),

    # Update the status of a specific report (PATCH/PUT)
    path('reports/<int:pk>/update-status/', UpdateReportStatusView.as_view(), name='update-report-status'),

    # Send email to tenants (POST)
    path('reports/send-email/', SendEmailView.as_view(), name='send-email'),  # Added /reports/ prefix
]
from rest_framework import generics, permissions
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import Report
from .serializers import ReportSerializer, UpdateReportStatusSerializer, SendEmailSerializer
from .permissions import IsTenantWithUnit, IsLandlordWithActiveSubscription
from accounts.permissions import CanAccessReport
from accounts.models import CustomUser, Unit
from .messaging import send_landlord_email
from rest_framework.permissions import IsAuthenticated


class CreateReportView(generics.CreateAPIView):
    queryset = Report.objects.all()
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated, IsTenantWithUnit]

    def perform_create(self, serializer):
        report = serializer.save()
        # Import here to avoid circular imports
        from app.tasks import send_report_email_task
        send_report_email_task.delay(report.id)

class OpenReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user

        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='open')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='open')
        return Report.objects.none()

class UrgentReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, priority_level='urgent')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, priority_level='urgent')
        return Report.objects.none()

class InProgressReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='in_progress')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='in_progress')
        return Report.objects.none()

class ResolvedReportsView(generics.ListAPIView):
    serializer_class = ReportSerializer
    permission_classes = [permissions.IsAuthenticated]

    def get_queryset(self):
        user = self.request.user
        if user.user_type == 'tenant':
            return Report.objects.filter(tenant=user, status='resolved')
        elif user.user_type == 'landlord':
            return Report.objects.filter(unit__property_obj__landlord=user, status='resolved')
        return Report.objects.none()

class UpdateReportStatusView(generics.UpdateAPIView):
    queryset = Report.objects.all()
    serializer_class = UpdateReportStatusSerializer
    permission_classes = [permissions.IsAuthenticated, CanAccessReport]

class SendEmailView(APIView):
    permission_classes = [permissions.IsAuthenticated, IsLandlordWithActiveSubscription]

    def post(self, request):
        serializer = SendEmailSerializer(data=request.data, context={'request': request})
        if serializer.is_valid():
            subject = serializer.validated_data['subject']
            message = serializer.validated_data['message']
            send_to_all = serializer.validated_data['send_to_all']

            if send_to_all:
                # Get all tenants of the landlord
                landlord_properties = request.user.property_set.all()
                tenants = CustomUser.objects.filter(
                    user_type='tenant',
                    unit__property_obj__in=landlord_properties
                ).distinct()
            else:
                tenants = serializer.validated_data['tenants']

            send_landlord_email(subject, message, tenants)
            return Response({"message": "Emails sent successfully."}, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
class ReportStatisticsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        user = request.user
        if user.user_type == 'landlord':
            reports = Report.objects.filter(unit__property_obj__landlord=user)
        else:
            reports = Report.objects.filter(tenant=user)
            
        stats = {
            'total': reports.count(),
            'open': reports.filter(status='open').count(),
            'in_progress': reports.filter(status='in_progress').count(),
            'resolved': reports.filter(status='resolved').count(),
            'urgent': reports.filter(priority_level='urgent', status__in=['open', 'in_progress']).count(),
            'average_resolution_time': self.get_average_resolution_time(reports),
        }
        return Response(stats)
    
    def get_average_resolution_time(self, reports):
        resolved_reports = reports.filter(status='resolved', resolved_date__isnull=False)
        if not resolved_reports:
            return 0
            
        total_days = sum((r.resolved_date - r.reported_date).days for r in resolved_reports)
        return total_days / resolved_reports.count()
"""
Django settings for app project.

Generated by 'django-admin startproject' using Django 5.2.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

from pathlib import Path
from datetime import timedelta
from decouple import config
import os
# For scheduling automatic sending messages to tenants every month
from celery.schedules import crontab
from urllib.parse import urlparse, parse_qsl
import os
from dotenv import load_dotenv

import os

load_dotenv()

# Auto create superuser on startup
DJANGO_SUPERUSER_USERNAME = os.environ.get('DJANGO_SUPERUSER_USERNAME')
DJANGO_SUPERUSER_EMAIL = os.environ.get('DJANGO_SUPERUSER_EMAIL')
DJANGO_SUPERUSER_PASSWORD = os.environ.get('DJANGO_SUPERUSER_PASSWORD')
DJANGO_SUPERUSER_FULL_NAME = os.environ.get('DJANGO_SUPERUSER_FULL_NAME', 'GEORGE MWANGI')

CELERY_BEAT_SCHEDULE = {
    # Tenants get notified daily at 9 AM
    "daily-rent-due-check": {
        "task": "app.tasks.notify_due_rent_task",
        "schedule": crontab(hour=9, minute=0),
    },
    # Landlords get a daily summary at 9:30 AM
    "daily-landlord-summary": {
        "task": "app.tasks.landlord_summary_task",
        "schedule": crontab(hour=9, minute=30),
    },
    # Deadline reminders at 10 AM
    "daily-deadline-reminders": {
        "task": "app.tasks.deadline_reminder_task",
        "schedule": crontab(hour=10, minute=0),
    },
}


# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# Ensure logs directory exists
logs_dir = BASE_DIR / 'logs'
logs_dir.mkdir(parents=True, exist_ok=True)


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = config('SECRET_KEY')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = config('DEBUG', default=False, cast=bool)

ALLOWED_HOSTS = ['*']


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    #dependencies
    'rest_framework',
    'rest_framework_simplejwt',
    "django_crontab",
    'corsheaders',
    #local apps
    'accounts',
    'communication',
    'payments',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'app.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# for CORS handling 
# TODO: Update CORS settings for production use
CORS_ALLOW_ALL_ORIGINS = True

WSGI_APPLICATION = 'app.wsgi.application'

AUTH_USER_MODEL = 'accounts.CustomUser'

#Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# Commented out for testing - PostgreSQL configuration
# tmpPostgres = urlparse(os.getenv("DATABASE_URL"))
# DATABASES = {
#     'default': {
#         'ENGINE': 'django.db.backends.postgresql',
#         'NAME': tmpPostgres.path.replace('/', ''),
#         'USER': tmpPostgres.username,
#         'PASSWORD': tmpPostgres.password,
#         'HOST': tmpPostgres.hostname,
#         'PORT': 5432,
#         'OPTIONS': dict(parse_qsl(tmpPostgres.query)),
#     }
# }

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'test_db.sqlite3',
    }
}

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
}
# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')  # or your preferred path
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'


# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
}

# Cache Configuration - Use DummyCache for Render deployment
CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.dummy.DummyCache",
    }
}

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
        },
    },
    'root': {
        'handlers': ['console'],
        'level': 'INFO',
    },
    'loggers': {
        'accounts.views': {
            'handlers': ['console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}

# Email Configuration
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
EMAIL_HOST = 'smtp.gmail.com'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
# TODO: Use environment variables or Django decouple to manage sensitive info
# TODO: Creaete a dedicated email for the application
EMAIL_HOST_USER = config('EMAIL_HOST_USER')
EMAIL_HOST_PASSWORD = config('EMAIL_HOST_PASSWORD')

# Mpesa Configuration
# TODO: Update these settings with your actual Mpesa credentials
MPESA_ENV = "sandbox"  # or "production"
MPESA_CONSUMER_KEY = config('MPESA_CONSUMER_KEY', default='')
MPESA_CONSUMER_SECRET = config('MPESA_CONSUMER_SECRET', default='')
MPESA_SHORTCODE = config('MPESA_SHORTCODE', default='')
MPESA_PASSKEY = config('MPESA_PASSKEY', default='')
MPESA_INITIATOR_NAME = config('MPESA_INITIATOR_NAME', default='')  # For B2C payments
MPESA_SECURITY_CREDENTIAL = config('MPESA_SECURITY_CREDENTIAL', default='')  # For B2C payments
MPESA_CALLBACK_URL = config('MPESA_CALLBACK_URL', default='')
# Provide explicit callback URLs expected by payment views. If not set, fall back to MPESA_CALLBACK_URL
MPESA_RENT_CALLBACK_URL = config('MPESA_RENT_CALLBACK_URL', default=MPESA_CALLBACK_URL)
MPESA_SUBSCRIPTION_CALLBACK_URL = config('MPESA_SUBSCRIPTION_CALLBACK_URL', default=MPESA_CALLBACK_URL)
MPESA_DEPOSIT_CALLBACK_URL = config('MPESA_DEPOSIT_CALLBACK_URL', default=MPESA_CALLBACK_URL)
# B2C callback URLs
MPESA_B2C_RESULT_URL = config('MPESA_B2C_RESULT_URL', default=MPESA_CALLBACK_URL)
MPESA_B2C_TIMEOUT_URL = config('MPESA_B2C_TIMEOUT_URL', default=MPESA_CALLBACK_URL)

# Logging Configuration - Enhanced for payment callbacks
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'handlers': {
        'console': {
            'class': 'logging.StreamHandler',
            'formatter': 'verbose',
        },
        'file': {
            'class': 'logging.FileHandler',
            'filename': os.path.join(BASE_DIR, 'logs', 'payments.log'),
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'accounts.views': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        'payments.views': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}
# Celery configuration
REDIS_URL = config('REDIS_URL', default='redis://redis:6379/0')
CELERY_BROKER_URL = REDIS_URL
CELERY_RESULT_BACKEND = REDIS_URL


# TODO: Run celery using the following commands -> celery -A your_project worker -l info
# celery -A your_project beat -l info


# Frontend URL for password reset links
FRONTEND_URL = config('FRONTEND_URL', default='http://localhost:3000')

# Optional: S3 storage for uploaded id_document files via django-storages
# To enable, set USE_S3=True and provide the AWS_* env vars. Install: pip install django-storages[boto3]
USE_S3 = config('USE_S3', default=False, cast=bool)
if USE_S3:
    INSTALLED_APPS.append('storages')
    AWS_ACCESS_KEY_ID = config('AWS_ACCESS_KEY_ID')
    AWS_SECRET_ACCESS_KEY = config('AWS_SECRET_ACCESS_KEY')
    AWS_STORAGE_BUCKET_NAME = config('AWS_STORAGE_BUCKET_NAME')
    AWS_S3_REGION_NAME = config('AWS_S3_REGION_NAME', default=None)
    AWS_S3_CUSTOM_DOMAIN = f"{AWS_STORAGE_BUCKET_NAME}.s3.amazonaws.com"
    AWS_DEFAULT_ACL = None

    DEFAULT_FILE_STORAGE = 'storages.backends.s3boto3.S3Boto3Storage'
    MEDIA_URL = f"https://{AWS_S3_CUSTOM_DOMAIN}/media/"
else:
    MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
    MEDIA_URL = '/media/'

